{
  "hash": "dbb30fee5bdf5fcbc2d3812161ff8ce1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'SCD41: On Demand CO2 Sensor'\nauthor: Jesse Anderson\ndate: '2024-09-02'\ncategories:\n  - ESP32\n  - IoT\nformat: html\nimage: Mid-infrared_absorption_spectra_of_Gases.png\nfreeze: true\nexecute:\n  freeze: true\n---\n\nOriginal Post: 06/01/2024\n\nUpdate: I updated this post as of 09/02/24 to reflect the changes made to the CO2 sensor, namely using 5V for stability, an OLED screen for display, switches for wifi and calibration, and finally an obnoxious buzzer to let me know I should open my windows/door(\\>1500ppm).\n\n*Disclaimer: Please note that the information presented in this article is for informational purposes only. It is not intended to serve as health advice, engineering advice, or any form of professional guidance. Readers should consult with qualified professionals for specific health or engineering concerns and should not rely solely on the content of this article for making decisions. The authors and publishers of this article are not responsible for any actions taken based on the information provided herein.*\n\nIn this post I intend to cover the basics of SCD41 sensors, their technical performance, some MicroPython code to use with an ESP32 microcontroller(yes I know there are other ones out there), and some of the limitations/precautions one should take with this particular sensor.\n\n### What is an SCD41 Sensor?\n\nAn SCD41 sensor is Sensirion's miniature CO2 sensor. It uses a photoacoustic NDIR sensing principle along with Sensirion's patented technology to offer high accuracy at a competitive price. I personally picked up this sensor for \\$28.99, and it could likely be found at a lower price directly from the manufacturer or via platforms like AliExpress. The sensor also includes on-chip signal compensation with a built-in SHT4x humidity and temperature sensor to account for fluctuations in environmental conditions, ensuring accurate CO2 readings.\n\n### Technical Performance\n\n#### **Generalized CO2 Accuracy Specification:**\n\n-   **400-1,000 ppm:** ±(50 ppm + 2.5% of reading)\n\n-   **1,001-2,000 ppm:** ±(50 ppm + 3% of reading)\n\n-   **2,001-5,000 ppm:** ±(40 ppm + 5% of reading)\n\n#### Temperature and Humidity Specifications:\n\n-   **Temperature Accuracy**: -10°C to 60°C range with an accuracy of ±0.8°C\n\n-   **Humidity Accuracy**: 0-95% RH range with an accuracy of ±6% RH\n\n<details>\n\n<summary>More Detailed Specifications...</summary>\n\n```         \nSCD41 Sensor Series Specifications\n```\n\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Specification                       | Value                           | Unit                            |\n| ```                                 | ```                             | ```                             |\n+=====================================+=================================+=================================+\n| ```                                 | ```                             | ```                             |\n| CO₂ Measurement Range               | 0 - 40,000                      | ppm                             |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Measurement Accuracy (SCD41)    | 400 - 1,000                     | ±(50 ppm + 2.5% of reading) ppm |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | 1,001 - 2,000                   | ±(50 ppm + 3% of reading) ppm   |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | 2,001 - 5,000                   | ±(40 ppm + 5% of reading) ppm   |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Repeatability                   | Typical                         | ±10 ppm                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Response Time (τ63%)            | Typical                         | 60 s                            |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Additional Accuracy Drift (5 years) | 400 - 2,000, with ASC enabled   | ±(5 ppm + 0.5% of reading) ppm  |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Measurement Range          | 0 - 100                         | %RH                             |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Accuracy (typical)         | 15 °C – 35 °C, 20 %RH – 65 %RH  | ±6 %RH                          |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | -10 °C – 60 °C, 0 %RH – 100 %RH | ±9 %RH                          |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Repeatability              | Typical                         | ±0.4 %RH                        |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Response Time (τ63%)       | Typical                         | 90 s                            |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Accuracy Drift             | Yearly                          | <0.25 %RH                       |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Measurement Range       | -10 - 60                        | °C                              |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Accuracy (typical)      | 15 °C – 35 °C                   | ±0.8 °C                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | -10 °C – 60 °C                  | ±1.5 °C                         |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Repeatability           | -                               | ±0.1 °C                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Response Time (τ63%)    | Typical                         | 120 s                           |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Accuracy Drift          | Yearly                          | <0.03 °C                        |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Supply Voltage                      | 2.4 - 5.5                       | V                               |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Average Supply Current              | Typical                         | 15 mA                           |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Max. Supply Current                 | -                               | 205 mA                          |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n\n</details>\n\nThe response time is roughly every 2 minutes for temperature and every 90 seconds for humidity. Using the longest response time as a basis for our sampling, we get a sampling rate of once every 2 minutes. The sensor's extensive command set, clearly detailed in the datasheet, simplifies programming but requires familiarity with numerous commands.\n\nBefore diving into the fundamentals let's visit why we even care about CO2 to begin with.\n\n### CO2 Levels in an Enclosed Space\n\nCO2 levels increase in an enclosed room predictably with time as it is an enclosed system with n number of producers(people). We can actually do a mass balance around the system if we really wanted to to evaluate the amount of CO2 if we had values per person. A mass balance for CO2 in an enclosed room involves calculating how the amount of CO2 changes over time. Since the room is sealed, we start with an initial amount of CO2 and add the CO2 produced by people inside the room. By knowing how much CO2 each person produces per minute, we can estimate the total CO2 in the room after a certain period. This helps us predict how CO2 levels will rise as people continue to breathe, ensuring the air quality is monitored and maintained.\n\nAs CO2 levels increase a number of health complaints can arise and these health complaints are CO2 concentration dependent. The Wisconsin Department of Health Services outline a ppm to health complaint table:\n\n-   **400 ppm:** average outdoor air level.\n\n-   **400–1,000 ppm:** typical level found in occupied spaces with good air exchange.\n\n-   **1,000–2,000 ppm:** level associated with complaints of drowsiness and poor air.\n\n-   **2,000–5,000 ppm:** level associated with headaches, sleepiness, and stagnant, stale, stuffy air. Poor concentration, loss of attention, increased heart rate and slight nausea may also be present.\n\n-   **5,000 ppm:** this indicates unusual air conditions where high levels of other gases could also be present. Toxicity or oxygen deprivation could occur. This is the permissible exposure limit for daily workplace exposures.\n\n-   **40,000 ppm:** this level is immediately harmful due to oxygen deprivation.\n\nWe also see plenty of examples of CO2 levels reaching dangerous levels in enclosed spaces and I am including images along with associated posts:\n\nFrom <https://vair-monitor.com/>:\n\n![](V_Air_Monitor.png)\n\nFrom [https://cambridgecarbonfootprint.org/](https://cambridgecarbonfootprint.org/what-we-do/carbon-dioxide-monitoring/):\n\n![](Cambridge_CO2.png)\n\nNow if we move to a more engineering based analysis we go to <https://www.engineeringtoolbox.com/pollution-concentration-rooms-d_692.html> and find that the carbon dioxide concentration in a room is a function of:\n\n\n```{=html}\n<h1>CO2 Concentration Calculation</h1>\n    <p>The carbon dioxide concentration in a room filled with persons after a time \\( t \\) can be calculated as:</p>\n    <pre>\nc = (q / (n V)) [1 - (1 / e<sup>n t</sup>)] + (c<sub>0</sub> - c<sub>i</sub>) (1 / e<sup>n t</sup>) + c<sub>i</sub>                              \n    </pre>\n    <p>where:</p>\n    <ul>\n        <li><b>c</b> = carbon dioxide concentration in the room (m<sup>3</sup>/m<sup>3</sup>)</li>\n        <li><b>q</b> = carbon dioxide supplied to the room (m<sup>3</sup>/h)</li>\n        <li><b>V</b> = volume of the room (m<sup>3</sup>)</li>\n        <li><b>e</b> = the constant 2.718...</li>\n        <li><b>n</b> = number of air shifts per hour (1/h)</li>\n        <li><b>t</b> = time (hour, h)</li>\n        <li><b>c<sub>i</sub></b> = carbon dioxide concentration in the inlet ventilation air (m<sup>3</sup>/m<sup>3</sup>)</li>\n        <li><b>c<sub>0</sub></b> = carbon dioxide concentration in the room at start, \\( t=0 \\) (m<sup>3</sup>/m<sup>3</sup>)</li>\n    </ul>\n```\n\n\nCalculator(the same formula as Engineering Toolbox): Defaults: 2 people, 10ft by 10ft room with 10ft feet ceilings, 1 air change per hour, and the makeup air is the standard 400ppm CO2. This is of course assuming absolutely no gaps and you're truly enclosed. Worst case scenario and as this is not cited anywhere take with a grain of salt!\n\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CO2 Concentration Calculator</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        form {\n            margin-bottom: 20px;\n        }\n        label {\n            display: block;\n            margin-top: 10px;\n        }\n        input {\n            margin-top: 5px;\n        }\n        button {\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n    <h1>CO2 Concentration Calculator</h1>\n    <form id=\"co2-form\">\n        <label for=\"q\">q - Carbon dioxide supplied to the room per person (m<sup>3</sup>/h person):</label>\n        <input type=\"number\" id=\"q\" name=\"q\" value=\"0.01\" step=\"0.01\" required><br><br>\n\n        <label for=\"persons\">Number of persons in the room:</label>\n        <input type=\"number\" id=\"persons\" name=\"persons\" value=\"2\" required><br><br>\n\n        <label for=\"V\">V - Volume of the room (m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"V\" name=\"V\" value=\"28.3168\" required><br><br>\n\n        <label for=\"n\">n - Number of air shifts per hour (1/h):</label>\n        <input type=\"number\" id=\"n\" name=\"n\" value=\"0.125\" step=\"0.01\" required><br><br>\n\n        <label for=\"t\">t - Time (hour, h):</label>\n        <input type=\"number\" id=\"t\" name=\"t\" value=\"8\" step=\"0.1\" required><br><br>\n\n        <label for=\"ci\">ci - Carbon dioxide concentration in the make up air (m<sup>3</sup>/m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"ci\" name=\"ci\" value=\"0.0004\" step=\"0.0001\" required><br><br>\n\n        <label for=\"c0\">c0 - Carbon dioxide concentration in the room at start, t=0 (m<sup>3</sup>/m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"c0\" name=\"c0\" value=\"0.000\" step=\"0.0001\" required><br><br>\n\n        <button type=\"button\" onclick=\"calculateCO2()\">Calculate</button>\n    </form>\n\n    <h2>CO2 concentration: <span id=\"result\">0.00657 m<sup>3</sup>/m<sup>3</sup> (6574 ppm)</span></h2>\n\n    <script>\n        function calculateCO2() {\n            const q = parseFloat(document.getElementById('q').value);\n            const persons = parseFloat(document.getElementById('persons').value);\n            const V = parseFloat(document.getElementById('V').value);\n            const n = parseFloat(document.getElementById('n').value);\n            const t = parseFloat(document.getElementById('t').value);\n            const ci = parseFloat(document.getElementById('ci').value);\n            const c0 = parseFloat(document.getElementById('c0').value);\n            const e = Math.E;\n\n            const q_total = q * persons;\n            const part1 = (q_total / (n * V)) * (1 - (1 / Math.pow(e, n * t)));\n            const part2 = (c0 - ci) * (1 / Math.pow(e, n * t));\n            const c = part1 + part2 + ci;\n\n            const result = document.getElementById('result');\n            result.innerHTML = `${c.toFixed(5)} m<sup>3</sup>/m<sup>3</sup> (${(c * 1000000).toFixed(0)} ppm)`;\n        }\n    </script>\n</body>\n</html>\n```\n\n\nWe also have a similar calculator here: <https://www.soletairpower.fi/co2-calculator/>\n\nFor a more scientifically based study one can navigate to the following: <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7411428/>\n\nThe study gives a CO2 based occupancy estimation by correlating the levels of CO2 with the number of occupants in a room with the ultimate goal of reducing energy use by dynamically adjusting HVAC systems in real time. This means you don't ventilate rooms that are unoccupied or ventilate less if they are under-occupied. Its probably possible to tease out a solid mathematical formula that could be put into a calculator, but that is time away from the goal of this article SCD41 and CO2 measurement.\n\n### Characteristics of NDIR Sensors\n\nNDIR sensors measure CO2 by exploiting its property to absorb IR light at around 4.2 µm. They use a non-dispersive band-pass filter to allow only the relevant IR wavelengths to pass, hence the name Non-Dispersive Infrared. An image from [Wikipedia](https://en.wikipedia.org/wiki/Nondispersive_infrared_sensor) below outlines various gases and their Mid-infrared absorption spectra:\n\n![](Mid-infrared_absorption_spectra_of_Gases.png)\n\n### How does Photoacoustic NDIR Work?\n\nPhotoacoustic Non-Dispersive Infrared (NDIR) technology is an advanced method used in sensors like the SCD41 to measure gas concentrations, such as CO2, using light and sound. Here’s a brief explanation of how it works:\n\n### Key Steps in Photoacoustic NDIR\n\n1.  **Infrared Light Source**: An infrared (IR) light source emits light at wavelengths absorbed by CO2.\n\n2.  **Gas Absorption**: CO2 molecules absorb this light, causing them to heat up and vibrate.\n\n3.  **Pressure Waves**: The vibrations create tiny sound waves.\n\n4.  **Microphone Detection**: A microphone detects these pressure waves.\n\n5.  **Signal Processing**: The sensor converts these waves into electrical signals to determine CO2 concentration.\n\n6.  **Output**: The final CO2 concentration is displayed for monitoring or further processing.\n\nThis method offers high sensitivity and accuracy, making it suitable for real-time CO2 monitoring in various applications, including indoor air quality and industrial processes. The SCD41 sensor is compact, low-power, and cost-effective, ideal for integration into diverse systems.\n\n### Transmissive NDIR\n\nThese sensors feature an IR emitter and an optical detector at opposite ends of an optical cavity. Here's a quick rundown of how they work:\n\n1.  **IR Emitter**: Emits light through the gas sample.\n\n2.  **Absorption by CO2**: CO2 absorbs specific wavelengths of the IR light.\n\n3.  **Detection**: The detector measures the transmitted IR light.\n\n4.  **Calculation**: CO2 concentration is calculated based on the difference in emitted and transmitted light.\n\nTransmissive NDIR sensors require precise positioning and minimal optical path length to ensure accurate readings.\n\n### TVOC Sensors and eCO2 Readings\n\nUsing Total Volatile Organic Compounds (TVOC) sensors, such as the Sensirion SGP30, to estimate CO2 levels is generally unreliable. TVOC sensors measure the concentration of various organic compounds in the air, which can include emissions from household products, cooking, cleaning agents, and even human breath. While these sensors are adept at detecting a wide range of VOCs, they are not designed to specifically measure CO2.\n\n#### Why TVOC Sensors Fall Short for CO2 Estimation\n\n-   **Broad Detection Spectrum**: TVOC sensors detect a broad range of organic compounds, not just CO2. This means they can be influenced by numerous sources of VOCs that are unrelated to CO2 levels, such as air fresheners, deodorizers, and various chemical products used indoors.\n\n-   **Lack of Specificity**: TVOC sensors lack the specificity required to accurately distinguish between CO2 and other VOCs. The presence of other VOCs can cause the sensor to give false indications of high CO2 levels.\n\n-   **Environmental Factors**: Various environmental factors such as temperature, humidity, and the presence of other gases can affect the readings of TVOC sensors, further complicating their accuracy when estimating CO2 levels.\n\nDespite these limitations, some vendors and manufacturers still promote TVOC sensors for CO2 estimation. This can be misleading for consumers who may believe they are getting accurate CO2 measurements. It is important for users to understand these limitations and consider more reliable methods, such as NDIR or photoacoustic sensors, for precise CO2 monitoring.\n\n#### Recommended Use of TVOC Sensors\n\nWhile TVOC sensors are not suitable for accurate CO2 measurement, they are valuable tools for:\n\n-   **Indoor Air Quality Monitoring**: Detecting the presence of harmful VOCs and identifying sources of indoor air pollution.\n\n-   **Health and Safety**: Ensuring that indoor environments are free from harmful concentrations of volatile organic compounds.\n\n-   **Industrial Applications**: Monitoring air quality in industrial settings to ensure compliance with safety regulations.\n\n### Comparing Low-Cost CO2 Sensors\n\n#### NDIR Sensors\n\nNDIR sensors measure CO2 based on gas absorption of IR light. They typically feature an IR emitter, dual channels for reference and measurement, and calculate CO2 concentration by comparing light absorption in these channels.\n\n#### Photo-Acoustic Sensors\n\nPhoto-acoustic sensors also measure absorption but use a microphone to detect the resulting pressure waves. They are smaller and do not rely on line-of-sight, making them suitable for compact applications.\n\nIn the image below we can see a comparison of the photoacoustic and transmissive NDIR sensors:\n\n![](NDIR_Comparison.png)\n\nWorking Principle References:\n\n<https://www.airgradient.com/blog/co2-sensors-photo-acoustic-vs-ndir/>\n\n<https://www.sensirion.com/resource/application_note/ndir-sensors-types>\n\n<https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7248969/>\n\n### Setting up the Circuit\n\nThe circuit used here is fairly simple as the SCD41 has 4 inputs.\n\n-   GROUND = GND\n\n-   Voltage_in = VDD\n\n-   SCL = Serial Clock Line\n\n-   SDA = Serial Data Line\n\nWe also use an LCD to monitor the output and one switch to control calibration on startup(two switches for toggling wifi). For the sake of being able to recreate this fast with the same board here are the associated pin numbers and side.\n\nSCD41\n\n-   SDA: 14-Left\n\n-   SCL: 17-Left\n\n-   VDD: 1-Right\n\n-   GND: 19-Left\n\nSwitch Calibration(Left Switch)\n\n-   Top(ON): 12-Right\n\n-   GND: Ground Bar-Right\n\n-   Bottom: N/A\n\nSwitch Wifi(Right Switch)\n\n-   Top(ON): 13-Right\n\n-   GND:Ground Bar - Right\n\n-   Bottom: N/A\n\nLCD\n\n-   SDA:10-Left\n\n-   SCL:7-Left\n\n-   VCC: 12-Right\n\n-   GND: Ground Bar-Right\n\nBuzzer\n\n-   15-Right\n\n-   Ground Bar - Right\n\nNote that with some changes to the code one can omit the LCD and the switches, but being able to calibrate on the fly with fresh air is nice as is having an offline version of the sensor. Also note that at 3.3V the peak supply current is typical 175mA with a max of 205mA and at 5.0V typical is 115mA with a max of 137mA. I personally experienced many issues using the 3.3V and switched to 5V and experienced absolutely no issues.\n\n![](CircuitSetup_bb.jpg)\n\nThe MicroPython library used is below. Simply open up the file in Thonny and save it to the device as SCD41.py so it can be imported in the main.py script. Note that the comments can be removed to cut down on space on your device. Implementing the Google Drive database and the ThingSpeak database are separate posts. See Raspberry Pi Sensor Server Project for more details on setting that up.\n\n<details>\n\n<summary>Library Code</summary>\n\n``` python\n# SCD41.py\n#This code is pretty heavily based off of the Sensirion type code at: https://github.com/octaprog7/SCD4x\n# And this library written by Sensirion: https://github.com/Sensirion/python-i2c-scd\n# This file should be saved as SCD41.py and called as import SCD41. See main.py in this folder for an example usage.\nimport time\nimport math\nfrom machine import SoftI2C, Pin, SPI\nimport micropython\nimport ustruct\n\n@micropython.native\ndef _calc_crc(sequence) -> int:\n    \"\"\"\n    Calculate CRC-8 checksum for the given sequence.\n    \"\"\"\n    return crc8(sequence, polynomial=0x31, init_value=0xFF)\n\n@micropython.native\ndef check_value(value: int, valid_range, error_msg: str) -> int:\n    \"\"\"\n    Check if the value is within the valid range. Raise ValueError if not.\n    \"\"\"\n    if value not in valid_range:\n        raise ValueError(error_msg)\n    return value\n\nclass Device:\n    \"\"\"Base class for devices.\"\"\"\n    def __init__(self, adapter, address: [int, SPI], big_byte_order: bool):\n        \"\"\"\n        Initialize the device with adapter, address, and byte order.\n        \"\"\"\n        self.adapter = adapter\n        self.address = address\n        self.big_byte_order = big_byte_order\n        self.msb_first = True\n\n    def _get_byteorder_as_str(self) -> tuple:\n        \"\"\"\n        Return the byte order as a string ('big' or 'little') and format character ('>' or '<').\n        \"\"\"\n        if self.is_big_byteorder():\n            return 'big', '>'\n        else:\n            return 'little', '<'\n\n    def unpack(self, fmt_char: str, source: bytes, redefine_byte_order: str = None) -> tuple:\n        \"\"\"\n        Unpack the given source bytes according to the format character and byte order.\n        \"\"\"\n        if not fmt_char:\n            raise ValueError(f\"Invalid length fmt_char parameter: {len(fmt_char)}\")\n        bo = self._get_byteorder_as_str()[1]\n        if redefine_byte_order is not None:\n            bo = redefine_byte_order[0]\n        return ustruct.unpack(bo + fmt_char, source)\n\n    @micropython.native\n    def is_big_byteorder(self) -> bool:\n        \"\"\"\n        Check if the device uses big byte order.\n        \"\"\"\n        return self.big_byte_order\n\nclass BaseSensor(Device):\n    \"\"\"Base class for sensors.\"\"\"\n    def get_id(self):\n        raise NotImplementedError\n\n    def soft_reset(self):\n        raise NotImplementedError\n\nclass Iterator:\n    \"\"\"Iterator class for sensors.\"\"\"\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        raise NotImplementedError\n\nclass BitField:\n    \"\"\"Class for working with bit fields.\"\"\"\n    def __init__(self, start: int, stop: int, alias: [str, None]):\n        \"\"\"\n        Initialize the bit field with start, stop, and alias.\n        \"\"\"\n        check(start, stop)\n        self.alias = alias\n        self.start = start\n        self.stop = stop\n        self.bitmask = _bitmask(start, stop)\n\n    def put(self, source: int, value: int) -> int:\n        \"\"\"\n        Write the value to the specified bit range in the source.\n        \"\"\"\n        src = source & ~self.bitmask\n        src |= (value << self.start) & self.bitmask\n        return src\n\n    def get(self, source: int) -> int:\n        \"\"\"\n        Get the value from the specified bit range in the source.\n        \"\"\"\n        return (source & self.bitmask) >> self.start\n\n@micropython.native\ndef put(start: int, stop: int, source: int, value: int) -> int:\n    \"\"\"\n    Write the value to the specified bit range in the source.\n    \"\"\"\n    check(start, stop)\n    bitmask = _bitmask(start, stop)\n    src = source & bitmask\n    src |= (value << start) & bitmask\n    return src\n\n@micropython.native\ndef _bitmask(start: int, stop: int) -> int:\n    \"\"\"\n    Generate a bitmask from start to stop bits.\n    \"\"\"\n    res = 0\n    for i in range(start, 1 + stop):\n        res |= 1 << i\n    return res\n\ndef check(start: int, stop: int):\n    \"\"\"\n    Check if start is less than or equal to stop. Raise ValueError if not.\n    \"\"\"\n    if start > stop:\n        raise ValueError(f\"Invalid start: {start}, stop value: {stop}\")\n\ndef _mpy_bl(value: int) -> int:\n    \"\"\"\n    Calculate the bit length of the value.\n    \"\"\"\n    if 0 == value:\n        return 0\n    return 1 + int(math.log2(abs(value)))\n\nclass BusAdapter:\n    \"\"\"Adapter class for bus communication.\"\"\"\n    def __init__(self, bus: [I2C, SPI]):\n        \"\"\"\n        Initialize the adapter with the bus.\n        \"\"\"\n        self.bus = bus\n\n    def get_bus_type(self) -> type:\n        \"\"\"\n        Return the type of the bus.\n        \"\"\"\n        return type(self.bus)\n\n    def read_register(self, device_addr: [int, Pin], reg_addr: int, bytes_count: int) -> bytes:\n        raise NotImplementedError\n\n    def write_register(self, device_addr: [int, Pin], reg_addr: int, value: [int, bytes, bytearray],\n                       bytes_count: int, byte_order: str):\n        raise NotImplementedError\n\n    def read(self, device_addr: [int, Pin], n_bytes: int) -> bytes:\n        raise NotImplementedError\n\n    def write(self, device_addr: [int, Pin], buf: bytes):\n        raise NotImplementedError\n\n    def write_const(self, device_addr: [int, Pin], val: int, count: int):\n        \"\"\"\n        Write a constant value to the device multiple times.\n        \"\"\"\n        if 0 == count:\n            return\n        bl = _mpy_bl(val)\n        if bl > 8:\n            raise ValueError(f\"The value must take no more than 8 bits! Current: {bl}\")\n        _max = 16\n        if count < _max:\n            _max = count\n        repeats = count // _max\n        b = bytearray([val for _ in range(_max)])\n        for _ in range(repeats):\n            self.write(device_addr, b)\n        remainder = count - _max * repeats\n        if remainder:\n            b = bytearray([val for _ in range(remainder)])\n            self.write(device_addr, b)\n\nclass I2cAdapter(BusAdapter):\n    \"\"\"Adapter class for I2C bus communication.\"\"\"\n    def __init__(self, bus: I2C):\n        super().__init__(bus)\n\n    def write_register(self, device_addr: int, reg_addr: int, value: [int, bytes, bytearray],\n                       bytes_count: int, byte_order: str):\n        \"\"\"\n        Write to the register of the device.\n        \"\"\"\n        buf = None\n        if isinstance(value, int):\n            buf = value.to_bytes(bytes_count, byte_order)\n        if isinstance(value, (bytes, bytearray)):\n            buf = value\n        return self.bus.writeto_mem(device_addr, reg_addr, buf)\n\n    def read_register(self, device_addr: int, reg_addr: int, bytes_count: int) -> bytes:\n        \"\"\"\n        Read from the register of the device.\n        \"\"\"\n        return self.bus.readfrom_mem(device_addr, reg_addr, bytes_count)\n\n    def read(self, device_addr: int, n_bytes: int) -> bytes:\n        \"\"\"\n        Read bytes from the device.\n        \"\"\"\n        return self.bus.readfrom(device_addr, n_bytes)\n\n    def readfrom_into(self, device_addr: int, buf):\n        \"\"\"\n        Read bytes from the device into the buffer.\n        \"\"\"\n        return self.bus.readfrom_into(device_addr, buf)\n\n    def read_buf_from_mem(self, device_addr: int, mem_addr, buf):\n        \"\"\"\n        Read bytes from the device memory into the buffer.\n        \"\"\"\n        return self.bus.readfrom_mem_into(device_addr, mem_addr, buf)\n\n    def write(self, device_addr: int, buf: bytes):\n        \"\"\"\n        Write bytes to the device.\n        \"\"\"\n        return self.bus.writeto(device_addr, buf)\n\n    def write_buf_to_mem(self, device_addr: int, mem_addr, buf):\n        \"\"\"\n        Write bytes to the device memory.\n        \"\"\"\n        return self.bus.writeto_mem(device_addr, mem_addr, buf)\n\nclass SCD4xSensirion(BaseSensor, Iterator):\n    \"\"\"Class for SCD4x Sensirion CO2 sensor.\"\"\"\n    def __init__(self, adapter: I2cAdapter, address=0x62, this_is_scd41: bool = True, check_crc: bool = True):\n        \"\"\"\n        Initialize the sensor with adapter, address, and settings.\n        \"\"\"\n        super().__init__(adapter, address, True)\n        self._buf_3 = bytearray((0 for _ in range(3)))\n        self._buf_9 = bytearray((0 for _ in range(9)))\n        self.check_crc = check_crc\n        self._low_power_mode = False\n        self._single_shot_mode = False\n        self._rht_only = False\n        self._isSCD41 = this_is_scd41\n        self.byte_order = self._get_byteorder_as_str()\n\n    def _get_local_buf(self, bytes_for_read: int) -> [None, bytearray]:\n        \"\"\"\n        Return the local buffer for reading.\n        \"\"\"\n        if bytes_for_read not in (0, 3, 9):\n            raise ValueError(f\"Invalid value for bytes_for_read: {bytes_for_read}\")\n        if not bytes_for_read:\n            return None\n        if 3 == bytes_for_read:\n            return self._buf_3\n        return self._buf_9\n\n    def _to_bytes(self, value, length: int):\n        \"\"\"\n        Convert value to bytes with specified length.\n        \"\"\"\n        byteorder = self.byte_order[0]\n        return value.to_bytes(length, byteorder)\n\n    def _write(self, buf: bytes) -> bytes:\n        \"\"\"\n        Write buffer to the device.\n        \"\"\"\n        return self.adapter.write(self.address, buf)\n\n    def _readfrom_into(self, buf):\n        \"\"\"\n        Read bytes from the device into the buffer.\n        \"\"\"\n        return self.adapter.readfrom_into(self.address, buf)\n\n    def _send_command(self, cmd: int, value: [bytes, None], wait_time: int = 0, bytes_for_read: int = 0,\n                      crc_index: range = None, value_index: tuple = None) -> [bytes, None]:\n        \"\"\"\n        Send a command to the sensor.\n        \"\"\"\n        raw_cmd = self._to_bytes(cmd, 2)\n        raw_out = raw_cmd\n        if value:\n            raw_out += value\n            raw_out += self._to_bytes(_calc_crc(value), 1)\n        self._write(raw_out)\n        if wait_time:\n            time.sleep_ms(wait_time)\n        if not bytes_for_read:\n            return None\n        b = self._get_local_buf(bytes_for_read)\n        self._readfrom_into(b)\n        check_value(len(b), (bytes_for_read,), f\"Invalid buffer length for cmd: {cmd}. Received {len(b)} out of {bytes_for_read}\")\n        if self.check_crc:\n            crc_from_buf = [b[i] for i in crc_index]\n            calculated_crc = [_calc_crc(b[rng.start:rng.stop]) for rng in value_index]\n            if crc_from_buf != calculated_crc:\n                raise ValueError(f\"Invalid CRC! Calculated{calculated_crc}. From buffer {crc_from_buf}\")\n        return b\n\n    def save_config(self):\n        \"\"\"\n        Save the sensor configuration to EEPROM.\n        \"\"\"\n        cmd = 0x3615\n        self._send_command(cmd, None, 800)\n\n    def get_id(self) -> tuple:\n        \"\"\"\n        Get the unique serial number of the sensor.\n        \"\"\"\n        cmd = 0x3682\n        b = self._send_command(cmd, None, 0, bytes_for_read=9,\n                               crc_index=range(2, 9, 3), value_index=(range(2), range(3, 5), range(6, 8)))\n        return tuple([(b[i] << 8) | b[i+1] for i in range(0, 9, 3)])\n\n    def soft_reset(self):\n        \"\"\"\n        Perform a soft reset of the sensor.\n        \"\"\"\n        return None\n\n    def exec_self_test(self) -> bool:\n        \"\"\"\n        Execute self-test on the sensor. Returns True if successful.\n        \"\"\"\n        cmd = 0x3639\n        length = 3\n        b = self._send_command(cmd, None, wait_time=10_000,\n                               bytes_for_read=length, crc_index=range(2, 3), value_index=(range(2),))\n        res = self.unpack(\"H\", b)[0]\n        return 0 == res\n\n    def reinit(self) -> None:\n        \"\"\"\n        Reinitialize the sensor by reloading user settings from EEPROM.\n        \"\"\"\n        cmd = 0x3646\n        self._send_command(cmd, None, 20)\n\n    def set_temperature_offset(self, offset: float):\n        \"\"\"\n        Set the temperature offset for the sensor.\n        \"\"\"\n        cmd = 0x241D\n        offset_raw = self._to_bytes(int(374.49142857 * offset), 2)\n        self._send_command(cmd, offset_raw, 1)\n\n    def get_temperature_offset(self) -> float:\n        \"\"\"\n        Get the temperature offset from the sensor.\n        \"\"\"\n        cmd = 0x2318\n        b = self._send_command(cmd, None, wait_time=1, bytes_for_read=3, crc_index=range(2, 3), value_index=(range(2),))\n        temp_offs = self.unpack(\"H\", b)[0]\n        return 0.0026702880859375 * temp_offs\n\n    def set_altitude(self, masl: int):\n        \"\"\"\n        Set the altitude for the sensor in meters above sea level.\n        \"\"\"\n        cmd = 0x2427\n        masl_raw = self._to_bytes(masl, 2)\n        self._send_command(cmd, masl_raw, 1)\n\n    def get_altitude(self) -> int:\n        \"\"\"\n        Get the altitude from the sensor in meters above sea level.\n        \"\"\"\n        cmd = 0x2322\n        b = self._send_command(cmd, None, wait_time=1, bytes_for_read=3, crc_index=range(2, 3), value_index=(range(2),))\n        return self.unpack(\"H\", b)[0]\n\n    def set_ambient_pressure(self, pressure: float):\n        \"\"\"\n        Set the ambient pressure for the sensor in Pascals.\n        \"\"\"\n        cmd = 0xE000\n        press_raw = self._to_bytes(int(pressure // 100), 2)\n        self._send_command(cmd, press_raw, 1)\n\n    def force_recalibration(self, target_co2_concentration: int) -> int:\n        \"\"\"\n        Force recalibration of the sensor with the target CO2 concentration.\n        \"\"\"\n        check_value(target_co2_concentration, range(2**16),\n                    f\"Invalid target CO2 concentration: {target_co2_concentration} ppm\")\n        cmd = 0x362F\n        target_raw = self._to_bytes(target_co2_concentration, 2)\n        b = self._send_command(cmd, target_raw, 400, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return self.unpack(\"h\", b)[0]\n\n    def is_auto_calibration(self) -> bool:\n        \"\"\"\n        Check if automatic self-calibration is enabled on the sensor.\n        \"\"\"\n        cmd = 0x2313\n        b = self._send_command(cmd, None, 1, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return 0 != self.unpack(\"H\", b)[0]\n\n    def set_auto_calibration(self, value: bool):\n        \"\"\"\n        Enable or disable automatic self-calibration on the sensor.\n        \"\"\"\n        cmd = 0x2416\n        value_raw = self._to_bytes(value, 2)\n        self._send_command(cmd, value_raw, 1, 3)\n\n    def set_measurement(self, start: bool, single_shot: bool = False, rht_only: bool = False):\n        \"\"\"\n        Start or stop periodic measurements, or perform a single shot measurement.\n        \"\"\"\n        if single_shot:\n            return self._single_shot_meas(rht_only)\n        return self._periodic_measurement(start)\n\n    def _periodic_measurement(self, start: bool):\n        \"\"\"\n        Start or stop periodic measurements.\n        \"\"\"\n        wt = 0\n        if start:\n            cmd = 0x21AC if self._low_power_mode else 0x21B1\n        else:\n            cmd = 0x3F86\n            wt = 500\n        self._send_command(cmd, None, wt)\n        self._single_shot_mode = False\n        self._rht_only = False\n\n    def get_meas_data(self) -> tuple:\n        \"\"\"\n        Get the measurement data from the sensor (CO2, temperature, and humidity).\n        \"\"\"\n        cmd = 0xEC05\n        val_index = (range(2), range(3, 5), range(6, 8))\n        b = self._send_command(cmd, None, 1, bytes_for_read=9,\n                               crc_index=range(2, 9, 3), value_index=val_index)\n        words = [self.unpack(\"H\", b[val_rng.start:val_rng.stop])[0] for val_rng in val_index]\n        return words[0], -45 + 0.0026703288 * words[1], 0.0015259022 * words[2]\n\n    def is_data_ready(self) -> bool:\n        \"\"\"\n        Check if the measurement data is ready to be read from the sensor.\n        \"\"\"\n        cmd = 0xE4B8\n        b = self._send_command(cmd, None, 1, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return bool(self.unpack(\"H\", b)[0] & 0b0000_0111_1111_1111)\n\n    @micropython.native\n    def get_conversion_cycle_time(self) -> int:\n        \"\"\"\n        Get the conversion cycle time of the sensor in milliseconds.\n        \"\"\"\n        if self.is_single_shot_mode and self.is_rht_only:\n            return 50\n        return 5000\n\n    def set_power(self, value: bool):\n        \"\"\"\n        Power up or power down the sensor.\n        \"\"\"\n        if not self._isSCD41:\n            return\n        cmd = 0x36F6 if value else 0x36E0\n        wt = 20 if value else 1\n        self._send_command(cmd, None, wt)\n\n    def _single_shot_meas(self, rht_only: bool = False):\n        \"\"\"\n        Perform a single shot measurement.\n        \"\"\"\n        if not self._isSCD41:\n            return\n        cmd = 0x2196 if rht_only else 0x219D\n        self._send_command(cmd, None, 0)\n        self._single_shot_mode = True\n        self._rht_only = rht_only\n\n    @property\n    def is_single_shot_mode(self) -> bool:\n        \"\"\"\n        Check if the sensor is in single shot mode.\n        \"\"\"\n        return self._single_shot_mode\n\n    @property\n    def is_rht_only(self) -> bool:\n        \"\"\"\n        Check if the sensor is in RHT-only mode.\n        \"\"\"\n        return self._rht_only\n\n    def __iter__(self):\n        return self\n\n    def __next__(self) -> [tuple, None]:\n        \"\"\"\n        Get the next set of measurement data.\n        \"\"\"\n        if self._single_shot_mode:\n            return None\n        if self.is_data_ready():\n            return self.get_meas_data()\n        return None\n\ndef pa_mmhg(value: float) -> float:\n    \"\"\"\n    Convert air pressure from Pascals to millimeters of mercury.\n    \"\"\"\n    return 7.50062E-3 * value\n\ndef crc8(sequence, polynomial: int, init_value: int = 0x00):\n    \"\"\"\n    Calculate CRC-8 checksum for the given sequence.\n    \"\"\"\n    mask = 0xFF\n    crc = init_value & mask\n    for item in sequence:\n        crc ^= item & mask\n        for _ in range(8):\n            if crc & 0x80:\n                crc = mask & ((crc << 1) ^ polynomial)\n            else:\n                crc = mask & (crc << 1)\n    return crc\n\ndef check_device_presence(i2c, address):\n    \"\"\"\n    Check if a device with the given address is present on the I2C bus.\n    \"\"\"\n    devices = i2c.scan()\n    return address in devices\n```\n\n</details>\n\nAnd once you have that done run the following code below on your device or save it to main.py, whatever you'd like. Note that we power cycle every 6 hours on the device to ensure that we don't run into memory issues. I encountered a memory leak that became a problem roughly 5 days in and felt that chasing it down was a waste compared to a simple power cycling using machine.reset().\n\n<details>\n\n<summary>Main Code</summary>\n\n``` python\n# main.py\n\nfrom machine import SoftI2C, Pin, reset, freq\nimport time\nimport gc  # Make sure we import gc\nfrom SCD41 import SCD4xSensirion, I2cAdapter, check_device_presence\nfrom ssd1306 import SSD1306_I2C  # Ensure you have the SSD1306 library\nimport urequests as requests\nimport network\nimport json\nimport utime\nimport usocket as socket\nimport ssl\nimport ntptime\n\n# ThingSpeak settings\nTHINGSPEAK_API_KEY = 'YOUR_KEY_HERE'\nTHINGSPEAK_URL = 'https://api.thingspeak.com/update'\nTHINGSPEAK_CHANNEL_ID = '00000000'\nTHINGSPEAK_BULK_UPDATE_URL = 'https://api.thingspeak.com/channels/'+str(THINGSPEAK_CHANNEL_ID)+'/bulk_update.json'\nSEND_TO_THINGSPEAK = True\n\nthingspeak_buffer = []  # Buffer for ThingSpeak data\n\n# Google Sheets settings\nSPREADSHEET_ID = 'VERY_LONG_SPREADSHEET_ID_HERE'\nRANGE_NAME = 'Sheet1!A1:C1'\nSHEET_NAME = 'Sheet1'\nGOOGLE_URL = 'https://script.google.com/macros/s/VERY_LONG_URL/exec'\n\n# WiFi settings\nSSID = 'YOUR_SSID'\nPASSWORD = 'WIFI_PSWD'\n# NTP sync settings\nlast_ntp_sync = 0  # Last NTP sync timestamp\nNTP_SYNC_INTERVAL = 3600  # Sync once per hour (in seconds)\n\nswitchOnWifi = Pin(32, Pin.IN, Pin.PULL_UP)\nswitchOnCalibrate = Pin(33, Pin.IN, Pin.PULL_UP)\nbuzzer = Pin(26, Pin.OUT)\n\nswitch_state_calibrate = switchOnCalibrate.value() # If switch is in up position we consider it on.\nprint(switch_state_calibrate)\n\nswitch_state_wifi = switchOnWifi.value() # If switch is in up position we consider it on.\nprint(switch_state_wifi)\n\nif switch_state_calibrate == 0:\n    print(\"Calibration switch is on! Calibrating Device...\")\nif switch_state_wifi == 0:\n    print(\"Wifi switch is on! Will use Wifi...\")\n    \n# Setup GPIO for OLED power\noled_power = Pin(19, Pin.OUT)\n\n# Function to get system status\ndef get_system_status(firstRun):\n    gc.collect()  # Ensure memory is collected before checking\n    free_heap = gc.mem_free()\n    total_heap = gc.mem_alloc() + free_heap\n    free_heap_percent = (free_heap / total_heap) * 100\n    if firstRun == True:\n        print(f\"Total heap memory: {total_heap} bytes\")\n        # Additional information about the system\n        print(f\"Frequency: {freq()} Hz\")\n    print(f\"Free heap memory: {free_heap} bytes ({free_heap_percent:.2f}%)\")\n    \ndef connect_wifi(ssid, password):\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    \n    # Check if already connected\n    if wlan.isconnected():\n        print(\"Already connected to WiFi\")\n        print(wlan.ifconfig())\n        return True\n        \n    print(\"Connecting to WiFi...\")\n    wlan.connect(ssid, password)\n    \n    # Wait with timeout instead of infinite loop\n    max_wait = 20  # 20 seconds timeout\n    while max_wait > 0 and not wlan.isconnected():\n        max_wait -= 1\n        time.sleep(1)\n        print(\"Connecting to WiFi...\")\n    \n    if wlan.isconnected():\n        print(\"Connected to WiFi\")\n        print(wlan.ifconfig())\n        return True\n    else:\n        print(\"Failed to connect to WiFi\")\n        return False\n    \ndef get_time_chicago():\n    \"\"\"Get Chicago time with NTP sync once per hour\"\"\"\n    global last_ntp_sync\n    current_time = time.time()\n    \n    # Check if we should sync (if an hour has passed since last sync)\n    if current_time - last_ntp_sync >= NTP_SYNC_INTERVAL:\n        print(f\"NTP sync needed (last sync was {(current_time - last_ntp_sync) / 60:.1f} minutes ago)\")\n        max_retries = 3  # Limit retries to save resources\n        for attempt in range(max_retries):\n            try:\n                ntptime.settime()\n                last_ntp_sync = time.time()  # Update the last sync time\n                print(f\"NTP sync successful at: {last_ntp_sync}\")\n                break\n            except OSError as e:\n                print(f\"Failed to get NTP time, attempt {attempt + 1} of {max_retries}. Error: {e}\")\n                time.sleep(1)\n        else:\n            print(\"Could not sync with NTP server, using internal RTC time\")\n    else:\n        minutes_since_sync = (current_time - last_ntp_sync) / 60\n        print(f\"Using cached time (next sync in {60 - minutes_since_sync:.1f} minutes)\")\n    \n    # Get current time and apply timezone offset\n    current_time = utime.localtime()\n    \n    # Determine if it is daylight saving time (DST)\n    month = current_time[1]\n    day = current_time[2]\n    hour = current_time[3]\n    if (month > 3 and month < 11) or (month == 3 and day >= 8 and hour >= 2) or (month == 11 and day < 1 and hour < 2):\n        is_dst = True\n    else:\n        is_dst = False\n    \n    offset = -6 * 3600 if not is_dst else -5 * 3600\n    local_time = utime.mktime(current_time) + offset\n    return utime.localtime(local_time)\n\n# Function to sound the buzzer\ndef sound_buzzer():\n    for _ in range(5):\n        buzzer.value(1)  # Turn on buzzer\n        time.sleep(0.25)  # 250 ms delay\n        buzzer.value(0)  # Turn off buzzer\n        time.sleep(0.25)  # 250 ms delay\n\n# Memory-optimized version of send_data_to_google_sheets\ndef send_data_to_google_sheets(data):\n    for attempt in range(3):\n        try:\n            # Force garbage collection before making a network connection\n            gc.collect()\n            \n            # Format the URL components separately to avoid long string concatenation\n            url = GOOGLE_URL\n            _, _, host, path = url.split('/', 3)\n            \n            # Format data carefully to minimize memory usage\n            encoded_data = \"Date=\" + data['date']\n            encoded_data += \"&Time=\" + data['time']\n            encoded_data += \"&CO2=\" + str(data['co2'])\n            encoded_data += \"&Temperature=\" + str(data['temp_f'])\n            encoded_data += \"&Humidity=\" + str(data['humidity'])\n            \n            s = None\n            try:\n                # Create socket first without SSL\n                addr = socket.getaddrinfo(host, 443)[0][-1]\n                s = socket.socket()\n                s.settimeout(15)  # Add timeout to prevent hanging\n                s.connect(addr)\n                \n                # Build request in parts\n                request_header = f\"POST /{path} HTTP/1.1\\r\\nHost: {host}\\r\\n\"\n                request_header += \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n                request_header += f\"Content-Length: {len(encoded_data)}\\r\\n\\r\\n\"\n                \n                # Wrap socket with SSL AFTER connecting\n                s = ssl.wrap_socket(s)\n                \n                # Send in two parts to reduce memory pressure\n                s.write(request_header)\n                s.write(encoded_data)\n                \n                # Read minimal response to verify success\n                response = s.read(64)\n                \n                # Close the socket before any other operations\n                s.close()\n                s = None\n                \n                print('Data sent to Google Sheets!')\n                gc.collect()  # Force collection after network operation\n                return True\n                \n            except Exception as e:\n                print('Failed to send data to Google Sheets:', e)\n                if s:\n                    try:\n                        s.close()\n                    except:\n                        pass\n                    s = None\n                gc.collect()  # Force collection after error\n                \n        except Exception as e:\n            print(f\"Exception occurred... Retrying sending data to Google Sheets {attempt + 1} of 3 attempts.\")\n            time.sleep(2)  # Wait before retry\n            gc.collect()  # Force collection\n    \n    return False  # Failed after all attempts\n\n# Memory-optimized ThingSpeak function\ndef send_data_to_thingspeak():\n    \"\"\"Send data to ThingSpeak.\"\"\"\n    if not SEND_TO_THINGSPEAK or not thingspeak_buffer:\n        return False\n        \n    for attempt in range(3):\n        try:\n            # Force garbage collection before sending\n            gc.collect()\n            \n            if len(thingspeak_buffer) > 1:\n                # Handle bulk update with memory considerations\n                bulk_send_thingspeak()\n            else:\n                # Handle single update\n                data = thingspeak_buffer.pop(0)\n                payload = {\n                    'api_key': THINGSPEAK_API_KEY,\n                    'field1': data['co2'],\n                    'field2': data['temp_f'],\n                    'field3': data['humidity']\n                }\n                \n                try:\n                    response = requests.post(THINGSPEAK_URL, json=payload)\n                    if response.status_code == 200:\n                        print('Data posted to ThingSpeak:', response.text)\n                        response.close()\n                        thingspeak_buffer.clear()  # Clear any remaining data\n                        return True\n                    else:\n                        print(f'Failed to send data to ThingSpeak: {response.status_code}')\n                        response.close()\n                except Exception as e:\n                    print('Failed to send data to ThingSpeak:', e)\n            \n            time.sleep(2)  # Wait before retry\n            gc.collect()  # Force collection\n            \n        except Exception as e:\n            print(f\"Exception occurred... Retrying sending data to ThingSpeak {attempt + 1} of 3 attempts.\")\n            time.sleep(2)  # Wait before retry\n            gc.collect()  # Force collection\n    \n    return False  # Failed after all attempts\n\n# Helper function to handle bulk ThingSpeak updates with memory considerations\ndef bulk_send_thingspeak():\n    # Force garbage collection\n    gc.collect()\n    \n    # Prepare payload\n    payload = {\n        'write_api_key': THINGSPEAK_API_KEY,\n        'updates': []\n    }\n    \n    # Add updates to payload\n    for data in thingspeak_buffer:\n        update = {\n            'created_at': f\"{data['date']} {data['time']} -0500\",\n            'field1': data['co2'],\n            'field2': data['temp_f'],\n            'field3': data['humidity']\n        }\n        payload['updates'].append(update)\n    \n    # Convert to JSON\n    json_data = json.dumps(payload)\n    \n    # Send request\n    try:\n        headers = {'Content-Type': 'application/json'}\n        response = requests.post(THINGSPEAK_BULK_UPDATE_URL, headers=headers, data=json_data)\n        \n        if response.status_code == 202:\n            print('Data posted to ThingSpeak (bulk update):', response.text)\n            thingspeak_buffer.clear()  # Clear the buffer after successful update\n            response.close()\n            return True\n        else:\n            print(f'Failed to send data to ThingSpeak (bulk update): {response.status_code}')\n            response.close()\n            return False\n    except Exception as e:\n        print('Failed to send data to ThingSpeak (bulk update):', e)\n        return False\n    finally:\n        gc.collect()  # Force collection\n\ndef get_sensor_reading(sensor, conversion_cycle_time, last_update_sensor):\n    \"\"\"Get a single sensor reading with a delay equal to the conversion cycle time.\"\"\"\n    update = False\n    while update == False:\n        time_since_update = time.time() - last_update_sensor\n        print(time_since_update)\n        if time_since_update >= 30:       \n            try:\n                # Check if data is ready\n                if sensor.is_data_ready():\n                    update = True\n                    return sensor.get_meas_data()\n                else:\n                    print(\"Data not ready.\")\n                    update = False\n                    time.sleep(1)\n                    return None\n            except OSError as e:\n                print(f\"Error during sensor reading: {e}\")\n                update = True\n                return None\n        else:\n            time.sleep(1)\n            update = False\n\nled = Pin(2, Pin.OUT)\nled.value(0)  # turn off red LED, doesn't work :L hard soldered in.\n\ndef main():\n    # Force garbage collection at start\n    gc.collect()\n    get_system_status(True)\n    \n    reading_count = 0\n    if switch_state_wifi == 0:\n        # Connect to WiFi\n        connect_wifi(SSID, PASSWORD)\n        # Initial time sync\n        get_time_chicago()\n    \n    # Initialize I2C communication with the specified pins and frequency\n    i2c = SoftI2C(scl=Pin(22), sda=Pin(21), freq=400_000)\n    device_address = 0x62\n\n    # Check if the device is present on the I2C bus\n    if not check_device_presence(i2c, device_address):\n        print(f\"Device with address {device_address} not found on I2C bus.\")\n        return\n\n    print(f\"Device with address {device_address} found on I2C bus.\")\n    oled_power.value(1)  # Turn on OLED display\n    \n    # Setup SoftI2C for OLED\n    i2c_oled = SoftI2C(scl=Pin(4), sda=Pin(5))\n    \n    # Scan for OLED device\n    print('Scanning for I2C devices...')\n    devices = i2c_oled.scan()\n    if len(devices) == 0:\n        print(\"No I2C OLED devices found.\")\n        OLEDaddress = None\n    else:\n        print('I2C OLED devices found:', len(devices))\n        OLEDaddress = devices[0]  # Assuming the first device found is the OLED\n        for device in devices:\n            print(\"Device address: \", hex(device))\n\n    # Initialize OLED if found\n    oled = None\n    if OLEDaddress:\n        print(\"Testing OLED...\")\n        oled = SSD1306_I2C(128, 64, i2c_oled)\n        i = 0\n        while i < 5:\n            time.sleep(1)\n            oled_power.value(1)\n            oled.fill(0)\n            oled.text(f\"Init: Test {i}\", 0, 0)\n            oled.show()\n            time.sleep(1)\n            i = i+1\n            oled_power.value(0)\n        oled_power.value(1)\n        oled.fill(0)\n        if switch_state_calibrate == 0:\n            oled.text(f\"CALIBRATION ON\", 0, 0)\n        if switch_state_calibrate == 1:\n            oled.text(f\"CALIBRATION OFF\", 0, 0)\n        if switch_state_wifi == 0:\n            oled.text(f\"WIFI ON\", 0, 10)\n        if switch_state_wifi == 1:\n            oled.text(f\"WIFI OFF\", 0, 10) \n        oled.show()\n        time.sleep(5)  # Reduced from 10 to 5 seconds to save power\n        oled_power.value(0)\n    \n    # Create an I2C adapter and sensor instance\n    adapter = I2cAdapter(i2c)\n    sensor = SCD4xSensirion(adapter)\n    sensor.set_measurement(start=False, single_shot=False) #if looping need to put sensor back into IDLE mode. Sensor can't exec self test if currently reading...\n    \n    # Check if sensor is good to go. Note you may need to power cycle to pass this test. Make sure 5V in.\n    selfTest = False\n    retry_count = 0\n    while selfTest == False and retry_count < 5:  # Added retry limit\n        try:\n            if sensor.exec_self_test():\n                print(\"Sensor self test shows good to go\")\n                selfTest = True\n            else:\n                print(\"Sensor self test failed!\")\n                selfTest = False\n                retry_count += 1\n                time.sleep(1)\n        except Exception as e:\n            print(\"Exception occurred:\", e)\n            retry_count += 1\n            time.sleep(1)\n\n    # Ensure the sensor is in IDLE mode\n    sensor.set_measurement(start=False, single_shot=False)\n\n    # Retrieve and display the sensor ID\n    sensor_id = sensor.get_id()\n    print(f\"Sensor ID: {sensor_id[0]:x}:{sensor_id[1]:x}:{sensor_id[2]:x}\")\n\n    # Retrieve and display the temperature offset\n    temp_offset = sensor.get_temperature_offset()\n    print(f\"Temperature offset: {temp_offset:.6f} F\")\n\n    # Set and retrieve the altitude (meters above sea level)\n    altitude = 198\n    retrieved_altitude = sensor.get_altitude()\n    print(f\"Desired Altitude: {altitude} m, Retrieved Altitude: {retrieved_altitude} m\")\n    if altitude != retrieved_altitude:\n        sensor.set_altitude(altitude)\n        print(f\"Altitude set to: {altitude}\")\n    \n    # Check if automatic self-calibration is enabled\n    if sensor.is_auto_calibration():\n        print(\"Automatic self-calibration is ON.\")\n    else:\n        print(\"Automatic self-calibration is OFF.\")\n    \n    # Start periodic measurement\n    sensor._low_power_mode = True\n    sensor.set_measurement(start=True, single_shot=False)\n    conversion_cycle_time = sensor.get_conversion_cycle_time()\n    last_update_sensor = time.time()\n    print(f\"Low Power Mode: {sensor._low_power_mode}\")\n    print(f\"Low power periodic measurement started with conversion cycle time: {conversion_cycle_time} ms\")\n    print(\"Periodic measurement started.\")\n\n    # Handle calibration mode\n    if switch_state_calibrate == 0:\n        # We want to calibrate it with this chunk if anything...\n        # Start periodic measurement\n        print(\"Performing sensor calibration in 30 seconds...\")\n        print(\"The sensor will be calibrated over 60 min in fresh air.\")\n        time.sleep(30)\n        sensorCycle = 0\n        calibrateMe = True\n\n        # Perform factory reset and reinitialize\n        sensor.perform_factory_reset()\n        print(\"Factory reset performed.\")\n        time.sleep(2)  # Wait for the factory reset to complete\n        \n        # Perform soft reset and reinitialize\n        sensor.soft_reset()\n        time.sleep(1)  # Wait for the reset to complete\n        sensor.set_measurement(start=False, single_shot=False) \n        time.sleep(1)\n        sensor.set_measurement(start=True, single_shot=False)\n        time.sleep(1)\n        print(\"Performing soft reset and reinitialization...\")\n\n        while sensorCycle < 60:\n            # Force garbage collection in calibration loop\n            gc.collect()\n            \n            conversion_cycle_time = sensor.get_conversion_cycle_time()\n            reading = get_sensor_reading(sensor, conversion_cycle_time, last_update_sensor)\n            if reading:\n                co2, temp, humidity = reading\n                last_update_sensor = time.time()\n                temp_f = temp * 9 / 5 + 32  # Convert to Fahrenheit\n                time.sleep(30)\n                sensorCycle += 1\n                print(f\"Continuous Reading: CO2: {co2} ppm, Temperature: {temp_f:.2f} F, Humidity: {humidity:.2f} %\")\n                print(f\"Sensor Cycled {sensorCycle} times of 60\")\n                \n                # Display on OLED during calibration\n                if oled:\n                    oled_power.value(1)\n                    oled.fill(0)\n                    oled.text(f\"CALIBRATING\", 0, 0)\n                    oled.text(f\"Cycle: {sensorCycle}/60\", 0, 10)\n                    oled.text(f\"CO2: {co2} ppm\", 0, 20)\n                    oled.text(f\"Temp: {temp_f:.1f}F\", 0, 30)\n                    oled.text(f\"Hum: {humidity:.1f}%\", 0, 40)\n                    oled.show()\n                    time.sleep(5)  # Show for 5 seconds\n                    oled_power.value(0)\n                \n                if sensorCycle == 59:\n                    if calibrateMe == True:\n                        print(\"Initiating forced recalibration...\")\n                        target_co2_concentration = int(426 * 1.15)  # Mauna Loa CO2 = 426.57ppm April 2024 + 15-20% differential for being near/in a major city(Chicago), to int bc need int for low level\n                        correction_value = sensor.force_recalibration(target_co2_concentration)\n                        print(f\"Forced recalibration completed with correction value: {correction_value} ppm\")\n                        sensor.set_auto_calibration(False)\n                        print(f\"Sensor Auto Calibration set to: {sensor.is_auto_calibration()}. Rerun the program after power cycling with the calibration commented out to double check persistence!\")\n                        sensor.save_config()\n                        print(\"Settings saved.\")\n            else:\n                # Reset the sensor and reinitialize if an error occurs\n                print(\"Attempting to reinitialize the sensor...\")\n                sensor.set_measurement(start=False, single_shot=False)\n                sensor.set_measurement(start=True, single_shot=False)\n    else:\n        print(\"Skipping calibration.\")\n    \n    # Main monitoring loop\n    while True:\n        try:\n            # Check memory status\n            gc.collect()\n            get_system_status(False)\n            \n            # Eventually...somewhere...memory will leak. Power Cycle every 6 hours for good measure.\n            if reading_count >= 360:\n                print(\"Scheduled restart after 360 readings\")\n                reset()\n                \n            date_str = None\n            reading = get_sensor_reading(sensor, conversion_cycle_time, last_update_sensor)\n            if reading:\n                co2, temp, humidity = reading\n                last_update_sensor = time.time()\n                temp_f = temp * 9 / 5 + 32\n                print(f\"Continuous Reading: CO2: {co2} ppm, Temperature: {temp_f:.2f} F, Humidity: {humidity:.2f} %\")\n                get_system_status(True)\n                reading_count = reading_count + 1\n                \n                # Check CO2 level and sound the buzzer if above threshold\n                if co2 > 1500:\n                    print(\"CO2 level exceeded 1500 ppm. Activating buzzer.\")\n                    sound_buzzer()\n                \n                # Handle data transmission if WiFi is enabled\n                if switch_state_wifi == 0:\n                    # Check WiFi connection and reconnect if needed\n                    if not network.WLAN(network.STA_IF).isconnected():\n                        print(\"WiFi connection lost, reconnecting...\")\n                        connect_wifi(SSID, PASSWORD)\n                    \n                    # Get current date and time (with hourly NTP sync)\n                    current_time = get_time_chicago()\n                    date_str = \"{:04}-{:02}-{:02}\".format(current_time[0], current_time[1], current_time[2])\n                    time_str = \"{:02}:{:02}:{:02}\".format(current_time[3], current_time[4], current_time[5])\n\n                    # Prepare data for sending\n                    data = {\n                        'date': date_str, \n                        'time': time_str, \n                        'co2': co2,\n                        'temp_f': temp_f,\n                        'humidity': humidity\n                    }\n                    \n                    # Collect garbage before network operations\n                    gc.collect()\n                    \n                    # Send to Google Sheets\n                    send_data_to_google_sheets(data)\n                    \n                    # Add to ThingSpeak buffer and send\n                    thingspeak_buffer.append(data)\n                    send_data_to_thingspeak()\n                elif switch_state_wifi == 1:\n                    thingspeak_buffer.clear()\n                \n                # OLED Logic - display for a shorter time to save power\n                if oled:\n                    oled_power.value(1)\n                    oled.fill(0)\n                    oled.text(f'Reading: {reading_count}', 0, 0)\n                    if date_str is not None:\n                        oled.text(f'Date: {date_str}', 0, 10)\n                        oled.text(f'Time: {time_str}', 0, 20)\n                    oled.text(f'CO2:{int(co2)}ppm', 0, 30)\n                    oled.text(f'Temp:{temp_f:.2f}F',0,40)\n                    oled.text(f'Hum:{humidity:.2f}%', 0, 50)\n                    oled.show()\n                    time.sleep(10)  # Reduced from 20 to 10 seconds to save power\n                    oled_power.value(0) \n                \n                # Force garbage collection after all operations\n                gc.collect()\n                \n        except Exception as e:\n            print(\"Error occurred:\", e)\n            time.sleep(5)  # Wait for 5 seconds before retrying\n            gc.collect()  # Force collection after error\n\nif __name__ == '__main__':\n    # Initialize garbage collection\n    gc.collect()\n    \n    try:\n        main()\n    except Exception as e:\n        print(\"Error occurred:\", e)\n        time.sleep(5)  # Wait for 5 seconds before retrying\n```\n\n</details>\n\nI'm not going to the go too much into the code as the SCD41 chip supports a variety of different modes and unless you do a deep dive into the datasheet and the code for some cursed reason you should be fine with the code above. I was able to log readings fairly close to the reported values for my town and breathing on the device and near the device increased the sensor readings reliably. I did note that the sensor took some time to get back down to baseline and took a bit to get up to the max with me breathing on it. It was roughly 2.5 minutes to get back down to baseline and that's roughly in line with what we would ideally sample at due to the humidity sampling interval mentioned in the technical specs above. See image below:\n\n![](CO2_Values.png)\n\n### Limitations of the SCD41\n\nAs mentioned above we will have a slight delay in logging values so the results won't be instantaneous. Additionally as mentioned by: <https://github.com/octaprog7/SCD4x> one will notice an increase in temperature reading from the sensor if the interval is less than 15 seconds as the sensor will self heat. Additionally, both the SCD40/41 sensors have an auto-calibrate mode which will take the lowest CO2 value from the past 7 days and assumes it is 400ppm. This can cause sensor drift over time unless one regularly(once a week) exposes the sensor to fresh air. It is possible to turn off this auto-calibration mode and one will note that in the code above\\[set_auto_calibration\\]. An anecdote from [User Anx2K on the r/ESP32 Reddit](https://www.reddit.com/r/esp32/comments/12y0x5k/warning_about_the_sensirion_scd4041_co2_sensors/) mentions that there is roughly a 40ppm(10%) drift year to year if one turns off auto calibration. Calibration takes 5 minutes, but is an inherently manual process. It would be nice to be somewhere near a weather monitoring station and set up this CO2 monitor alongside a MH-Z19B/C and MH-Z1+ which use NDIR and compare the initial and end of 24 hour values and assess drift.\n\n### Applications of the SCD41\n\nI am particularly interested in environmental monitoring to assess indoor air quality at a competitive price, allowing users to swap sensors in and out as needed. This flexibility is crucial for adapting to different monitoring requirements without significant additional costs.\n\nAdditionally, monitoring transient dump flows from businesses during off-hours (midnight to 3 AM) is vital. This involves tracking the release of CO2 and other gaseous components using the MQ-\\* sensor series. While this approach may not provide quantitative measurements due to various confounding factors, it serves as an initial assessment tool. This preliminary analysis can justify the purchase or lease of more advanced testing equipment, costing under \\$100 in upfront expenses and requiring only a few hours of labor.\n\nAnother intriguing experiment involves mapping a town with sensors placed every few blocks to monitor localized CO2 concentrations. This data can be correlated with consumer, commercial, and industrial activities, providing valuable insights into the town's environmental impact.\n\nOther applications include monitoring the respiratory activity of plants by measuring CO2 exchange in greenhouse or agricultural research settings. This can offer insights into plant health, photosynthetic efficiency, and growth patterns. Pairing this with R/G/B, UV, and light sensors can help determine several growth parameters. Note that NPK (Nitrogen/Phosphorous/Potassium) sensors are often unreliable based on my research. Therefore, it's better to use actual chemical testing methods or automate the chemical testing apparatus rather than relying on electronic sensors for these measurements.\n\nIn biotechnology and biochemical engineering contexts, monitoring CO2 levels in cellular cultures and bioreactors is essential. Maintaining precise CO2 concentrations ensures the optimal growth of microorganisms, which can significantly reduce production costs. This is particularly important for the pharmaceutical industry, biofuel production, and other bio-based manufacturing processes.\n\n### Personal Testing\n\nIn the recent heat wave I noted that it took roughly 30 minutes to air out the house and cut CO2 levels from \\~1200ppm to \\~650ppm.\n\n![](CO2_Reduction.jpg)\n\nIts interesting to note that the temperature jumped only a few degrees over the 30 minutes per below:\n\n![](Temp_Humidity.jpeg)\n\nThe actual \"enclosure\" of the sensor is just an old Raspberry Pi 5 Case box, a FLIRC model. The solid wire coming from the main board is hooked up to a smaller board used for data display, switching wifi/calibration on/off, and alerting users to high CO2(1500ppm). Note that I didn't feel like potentially burning the board or buying a soldering attachment to safely remove the LED so I covered it with some cardboard to remove some of the interference caused by the light on the sensor. See below:\n\nRaw Boards, no case\n\n![](SCD41_NoBox.jpg)\n\nWifi/Calibration Screen, with case\n\n![](SwitchesScreen.jpg)\n\nNormal Output, with case\n\n![](SCD41_Example_Data.jpg)\n\n### Conclusion\n\nThe SCD41 sensor offers a versatile and accurate solution for CO2 monitoring in various applications. For our particular application, provided we either calibrate it once at the beginning then once more every year we can enjoy accurate CO2 monitoring at a low price.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}