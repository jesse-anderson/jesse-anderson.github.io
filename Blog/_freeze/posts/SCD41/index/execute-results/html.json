{
  "hash": "b1f11d4096490b4c8aa8f0ea21089920",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'SCD41: On Demand CO2 Sensor'\nauthor: Jesse Anderson\ndate: '2024-09-02'\ncategories:\n  - ESP32\n  - IoT\nformat: html\nimage: Mid-infrared_absorption_spectra_of_Gases.png\nfreeze: true\nexecute:\n  freeze: true\n---\n\nOriginal Post: 06/01/2024\n\nUpdate: I updated this post as of 09/02/24 to reflect the changes made to the CO2 sensor, namely using 5V for stability, an OLED screen for display, switches for wifi and calibration, and finally an obnoxious buzzer to let me know I should open my windows/door(\\>1500ppm).\n\n*Disclaimer: Please note that the information presented in this article is for informational purposes only. It is not intended to serve as health advice, engineering advice, or any form of professional guidance. Readers should consult with qualified professionals for specific health or engineering concerns and should not rely solely on the content of this article for making decisions. The authors and publishers of this article are not responsible for any actions taken based on the information provided herein.*\n\nIn this post I intend to cover the basics of SCD41 sensors, their technical performance, some MicroPython code to use with an ESP32 microcontroller(yes I know there are other ones out there), and some of the limitations/precautions one should take with this particular sensor.\n\n### What is an SCD41 Sensor?\n\nAn SCD41 sensor is Sensirion's miniature CO2 sensor. It uses a photoacoustic NDIR sensing principle along with Sensirion's patented technology to offer high accuracy at a competitive price. I personally picked up this sensor for \\$28.99, and it could likely be found at a lower price directly from the manufacturer or via platforms like AliExpress. The sensor also includes on-chip signal compensation with a built-in SHT4x humidity and temperature sensor to account for fluctuations in environmental conditions, ensuring accurate CO2 readings.\n\n### Technical Performance\n\n#### **Generalized CO2 Accuracy Specification:**\n\n-   **400-1,000 ppm:** ±(50 ppm + 2.5% of reading)\n\n-   **1,001-2,000 ppm:** ±(50 ppm + 3% of reading)\n\n-   **2,001-5,000 ppm:** ±(40 ppm + 5% of reading)\n\n#### Temperature and Humidity Specifications:\n\n-   **Temperature Accuracy**: -10°C to 60°C range with an accuracy of ±0.8°C\n\n-   **Humidity Accuracy**: 0-95% RH range with an accuracy of ±6% RH\n\n<details>\n\n<summary>More Detailed Specifications...</summary>\n\n```         \nSCD41 Sensor Series Specifications\n```\n\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Specification                       | Value                           | Unit                            |\n| ```                                 | ```                             | ```                             |\n+=====================================+=================================+=================================+\n| ```                                 | ```                             | ```                             |\n| CO₂ Measurement Range               | 0 - 40,000                      | ppm                             |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Measurement Accuracy (SCD41)    | 400 - 1,000                     | ±(50 ppm + 2.5% of reading) ppm |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | 1,001 - 2,000                   | ±(50 ppm + 3% of reading) ppm   |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | 2,001 - 5,000                   | ±(40 ppm + 5% of reading) ppm   |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Repeatability                   | Typical                         | ±10 ppm                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| CO₂ Response Time (τ63%)            | Typical                         | 60 s                            |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Additional Accuracy Drift (5 years) | 400 - 2,000, with ASC enabled   | ±(5 ppm + 0.5% of reading) ppm  |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Measurement Range          | 0 - 100                         | %RH                             |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Accuracy (typical)         | 15 °C – 35 °C, 20 %RH – 65 %RH  | ±6 %RH                          |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | -10 °C – 60 °C, 0 %RH – 100 %RH | ±9 %RH                          |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Repeatability              | Typical                         | ±0.4 %RH                        |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Response Time (τ63%)       | Typical                         | 90 s                            |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Humidity Accuracy Drift             | Yearly                          | <0.25 %RH                       |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Measurement Range       | -10 - 60                        | °C                              |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Accuracy (typical)      | 15 °C – 35 °C                   | ±0.8 °C                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| ```                                 | -10 °C – 60 °C                  | ±1.5 °C                         |\n|                                     | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Repeatability           | -                               | ±0.1 °C                         |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Response Time (τ63%)    | Typical                         | 120 s                           |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Temperature Accuracy Drift          | Yearly                          | <0.03 °C                        |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Supply Voltage                      | 2.4 - 5.5                       | V                               |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Average Supply Current              | Typical                         | 15 mA                           |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n| ```                                 | ```                             | ```                             |\n| Max. Supply Current                 | -                               | 205 mA                          |\n| ```                                 | ```                             | ```                             |\n+-------------------------------------+---------------------------------+---------------------------------+\n\n</details>\n\nThe response time is roughly every 2 minutes for temperature and every 90 seconds for humidity. Using the longest response time as a basis for our sampling, we get a sampling rate of once every 2 minutes. The sensor's extensive command set, clearly detailed in the datasheet, simplifies programming but requires familiarity with numerous commands.\n\nBefore diving into the fundamentals let's visit why we even care about CO2 to begin with.\n\n### CO2 Levels in an Enclosed Space\n\nCO2 levels increase in an enclosed room predictably with time as it is an enclosed system with n number of producers(people). We can actually do a mass balance around the system if we really wanted to to evaluate the amount of CO2 if we had values per person. A mass balance for CO2 in an enclosed room involves calculating how the amount of CO2 changes over time. Since the room is sealed, we start with an initial amount of CO2 and add the CO2 produced by people inside the room. By knowing how much CO2 each person produces per minute, we can estimate the total CO2 in the room after a certain period. This helps us predict how CO2 levels will rise as people continue to breathe, ensuring the air quality is monitored and maintained.\n\nAs CO2 levels increase a number of health complaints can arise and these health complaints are CO2 concentration dependent. The Wisconsin Department of Health Services outline a ppm to health complaint table:\n\n-   **400 ppm:** average outdoor air level.\n\n-   **400–1,000 ppm:** typical level found in occupied spaces with good air exchange.\n\n-   **1,000–2,000 ppm:** level associated with complaints of drowsiness and poor air.\n\n-   **2,000–5,000 ppm:** level associated with headaches, sleepiness, and stagnant, stale, stuffy air. Poor concentration, loss of attention, increased heart rate and slight nausea may also be present.\n\n-   **5,000 ppm:** this indicates unusual air conditions where high levels of other gases could also be present. Toxicity or oxygen deprivation could occur. This is the permissible exposure limit for daily workplace exposures.\n\n-   **40,000 ppm:** this level is immediately harmful due to oxygen deprivation.\n\nWe also see plenty of examples of CO2 levels reaching dangerous levels in enclosed spaces and I am including images along with associated posts:\n\nFrom <https://vair-monitor.com/>:\n\n![](V_Air_Monitor.png)\n\nFrom [https://cambridgecarbonfootprint.org/](https://cambridgecarbonfootprint.org/what-we-do/carbon-dioxide-monitoring/):\n\n![](Cambridge_CO2.png)\n\nNow if we move to a more engineering based analysis we go to <https://www.engineeringtoolbox.com/pollution-concentration-rooms-d_692.html> and find that the carbon dioxide concentration in a room is a function of:\n\n\n```{=html}\n<h1>CO2 Concentration Calculation</h1>\n    <p>The carbon dioxide concentration in a room filled with persons after a time \\( t \\) can be calculated as:</p>\n    <pre>\nc = (q / (n V)) [1 - (1 / e<sup>n t</sup>)] + (c<sub>0</sub> - c<sub>i</sub>) (1 / e<sup>n t</sup>) + c<sub>i</sub>                              \n    </pre>\n    <p>where:</p>\n    <ul>\n        <li><b>c</b> = carbon dioxide concentration in the room (m<sup>3</sup>/m<sup>3</sup>)</li>\n        <li><b>q</b> = carbon dioxide supplied to the room (m<sup>3</sup>/h)</li>\n        <li><b>V</b> = volume of the room (m<sup>3</sup>)</li>\n        <li><b>e</b> = the constant 2.718...</li>\n        <li><b>n</b> = number of air shifts per hour (1/h)</li>\n        <li><b>t</b> = time (hour, h)</li>\n        <li><b>c<sub>i</sub></b> = carbon dioxide concentration in the inlet ventilation air (m<sup>3</sup>/m<sup>3</sup>)</li>\n        <li><b>c<sub>0</sub></b> = carbon dioxide concentration in the room at start, \\( t=0 \\) (m<sup>3</sup>/m<sup>3</sup>)</li>\n    </ul>\n```\n\nCalculator(the same formula as Engineering Toolbox): Defaults: 2 people, 10ft by 10ft room with 10ft feet ceilings, 1 air change per hour, and the makeup air is the standard 400ppm CO2. This is of course assuming absolutely no gaps and you're truly enclosed. Worst case scenario and as this is not cited anywhere take with a grain of salt!\n\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CO2 Concentration Calculator</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        form {\n            margin-bottom: 20px;\n        }\n        label {\n            display: block;\n            margin-top: 10px;\n        }\n        input {\n            margin-top: 5px;\n        }\n        button {\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n    <h1>CO2 Concentration Calculator</h1>\n    <form id=\"co2-form\">\n        <label for=\"q\">q - Carbon dioxide supplied to the room per person (m<sup>3</sup>/h person):</label>\n        <input type=\"number\" id=\"q\" name=\"q\" value=\"0.05\" step=\"0.01\" required><br><br>\n\n        <label for=\"persons\">Number of persons in the room:</label>\n        <input type=\"number\" id=\"persons\" name=\"persons\" value=\"2\" required><br><br>\n\n        <label for=\"V\">V - Volume of the room (m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"V\" name=\"V\" value=\"28.3168\" required><br><br>\n\n        <label for=\"n\">n - Number of air shifts per hour (1/h):</label>\n        <input type=\"number\" id=\"n\" name=\"n\" value=\"0.125\" step=\"0.01\" required><br><br>\n\n        <label for=\"t\">t - Time (hour, h):</label>\n        <input type=\"number\" id=\"t\" name=\"t\" value=\"8\" step=\"0.1\" required><br><br>\n\n        <label for=\"ci\">ci - Carbon dioxide concentration in the make up air (m<sup>3</sup>/m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"ci\" name=\"ci\" value=\"0.0004\" step=\"0.0001\" required><br><br>\n\n        <label for=\"c0\">c0 - Carbon dioxide concentration in the room at start, t=0 (m<sup>3</sup>/m<sup>3</sup>):</label>\n        <input type=\"number\" id=\"c0\" name=\"c0\" value=\"0.000\" step=\"0.0001\" required><br><br>\n\n        <button type=\"button\" onclick=\"calculateCO2()\">Calculate</button>\n    </form>\n\n    <h2>CO2 concentration: <span id=\"result\">0.00657 m<sup>3</sup>/m<sup>3</sup> (6574 ppm)</span></h2>\n\n    <script>\n        function calculateCO2() {\n            const q = parseFloat(document.getElementById('q').value);\n            const persons = parseFloat(document.getElementById('persons').value);\n            const V = parseFloat(document.getElementById('V').value);\n            const n = parseFloat(document.getElementById('n').value);\n            const t = parseFloat(document.getElementById('t').value);\n            const ci = parseFloat(document.getElementById('ci').value);\n            const c0 = parseFloat(document.getElementById('c0').value);\n            const e = Math.E;\n\n            const q_total = q * persons;\n            const part1 = (q_total / (n * V)) * (1 - (1 / Math.pow(e, n * t)));\n            const part2 = (c0 - ci) * (1 / Math.pow(e, n * t));\n            const c = part1 + part2 + ci;\n\n            const result = document.getElementById('result');\n            result.innerHTML = `${c.toFixed(5)} m<sup>3</sup>/m<sup>3</sup> (${(c * 1000000).toFixed(0)} ppm)`;\n        }\n    </script>\n</body>\n</html>\n```\n\nWe also have a similar calculator here: <https://www.soletairpower.fi/co2-calculator/>\n\nFor a more scientifically based study one can navigate to the following: <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7411428/>\n\nThe study gives a CO2 based occupancy estimation by correlating the levels of CO2 with the number of occupants in a room with the ultimate goal of reducing energy use by dynamically adjusting HVAC systems in real time. This means you don't ventilate rooms that are unoccupied or ventilate less if they are under-occupied. Its probably possible to tease out a solid mathematical formula that could be put into a calculator, but that is time away from the goal of this article SCD41 and CO2 measurement.\n\n### Characteristics of NDIR Sensors\n\nNDIR sensors measure CO2 by exploiting its property to absorb IR light at around 4.2 µm. They use a non-dispersive band-pass filter to allow only the relevant IR wavelengths to pass, hence the name Non-Dispersive Infrared. An image from [Wikipedia](https://en.wikipedia.org/wiki/Nondispersive_infrared_sensor) below outlines various gases and their Mid-infrared absorption spectra:\n\n![](Mid-infrared_absorption_spectra_of_Gases.png)\n\n### How does Photoacoustic NDIR Work?\n\nPhotoacoustic Non-Dispersive Infrared (NDIR) technology is an advanced method used in sensors like the SCD41 to measure gas concentrations, such as CO2, using light and sound. Here’s a brief explanation of how it works:\n\n### Key Steps in Photoacoustic NDIR\n\n1.  **Infrared Light Source**: An infrared (IR) light source emits light at wavelengths absorbed by CO2.\n\n2.  **Gas Absorption**: CO2 molecules absorb this light, causing them to heat up and vibrate.\n\n3.  **Pressure Waves**: The vibrations create tiny sound waves.\n\n4.  **Microphone Detection**: A microphone detects these pressure waves.\n\n5.  **Signal Processing**: The sensor converts these waves into electrical signals to determine CO2 concentration.\n\n6.  **Output**: The final CO2 concentration is displayed for monitoring or further processing.\n\nThis method offers high sensitivity and accuracy, making it suitable for real-time CO2 monitoring in various applications, including indoor air quality and industrial processes. The SCD41 sensor is compact, low-power, and cost-effective, ideal for integration into diverse systems.\n\n### Transmissive NDIR\n\nThese sensors feature an IR emitter and an optical detector at opposite ends of an optical cavity. Here's a quick rundown of how they work:\n\n1.  **IR Emitter**: Emits light through the gas sample.\n\n2.  **Absorption by CO2**: CO2 absorbs specific wavelengths of the IR light.\n\n3.  **Detection**: The detector measures the transmitted IR light.\n\n4.  **Calculation**: CO2 concentration is calculated based on the difference in emitted and transmitted light.\n\nTransmissive NDIR sensors require precise positioning and minimal optical path length to ensure accurate readings.\n\n### TVOC Sensors and eCO2 Readings\n\nUsing Total Volatile Organic Compounds (TVOC) sensors, such as the Sensirion SGP30, to estimate CO2 levels is generally unreliable. TVOC sensors measure the concentration of various organic compounds in the air, which can include emissions from household products, cooking, cleaning agents, and even human breath. While these sensors are adept at detecting a wide range of VOCs, they are not designed to specifically measure CO2.\n\n#### Why TVOC Sensors Fall Short for CO2 Estimation\n\n-   **Broad Detection Spectrum**: TVOC sensors detect a broad range of organic compounds, not just CO2. This means they can be influenced by numerous sources of VOCs that are unrelated to CO2 levels, such as air fresheners, deodorizers, and various chemical products used indoors.\n\n-   **Lack of Specificity**: TVOC sensors lack the specificity required to accurately distinguish between CO2 and other VOCs. The presence of other VOCs can cause the sensor to give false indications of high CO2 levels.\n\n-   **Environmental Factors**: Various environmental factors such as temperature, humidity, and the presence of other gases can affect the readings of TVOC sensors, further complicating their accuracy when estimating CO2 levels.\n\nDespite these limitations, some vendors and manufacturers still promote TVOC sensors for CO2 estimation. This can be misleading for consumers who may believe they are getting accurate CO2 measurements. It is important for users to understand these limitations and consider more reliable methods, such as NDIR or photoacoustic sensors, for precise CO2 monitoring.\n\n#### Recommended Use of TVOC Sensors\n\nWhile TVOC sensors are not suitable for accurate CO2 measurement, they are valuable tools for:\n\n-   **Indoor Air Quality Monitoring**: Detecting the presence of harmful VOCs and identifying sources of indoor air pollution.\n\n-   **Health and Safety**: Ensuring that indoor environments are free from harmful concentrations of volatile organic compounds.\n\n-   **Industrial Applications**: Monitoring air quality in industrial settings to ensure compliance with safety regulations.\n\n### Comparing Low-Cost CO2 Sensors\n\n#### NDIR Sensors\n\nNDIR sensors measure CO2 based on gas absorption of IR light. They typically feature an IR emitter, dual channels for reference and measurement, and calculate CO2 concentration by comparing light absorption in these channels.\n\n#### Photo-Acoustic Sensors\n\nPhoto-acoustic sensors also measure absorption but use a microphone to detect the resulting pressure waves. They are smaller and do not rely on line-of-sight, making them suitable for compact applications.\n\nIn the image below we can see a comparison of the photoacoustic and transmissive NDIR sensors:\n\n![](NDIR_Comparison.png)\n\nWorking Principle References:\n\n<https://www.airgradient.com/blog/co2-sensors-photo-acoustic-vs-ndir/>\n\n<https://www.sensirion.com/resource/application_note/ndir-sensors-types>\n\n<https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7248969/>\n\n### Setting up the Circuit\n\nThe circuit used here is fairly simple as the SCD41 has 4 inputs.\n\n-   GROUND = GND\n\n-   Voltage_in = VDD\n\n-   SCL = Serial Clock Line\n\n-   SDA = Serial Data Line\n\nWe also use an LCD to monitor the output and one switch to control calibration on startup(two switches for toggling wifi). For the sake of being able to recreate this fast with the same board here are the associated pin numbers and side.\n\nSCD41\n\n-   SDA: 14-Left\n\n-   SCL: 17-Left\n\n-   VDD: 1-Right\n\n-   GND: 19-Left\n\nSwitch Calibration(Left Switch)\n\n-   Top(ON): 12-Right\n\n-   GND: Ground Bar-Right\n\n-   Bottom: N/A\n\nSwitch Wifi(Right Switch)\n\n-   Top(ON): 13-Right\n\n-   GND:Ground Bar - Right\n\n-   Bottom: N/A\n\nLCD\n\n-   SDA:10-Left\n\n-   SCL:7-Left\n\n-   VCC: 12-Right\n\n-   GND: Ground Bar-Right\n\nBuzzer\n\n-   15-Right\n\n-   Ground Bar - Right\n\nNote that with some changes to the code one can omit the LCD and the switches, but being able to calibrate on the fly with fresh air is nice as is having an offline version of the sensor. Also note that at 3.3V the peak supply current is typical 175mA with a max of 205mA and at 5.0V typical is 115mA with a max of 137mA. I personally experienced many issues using the 3.3V and switched to 5V and experienced absolutely no issues.\n\n![](CircuitSetup_bb.jpg)\n\nThe MicroPython library used is below. Simply open up the file in Thonny and save it to the device as SCD41.py so it can be imported in the main.py script. Note that the comments can be removed to cut down on space on your device. Implementing the Google Drive database and the ThingSpeak database are separate posts. See Raspberry Pi Sensor Server Project for more details on setting that up.\n\n<details>\n\n<summary>Library Code</summary>\n\n``` python\n# SCD41.py\n#This code is pretty heavily based off of the Sensirion type code at: https://github.com/octaprog7/SCD4x\n# And this library written by Sensirion: https://github.com/Sensirion/python-i2c-scd\n# This file should be saved as SCD41.py and called as import SCD41. See main.py in this folder for an example usage.\nimport time\nimport math\nfrom machine import SoftI2C, Pin, SPI\nimport micropython\nimport ustruct\n\n@micropython.native\ndef _calc_crc(sequence) -> int:\n    \"\"\"\n    Calculate CRC-8 checksum for the given sequence.\n    \"\"\"\n    return crc8(sequence, polynomial=0x31, init_value=0xFF)\n\n@micropython.native\ndef check_value(value: int, valid_range, error_msg: str) -> int:\n    \"\"\"\n    Check if the value is within the valid range. Raise ValueError if not.\n    \"\"\"\n    if value not in valid_range:\n        raise ValueError(error_msg)\n    return value\n\nclass Device:\n    \"\"\"Base class for devices.\"\"\"\n    def __init__(self, adapter, address: [int, SPI], big_byte_order: bool):\n        \"\"\"\n        Initialize the device with adapter, address, and byte order.\n        \"\"\"\n        self.adapter = adapter\n        self.address = address\n        self.big_byte_order = big_byte_order\n        self.msb_first = True\n\n    def _get_byteorder_as_str(self) -> tuple:\n        \"\"\"\n        Return the byte order as a string ('big' or 'little') and format character ('>' or '<').\n        \"\"\"\n        if self.is_big_byteorder():\n            return 'big', '>'\n        else:\n            return 'little', '<'\n\n    def unpack(self, fmt_char: str, source: bytes, redefine_byte_order: str = None) -> tuple:\n        \"\"\"\n        Unpack the given source bytes according to the format character and byte order.\n        \"\"\"\n        if not fmt_char:\n            raise ValueError(f\"Invalid length fmt_char parameter: {len(fmt_char)}\")\n        bo = self._get_byteorder_as_str()[1]\n        if redefine_byte_order is not None:\n            bo = redefine_byte_order[0]\n        return ustruct.unpack(bo + fmt_char, source)\n\n    @micropython.native\n    def is_big_byteorder(self) -> bool:\n        \"\"\"\n        Check if the device uses big byte order.\n        \"\"\"\n        return self.big_byte_order\n\nclass BaseSensor(Device):\n    \"\"\"Base class for sensors.\"\"\"\n    def get_id(self):\n        raise NotImplementedError\n\n    def soft_reset(self):\n        raise NotImplementedError\n\nclass Iterator:\n    \"\"\"Iterator class for sensors.\"\"\"\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        raise NotImplementedError\n\nclass BitField:\n    \"\"\"Class for working with bit fields.\"\"\"\n    def __init__(self, start: int, stop: int, alias: [str, None]):\n        \"\"\"\n        Initialize the bit field with start, stop, and alias.\n        \"\"\"\n        check(start, stop)\n        self.alias = alias\n        self.start = start\n        self.stop = stop\n        self.bitmask = _bitmask(start, stop)\n\n    def put(self, source: int, value: int) -> int:\n        \"\"\"\n        Write the value to the specified bit range in the source.\n        \"\"\"\n        src = source & ~self.bitmask\n        src |= (value << self.start) & self.bitmask\n        return src\n\n    def get(self, source: int) -> int:\n        \"\"\"\n        Get the value from the specified bit range in the source.\n        \"\"\"\n        return (source & self.bitmask) >> self.start\n\n@micropython.native\ndef put(start: int, stop: int, source: int, value: int) -> int:\n    \"\"\"\n    Write the value to the specified bit range in the source.\n    \"\"\"\n    check(start, stop)\n    bitmask = _bitmask(start, stop)\n    src = source & bitmask\n    src |= (value << start) & bitmask\n    return src\n\n@micropython.native\ndef _bitmask(start: int, stop: int) -> int:\n    \"\"\"\n    Generate a bitmask from start to stop bits.\n    \"\"\"\n    res = 0\n    for i in range(start, 1 + stop):\n        res |= 1 << i\n    return res\n\ndef check(start: int, stop: int):\n    \"\"\"\n    Check if start is less than or equal to stop. Raise ValueError if not.\n    \"\"\"\n    if start > stop:\n        raise ValueError(f\"Invalid start: {start}, stop value: {stop}\")\n\ndef _mpy_bl(value: int) -> int:\n    \"\"\"\n    Calculate the bit length of the value.\n    \"\"\"\n    if 0 == value:\n        return 0\n    return 1 + int(math.log2(abs(value)))\n\nclass BusAdapter:\n    \"\"\"Adapter class for bus communication.\"\"\"\n    def __init__(self, bus: [I2C, SPI]):\n        \"\"\"\n        Initialize the adapter with the bus.\n        \"\"\"\n        self.bus = bus\n\n    def get_bus_type(self) -> type:\n        \"\"\"\n        Return the type of the bus.\n        \"\"\"\n        return type(self.bus)\n\n    def read_register(self, device_addr: [int, Pin], reg_addr: int, bytes_count: int) -> bytes:\n        raise NotImplementedError\n\n    def write_register(self, device_addr: [int, Pin], reg_addr: int, value: [int, bytes, bytearray],\n                       bytes_count: int, byte_order: str):\n        raise NotImplementedError\n\n    def read(self, device_addr: [int, Pin], n_bytes: int) -> bytes:\n        raise NotImplementedError\n\n    def write(self, device_addr: [int, Pin], buf: bytes):\n        raise NotImplementedError\n\n    def write_const(self, device_addr: [int, Pin], val: int, count: int):\n        \"\"\"\n        Write a constant value to the device multiple times.\n        \"\"\"\n        if 0 == count:\n            return\n        bl = _mpy_bl(val)\n        if bl > 8:\n            raise ValueError(f\"The value must take no more than 8 bits! Current: {bl}\")\n        _max = 16\n        if count < _max:\n            _max = count\n        repeats = count // _max\n        b = bytearray([val for _ in range(_max)])\n        for _ in range(repeats):\n            self.write(device_addr, b)\n        remainder = count - _max * repeats\n        if remainder:\n            b = bytearray([val for _ in range(remainder)])\n            self.write(device_addr, b)\n\nclass I2cAdapter(BusAdapter):\n    \"\"\"Adapter class for I2C bus communication.\"\"\"\n    def __init__(self, bus: I2C):\n        super().__init__(bus)\n\n    def write_register(self, device_addr: int, reg_addr: int, value: [int, bytes, bytearray],\n                       bytes_count: int, byte_order: str):\n        \"\"\"\n        Write to the register of the device.\n        \"\"\"\n        buf = None\n        if isinstance(value, int):\n            buf = value.to_bytes(bytes_count, byte_order)\n        if isinstance(value, (bytes, bytearray)):\n            buf = value\n        return self.bus.writeto_mem(device_addr, reg_addr, buf)\n\n    def read_register(self, device_addr: int, reg_addr: int, bytes_count: int) -> bytes:\n        \"\"\"\n        Read from the register of the device.\n        \"\"\"\n        return self.bus.readfrom_mem(device_addr, reg_addr, bytes_count)\n\n    def read(self, device_addr: int, n_bytes: int) -> bytes:\n        \"\"\"\n        Read bytes from the device.\n        \"\"\"\n        return self.bus.readfrom(device_addr, n_bytes)\n\n    def readfrom_into(self, device_addr: int, buf):\n        \"\"\"\n        Read bytes from the device into the buffer.\n        \"\"\"\n        return self.bus.readfrom_into(device_addr, buf)\n\n    def read_buf_from_mem(self, device_addr: int, mem_addr, buf):\n        \"\"\"\n        Read bytes from the device memory into the buffer.\n        \"\"\"\n        return self.bus.readfrom_mem_into(device_addr, mem_addr, buf)\n\n    def write(self, device_addr: int, buf: bytes):\n        \"\"\"\n        Write bytes to the device.\n        \"\"\"\n        return self.bus.writeto(device_addr, buf)\n\n    def write_buf_to_mem(self, device_addr: int, mem_addr, buf):\n        \"\"\"\n        Write bytes to the device memory.\n        \"\"\"\n        return self.bus.writeto_mem(device_addr, mem_addr, buf)\n\nclass SCD4xSensirion(BaseSensor, Iterator):\n    \"\"\"Class for SCD4x Sensirion CO2 sensor.\"\"\"\n    def __init__(self, adapter: I2cAdapter, address=0x62, this_is_scd41: bool = True, check_crc: bool = True):\n        \"\"\"\n        Initialize the sensor with adapter, address, and settings.\n        \"\"\"\n        super().__init__(adapter, address, True)\n        self._buf_3 = bytearray((0 for _ in range(3)))\n        self._buf_9 = bytearray((0 for _ in range(9)))\n        self.check_crc = check_crc\n        self._low_power_mode = False\n        self._single_shot_mode = False\n        self._rht_only = False\n        self._isSCD41 = this_is_scd41\n        self.byte_order = self._get_byteorder_as_str()\n\n    def _get_local_buf(self, bytes_for_read: int) -> [None, bytearray]:\n        \"\"\"\n        Return the local buffer for reading.\n        \"\"\"\n        if bytes_for_read not in (0, 3, 9):\n            raise ValueError(f\"Invalid value for bytes_for_read: {bytes_for_read}\")\n        if not bytes_for_read:\n            return None\n        if 3 == bytes_for_read:\n            return self._buf_3\n        return self._buf_9\n\n    def _to_bytes(self, value, length: int):\n        \"\"\"\n        Convert value to bytes with specified length.\n        \"\"\"\n        byteorder = self.byte_order[0]\n        return value.to_bytes(length, byteorder)\n\n    def _write(self, buf: bytes) -> bytes:\n        \"\"\"\n        Write buffer to the device.\n        \"\"\"\n        return self.adapter.write(self.address, buf)\n\n    def _readfrom_into(self, buf):\n        \"\"\"\n        Read bytes from the device into the buffer.\n        \"\"\"\n        return self.adapter.readfrom_into(self.address, buf)\n\n    def _send_command(self, cmd: int, value: [bytes, None], wait_time: int = 0, bytes_for_read: int = 0,\n                      crc_index: range = None, value_index: tuple = None) -> [bytes, None]:\n        \"\"\"\n        Send a command to the sensor.\n        \"\"\"\n        raw_cmd = self._to_bytes(cmd, 2)\n        raw_out = raw_cmd\n        if value:\n            raw_out += value\n            raw_out += self._to_bytes(_calc_crc(value), 1)\n        self._write(raw_out)\n        if wait_time:\n            time.sleep_ms(wait_time)\n        if not bytes_for_read:\n            return None\n        b = self._get_local_buf(bytes_for_read)\n        self._readfrom_into(b)\n        check_value(len(b), (bytes_for_read,), f\"Invalid buffer length for cmd: {cmd}. Received {len(b)} out of {bytes_for_read}\")\n        if self.check_crc:\n            crc_from_buf = [b[i] for i in crc_index]\n            calculated_crc = [_calc_crc(b[rng.start:rng.stop]) for rng in value_index]\n            if crc_from_buf != calculated_crc:\n                raise ValueError(f\"Invalid CRC! Calculated{calculated_crc}. From buffer {crc_from_buf}\")\n        return b\n\n    def save_config(self):\n        \"\"\"\n        Save the sensor configuration to EEPROM.\n        \"\"\"\n        cmd = 0x3615\n        self._send_command(cmd, None, 800)\n\n    def get_id(self) -> tuple:\n        \"\"\"\n        Get the unique serial number of the sensor.\n        \"\"\"\n        cmd = 0x3682\n        b = self._send_command(cmd, None, 0, bytes_for_read=9,\n                               crc_index=range(2, 9, 3), value_index=(range(2), range(3, 5), range(6, 8)))\n        return tuple([(b[i] << 8) | b[i+1] for i in range(0, 9, 3)])\n\n    def soft_reset(self):\n        \"\"\"\n        Perform a soft reset of the sensor.\n        \"\"\"\n        return None\n\n    def exec_self_test(self) -> bool:\n        \"\"\"\n        Execute self-test on the sensor. Returns True if successful.\n        \"\"\"\n        cmd = 0x3639\n        length = 3\n        b = self._send_command(cmd, None, wait_time=10_000,\n                               bytes_for_read=length, crc_index=range(2, 3), value_index=(range(2),))\n        res = self.unpack(\"H\", b)[0]\n        return 0 == res\n\n    def reinit(self) -> None:\n        \"\"\"\n        Reinitialize the sensor by reloading user settings from EEPROM.\n        \"\"\"\n        cmd = 0x3646\n        self._send_command(cmd, None, 20)\n\n    def set_temperature_offset(self, offset: float):\n        \"\"\"\n        Set the temperature offset for the sensor.\n        \"\"\"\n        cmd = 0x241D\n        offset_raw = self._to_bytes(int(374.49142857 * offset), 2)\n        self._send_command(cmd, offset_raw, 1)\n\n    def get_temperature_offset(self) -> float:\n        \"\"\"\n        Get the temperature offset from the sensor.\n        \"\"\"\n        cmd = 0x2318\n        b = self._send_command(cmd, None, wait_time=1, bytes_for_read=3, crc_index=range(2, 3), value_index=(range(2),))\n        temp_offs = self.unpack(\"H\", b)[0]\n        return 0.0026702880859375 * temp_offs\n\n    def set_altitude(self, masl: int):\n        \"\"\"\n        Set the altitude for the sensor in meters above sea level.\n        \"\"\"\n        cmd = 0x2427\n        masl_raw = self._to_bytes(masl, 2)\n        self._send_command(cmd, masl_raw, 1)\n\n    def get_altitude(self) -> int:\n        \"\"\"\n        Get the altitude from the sensor in meters above sea level.\n        \"\"\"\n        cmd = 0x2322\n        b = self._send_command(cmd, None, wait_time=1, bytes_for_read=3, crc_index=range(2, 3), value_index=(range(2),))\n        return self.unpack(\"H\", b)[0]\n\n    def set_ambient_pressure(self, pressure: float):\n        \"\"\"\n        Set the ambient pressure for the sensor in Pascals.\n        \"\"\"\n        cmd = 0xE000\n        press_raw = self._to_bytes(int(pressure // 100), 2)\n        self._send_command(cmd, press_raw, 1)\n\n    def force_recalibration(self, target_co2_concentration: int) -> int:\n        \"\"\"\n        Force recalibration of the sensor with the target CO2 concentration.\n        \"\"\"\n        check_value(target_co2_concentration, range(2**16),\n                    f\"Invalid target CO2 concentration: {target_co2_concentration} ppm\")\n        cmd = 0x362F\n        target_raw = self._to_bytes(target_co2_concentration, 2)\n        b = self._send_command(cmd, target_raw, 400, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return self.unpack(\"h\", b)[0]\n\n    def is_auto_calibration(self) -> bool:\n        \"\"\"\n        Check if automatic self-calibration is enabled on the sensor.\n        \"\"\"\n        cmd = 0x2313\n        b = self._send_command(cmd, None, 1, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return 0 != self.unpack(\"H\", b)[0]\n\n    def set_auto_calibration(self, value: bool):\n        \"\"\"\n        Enable or disable automatic self-calibration on the sensor.\n        \"\"\"\n        cmd = 0x2416\n        value_raw = self._to_bytes(value, 2)\n        self._send_command(cmd, value_raw, 1, 3)\n\n    def set_measurement(self, start: bool, single_shot: bool = False, rht_only: bool = False):\n        \"\"\"\n        Start or stop periodic measurements, or perform a single shot measurement.\n        \"\"\"\n        if single_shot:\n            return self._single_shot_meas(rht_only)\n        return self._periodic_measurement(start)\n\n    def _periodic_measurement(self, start: bool):\n        \"\"\"\n        Start or stop periodic measurements.\n        \"\"\"\n        wt = 0\n        if start:\n            cmd = 0x21AC if self._low_power_mode else 0x21B1\n        else:\n            cmd = 0x3F86\n            wt = 500\n        self._send_command(cmd, None, wt)\n        self._single_shot_mode = False\n        self._rht_only = False\n\n    def get_meas_data(self) -> tuple:\n        \"\"\"\n        Get the measurement data from the sensor (CO2, temperature, and humidity).\n        \"\"\"\n        cmd = 0xEC05\n        val_index = (range(2), range(3, 5), range(6, 8))\n        b = self._send_command(cmd, None, 1, bytes_for_read=9,\n                               crc_index=range(2, 9, 3), value_index=val_index)\n        words = [self.unpack(\"H\", b[val_rng.start:val_rng.stop])[0] for val_rng in val_index]\n        return words[0], -45 + 0.0026703288 * words[1], 0.0015259022 * words[2]\n\n    def is_data_ready(self) -> bool:\n        \"\"\"\n        Check if the measurement data is ready to be read from the sensor.\n        \"\"\"\n        cmd = 0xE4B8\n        b = self._send_command(cmd, None, 1, 3, crc_index=range(2, 3), value_index=(range(2),))\n        return bool(self.unpack(\"H\", b)[0] & 0b0000_0111_1111_1111)\n\n    @micropython.native\n    def get_conversion_cycle_time(self) -> int:\n        \"\"\"\n        Get the conversion cycle time of the sensor in milliseconds.\n        \"\"\"\n        if self.is_single_shot_mode and self.is_rht_only:\n            return 50\n        return 5000\n\n    def set_power(self, value: bool):\n        \"\"\"\n        Power up or power down the sensor.\n        \"\"\"\n        if not self._isSCD41:\n            return\n        cmd = 0x36F6 if value else 0x36E0\n        wt = 20 if value else 1\n        self._send_command(cmd, None, wt)\n\n    def _single_shot_meas(self, rht_only: bool = False):\n        \"\"\"\n        Perform a single shot measurement.\n        \"\"\"\n        if not self._isSCD41:\n            return\n        cmd = 0x2196 if rht_only else 0x219D\n        self._send_command(cmd, None, 0)\n        self._single_shot_mode = True\n        self._rht_only = rht_only\n\n    @property\n    def is_single_shot_mode(self) -> bool:\n        \"\"\"\n        Check if the sensor is in single shot mode.\n        \"\"\"\n        return self._single_shot_mode\n\n    @property\n    def is_rht_only(self) -> bool:\n        \"\"\"\n        Check if the sensor is in RHT-only mode.\n        \"\"\"\n        return self._rht_only\n\n    def __iter__(self):\n        return self\n\n    def __next__(self) -> [tuple, None]:\n        \"\"\"\n        Get the next set of measurement data.\n        \"\"\"\n        if self._single_shot_mode:\n            return None\n        if self.is_data_ready():\n            return self.get_meas_data()\n        return None\n\ndef pa_mmhg(value: float) -> float:\n    \"\"\"\n    Convert air pressure from Pascals to millimeters of mercury.\n    \"\"\"\n    return 7.50062E-3 * value\n\ndef crc8(sequence, polynomial: int, init_value: int = 0x00):\n    \"\"\"\n    Calculate CRC-8 checksum for the given sequence.\n    \"\"\"\n    mask = 0xFF\n    crc = init_value & mask\n    for item in sequence:\n        crc ^= item & mask\n        for _ in range(8):\n            if crc & 0x80:\n                crc = mask & ((crc << 1) ^ polynomial)\n            else:\n                crc = mask & (crc << 1)\n    return crc\n\ndef check_device_presence(i2c, address):\n    \"\"\"\n    Check if a device with the given address is present on the I2C bus.\n    \"\"\"\n    devices = i2c.scan()\n    return address in devices\n```\n\n</details>\n\nAnd once you have that done run the following code below on your device or save it to main.py, whatever you'd like. Note that we power cycle every 6 hours on the device to ensure that we don't run into memory issues. I encountered a memory leak that became a problem roughly 5 days in and felt that chasing it down was a waste compared to a simple power cycling using machine.reset().\n\n<details>\n\n<summary>Main Code</summary>\n\n``` python\n# main.py\n\nfrom machine import SoftI2C, Pin\nimport time\nfrom SCD41 import SCD4xSensirion, I2cAdapter, check_device_presence\nfrom ssd1306 import SSD1306_I2C  # Ensure you have the SSD1306 library\nimport urequests as requests\nimport network\nimport json\nimport utime\nimport usocket as socket\nimport ssl\nimport ntptime\n\n# ThingSpeak settings\nTHINGSPEAK_API_KEY = 'YOUR_KEY_HERE'\nTHINGSPEAK_URL = 'https://api.thingspeak.com/update'\nTHINGSPEAK_CHANNEL_ID = '00000000'\nTHINGSPEAK_BULK_UPDATE_URL = 'https://api.thingspeak.com/channels/'+str(THINGSPEAK_CHANNEL_ID)+'/bulk_update.json'\nSEND_TO_THINGSPEAK = True\n\nthingspeak_buffer = []  # Buffer for ThingSpeak data\n\n# Google Sheets settings\nSPREADSHEET_ID = 'VERY_LONG_SPREADSHEET_ID_HERE'\nRANGE_NAME = 'Sheet1!A1:C1'\nSHEET_NAME = 'Sheet1'\nGOOGLE_URL = 'https://script.google.com/macros/s/VERY_LONG_URL/exec'\n\n# WiFi settings\nSSID = 'YOUR_SSID'\nPASSWORD = 'WIFI_PSWD'\ndef connect_wifi(ssid, password):\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    wlan.connect(ssid, password)\n    while not wlan.isconnected():\n        time.sleep(1)\n        print(\"Connecting to WiFi...\")\n    print(\"Connected to WiFi\")\n    print(wlan.ifconfig())\n\ndef get_time_chicago():\n    max_retries = 100\n    for attempt in range(max_retries):\n        try:\n            ntptime.settime()\n            current_time = utime.localtime()\n            break\n        except OSError as e:\n            print(f\"Failed to get NTP time, attempt {attempt + 1} of {max_retries}. Error: {e}\")\n            time.sleep(1)\n    else:\n        print(\"Could not get NTP time, proceeding without time synchronization.\")\n        return utime.localtime()\n\n    # Determine if it is daylight saving time (DST)\n    month = current_time[1]\n    day = current_time[2]\n    hour = current_time[3]\n    if (month > 3 and month < 11) or (month == 3 and day >= 8 and hour >= 2) or (month == 11 and day < 1 and hour < 2):\n        is_dst = True\n    else:\n        is_dst = False\n    \n    offset = -6 * 3600 if not is_dst else -5 * 3600\n    local_time = utime.mktime(current_time) + offset\n    return utime.localtime(local_time)\n\n# Function to sound the buzzer\ndef sound_buzzer():\n    for _ in range(5):\n        buzzer.value(1)  # Turn on buzzer\n        time.sleep(0.5)  # 500 ms delay\n        buzzer.value(0)  # Turn off buzzer\n        time.sleep(0.5)  # 500 ms delay\n    \ndef send_data_to_google_sheets(data):\n    url = GOOGLE_URL  # Define your Google URL here\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    encoded_data = (\n        \"Date=\" + data['date'] +\n        \"&Time=\" + data['time'] +\n        \"&Temp=\" + str(data['temp_f']) +\n        \"&Humidity=\" + str(data['humidity']) +\n        \"&Lux=\" + str(data['lux']) +\n        \"&CCT=\" + str(data['color_temp']) +\n        \"&Soil Moisture=\" + str(data['soil_moisture']) +\n        \"&Soil Temp=\" + str(data['soil_temp']) +\n        \"&R=\" + str(data['r']) +\n        \"&G=\" + str(data['g']) +\n        \"&B=\" + str(data['b']) +\n        \"&HTML=\" + data['html']\n    )\n    try:\n        # Extract host and path from URL\n        _, _, host, path = url.split('/', 3)\n        \n        # Set up a socket connection\n        addr = socket.getaddrinfo(host, 443)[0][-1]\n        s = socket.socket()\n        s.connect(addr)\n        s = ssl.wrap_socket(s)\n        \n        # Create the HTTP request manually\n        request = f\"POST /{path} HTTP/1.1\\r\\nHost: {host}\\r\\n\"\n        request += \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n        request += f\"Content-Length: {len(encoded_data)}\\r\\n\\r\\n\"\n        request += encoded_data\n\n        # Send the request\n        s.write(request)\n        \n        # Close the socket\n        s.close()\n        print('Data sent to Google Sheets!')\n    except Exception as e:\n        print('Failed to send data to Google Sheets:', e)\n        \ndef send_data_to_thingspeak():\n    \"\"\"Send data to ThingSpeak.\"\"\"\n    if SEND_TO_THINGSPEAK and thingspeak_buffer:\n        if len(thingspeak_buffer) > 1:\n            # Bulk update\n            payload = {\n                'write_api_key': THINGSPEAK_API_KEY,\n                'updates': []\n            }\n            for data in thingspeak_buffer:\n                update = {\n                    'created_at': f\"{data['date']} {data['time']} -0500\",\n                    'field1': data['soil_temp'],\n                    'field2': data['soil_moisture'],\n                    'field3': data['lux'],\n                    'field4': data['color_temp'],\n                    'field5': data['temp_f'],\n                    'field6': data['humidity']\n                }\n                payload['updates'].append(update)\n\n            try:\n                headers = {'Content-Type': 'application/json'}\n                json_data = json.dumps(payload)\n                response = requests.post(THINGSPEAK_BULK_UPDATE_URL, headers=headers, data=json_data)\n                if response.status_code == 202:\n                    print('Data posted to ThingSpeak (bulk update):', response.text)\n                    thingspeak_buffer.clear()  # Clear the buffer after successful update\n                else:\n                    print(f'Failed to send data to ThingSpeak (bulk update): {response.status_code}, {response.text}')\n            except Exception as e:\n                print('Failed to send data to ThingSpeak (bulk update):', e)\n        else:\n            data = thingspeak_buffer.pop(0)  # Get the first item in the buffer\n            payload = {\n                'api_key': THINGSPEAK_API_KEY,\n                'field1': data['soil_temp'],\n                'field2': data['soil_moisture'],\n                'field3': data['lux'],\n                'field4': data['color_temp'],\n                'field5': data['temp_f'],\n                'field6': data['humidity']\n            }\n            try:\n                response = requests.post(THINGSPEAK_URL, json=payload)\n                if response.status_code == 200:\n                    print('Data posted to ThingSpeak:', response.text)\n                else:\n                    print(f'Failed to send data to ThingSpeak: {response.status_code}, {response.text}')\n            except Exception as e:\n                print('Failed to send data to ThingSpeak:', e)\n\n# Pin definitions\nDHT_PIN = Pin(27)\nDHT_POWER_PIN = Pin(26, Pin.OUT)\n# SEESAW_POWER_PIN = Pin(25, Pin.OUT)\nTCS34725_POWER_PIN = Pin(33, Pin.OUT)\nOLED_POWER_PIN = Pin(32, Pin.OUT)\nTCS34725_LED_PIN = Pin(23, Pin.OUT)  # GPIO 23 for TCS34725 LED control\n\n# Setup GPIO for Buzzer\nBUZZER_GPIO = 13  # Use GPIO 25 for the buzzer\nbuzzer = machine.Pin(BUZZER_GPIO, Pin.OUT)\n\n# Initialize separate I2C buses\ni2c_oled = SoftI2C(scl=Pin(22), sda=Pin(21))\ni2c_seesaw = SoftI2C(scl=Pin(16), sda=Pin(17))\ni2c_tcs = SoftI2C(scl=Pin(18), sda=Pin(19))\n\n# Scan I2C buses\nOLED_POWER_PIN.value(1)\nprint('Scanning I2C bus for OLED...')\ndevices_oled = i2c_oled.scan()\nOLED_POWER_PIN.value(0)\nprint('OLED I2C devices:', [hex(device) for device in devices_oled])\ntime.sleep(1)\n\nprint('Scanning I2C bus for Seesaw...')\n# SEESAW_POWER_PIN.value(1)\ndevices_seesaw = i2c_seesaw.scan()\n# SEESAW_POWER_PIN.value(0)\nprint('Seesaw I2C devices:', [hex(device) for device in devices_seesaw])\ntime.sleep(1)\n\nprint('Scanning I2C bus for TCS34725...')\nTCS34725_POWER_PIN.value(1)\nTCS34725_LED_PIN.value(0)  # Start with the LED off\ndevices_tcs = i2c_tcs.scan()\nprint('TCS34725 I2C devices:', [hex(device) for device in devices_tcs])\n\n# Initialize DHT22 sensor and OLED display\nDHT_POWER_PIN.value(1)\ndht_sensor = DHT22(DHT_PIN)\nDHT_POWER_PIN.value(0)\n\nOLED_POWER_PIN.value(1)\noled = SSD1306_I2C(128, 64, i2c_oled)\n\n# Ensure the addresses are correct (default addresses used)\nif 0x36 in devices_seesaw:\n    soil_sensor = StemmaSoilSensor(i2c_seesaw)\nelse:\n    print(\"Seesaw sensor not found!\")\n    \nif 0x39 in devices_tcs:\n    tcs = TCS34725(i2c_tcs)\nelse:\n    print(\"TCS34725 sensor not found!\")\n    \n# # Function to adjust gain and integration time based on Lux value\n# def adjust_tcs_settings(tcs, lux):\n#     print(lux)\n#     if lux > 10000:\n#         integration_time = 50  # Short integration time\n#         gain = 1  # Low gain\n#     elif lux > 1000:\n#         integration_time = 100  # Moderate integration time\n#         gain = 1  # Moderate gain\n#     elif lux > 100:\n#         integration_time = 150  # Long integration time\n#         gain = 4  # High gain\n#     else:\n#         integration_time = 200  # Longest integration time\n#         gain = 16  # Highest gain\n# \n#     tcs.integration_time(integration_time)\n#     tcs.gain(gain)\n#     print(f'Adjusted TCS34725 settings: Integration Time = {integration_time} ms, Gain = {gain}')\n\n# Function to reinitialize the TCS34725 sensor with retries and initial Lux adjustment\ndef reinitialize_tcs_sensor(i2c_tcs, retries=9):\n    for attempt in range(retries):\n        try:\n            tcs = TCS34725(i2c_tcs)\n            tcs.gain(4)\n            tcs.integration_time(150)\n            time.sleep(1)\n            tcs.active(True)\n            tcs.led(False)  # Ensure LED is off\n            time.sleep(1)  # Wait for the sensor to stabilize\n            cct, lux = tcs.read()  # Get initial readings to dynamically adjust Lux values\n            cct, lux = tcs.read()  # Get initial readings to dynamically adjust Lux values\n            print(\"Intial CCT:\",cct)\n            print(\"Initial Lux:\",lux)\n            \n            cct, lux = tcs.read()  # Get initial readings to dynamically adjust Lux values\n#             adjust_tcs_settings(tcs, lux)  # Adjust settings based on Lux\n            print(\"2nd CCT:\",cct)\n            print(\"2nd Lux:\",lux)\n            time.sleep(1)  # Wait for settings to take effect\n            print(f\"TCS34725 sensor initialized on attempt {attempt + 1}\")\n            return tcs, cct, lux\n        except Exception as e:\n            print(f\"Error initializing TCS34725 sensor: {e}, retrying...\")\n            time.sleep(1)\n    raise RuntimeError(\"Failed to initialize TCS34725 sensor after multiple attempts\")\ndef main():\n    # Connect to WiFi\n    connect_wifi(SSID, PASSWORD)\n    count = 0\n    # Main loop\n    while True:\n        try:\n            count = count +1\n            # Read DHT22 sensor\n            print(\"Reading DHT22 sensor...\")\n            DHT_POWER_PIN.value(1)\n            time.sleep(2)  # Wait for the sensor to stabilize\n            dht_sensor.measure()\n            temp_dht22 = dht_sensor.temperature()\n            humidity = dht_sensor.humidity()\n            temp_fahrenheit = int(temp_dht22 * 9 / 5 + 32)\n            humidity = int(humidity)\n            DHT_POWER_PIN.value(0)\n\n            # Read Seesaw (Soil) sensor if it is found\n            if 'soil_sensor' in locals():\n                print(\"Reading Seesaw sensor...\")\n                soil_temp = soil_sensor.get_temp()\n                soil_temp = int(soil_temp * 9 / 5 + 32)\n                soil_moisture = soil_sensor.get_moisture()\n            else:\n                soil_temp = None\n                soil_moisture = None\n\n            # Reinitialize and read TCS34725 sensor\n            print(\"Reinitializing and reading TCS34725 sensor...\")\n            TCS34725_POWER_PIN.value(1)\n            TCS34725_LED_PIN.value(0)  # Turn off the LED\n            tcs, cct, lux = reinitialize_tcs_sensor(i2c_tcs)\n            time.sleep(1)  # Wait for the sensor to stabilize\n\n            try:\n                raw_data = tcs.read(True)\n                print(f\"Raw data: {raw_data}\")\n                r, g, b, c = raw_data\n                cct, lux = tcs.read()\n                print(f\"RGB: ({r}, {g}, {b}), Clear: {c}, CCT: {cct}, Lux: {lux}\")\n                html_rgb_val = tcs.html_rgb(raw_data)\n                html_hex_val = tcs.html_hex(raw_data)\n                print(f\"HTML RGB: {html_rgb_val}, HTML Hex: {html_hex_val}\")\n            except RuntimeError as e:\n                print(\"Error reading TCS34725:\", e)\n                html_hex_val = \"Error\"\n                lux = cct = 0\n\n            TCS34725_LED_PIN.value(0)  # Turn off the LED\n            TCS34725_POWER_PIN.value(0)\n            \n             # Get current date and time\n            current_time = get_time_chicago()\n            date_str = \"{:04}-{:02}-{:02}\".format(current_time[0], current_time[1], current_time[2])\n            time_str = \"{:02}:{:02}:{:02}\".format(current_time[3], current_time[4], current_time[5])\n\n            # Print sensor data to the console\n            print(f'Color: {html_hex_val}')\n            print(f'Lux: {lux}')\n            print(f'CCT: {cct}')\n            print(f'Temp: {temp_fahrenheit} Hum:{humidity}')\n            if soil_temp is not None and soil_moisture is not None:\n                print(f'Soil Temp: {soil_temp} F')\n                print(f'Soil Moisture: {soil_moisture}')\n            # Display data on OLED\n            print(\"Updating OLED display...\")\n            oled.fill(0)\n            if soil_temp is not None:\n                oled.text(f'Soil Temp: {soil_temp}F', 0, 0)\n            if soil_moisture is not None:\n                print(\"Count: \", count)\n                oled.text(f'Moisture: {soil_moisture}', 0, 10)\n                if count > 60:\n                    count = 0\n                    if soil_moisture < 600:\n                        sound_buzzer()\n                        print(\"Buzzer sounded\")\n            oled.text(f'RGB: {int(html_rgb_val[0])},{int(html_rgb_val[1])},{int(html_rgb_val[2])}', 0, 20)\n            oled.text(f'Lux:{int(lux)}', 0, 30)\n            oled.text(f'CCT:{int(cct)}',0,40)\n            oled.text(f'Temp:{temp_fahrenheit}F Hum:{humidity}%', 0, 50)\n            oled.show()\n            print(' ')\n            # Prepare data for ThingSpeak\n            data = {\n                'soil_temp': soil_temp,\n                'soil_moisture': soil_moisture,\n                'lux': lux,\n                'color_temp': cct,\n                'temp_f': temp_fahrenheit,\n                'humidity': humidity\n            }\n            \n            # Prepare data for ThingSpeak\n            thingspeak_buffer.append(data)\n\n            # Send data to ThingSpeak\n            send_data_to_thingspeak()\n            \n            data = {\n                'date': date_str,\n                'time': time_str,\n                'temp_f': temp_fahrenheit,\n                'humidity': humidity,\n                'lux': lux,\n                'color_temp': cct,\n                'soil_moisture': soil_moisture,\n                'soil_temp': soil_temp,\n                'r': int(html_rgb_val[0]),\n                'g': int(html_rgb_val[1]),\n                'b': int(html_rgb_val[2]),\n                'html': html_hex_val\n            }    \n            # Send data to Google Sheets\n            send_data_to_google_sheets(data)\n\n\n\n            # Wait before the next update\n            time.sleep(45)\n\n        except Exception as e:\n            print(\"Error occurred:\", e)\n            time.sleep(5)  # Wait for 5 seconds before retrying\nif __name__ == '__main__':\n    main()\n```\n\n</details>\n\nI'm not going to the go too much into the code as the SCD41 chip supports a variety of different modes and unless you do a deep dive into the datasheet and the code for some cursed reason you should be fine with the code above. I was able to log readings fairly close to the reported values for my town and breathing on the device and near the device increased the sensor readings reliably. I did note that the sensor took some time to get back down to baseline and took a bit to get up to the max with me breathing on it. It was roughly 2.5 minutes to get back down to baseline and that's roughly in line with what we would ideally sample at due to the humidity sampling interval mentioned in the technical specs above. See image below:\n\n![](CO2_Values.png)\n\n### Limitations of the SCD41\n\nAs mentioned above we will have a slight delay in logging values so the results won't be instantaneous. Additionally as mentioned by: <https://github.com/octaprog7/SCD4x> one will notice an increase in temperature reading from the sensor if the interval is less than 15 seconds as the sensor will self heat. Additionally, both the SCD40/41 sensors have an auto-calibrate mode which will take the lowest CO2 value from the past 7 days and assumes it is 400ppm. This can cause sensor drift over time unless one regularly(once a week) exposes the sensor to fresh air. It is possible to turn off this auto-calibration mode and one will note that in the code above\\[set_auto_calibration\\]. An anecdote from [User Anx2K on the r/ESP32 Reddit](https://www.reddit.com/r/esp32/comments/12y0x5k/warning_about_the_sensirion_scd4041_co2_sensors/) mentions that there is roughly a 40ppm(10%) drift year to year if one turns off auto calibration. Calibration takes 5 minutes, but is an inherently manual process. It would be nice to be somewhere near a weather monitoring station and set up this CO2 monitor alongside a MH-Z19B/C and MH-Z1+ which use NDIR and compare the initial and end of 24 hour values and assess drift.\n\n### Applications of the SCD41\n\nI am particularly interested in environmental monitoring to assess indoor air quality at a competitive price, allowing users to swap sensors in and out as needed. This flexibility is crucial for adapting to different monitoring requirements without significant additional costs.\n\nAdditionally, monitoring transient dump flows from businesses during off-hours (midnight to 3 AM) is vital. This involves tracking the release of CO2 and other gaseous components using the MQ-\\* sensor series. While this approach may not provide quantitative measurements due to various confounding factors, it serves as an initial assessment tool. This preliminary analysis can justify the purchase or lease of more advanced testing equipment, costing under \\$100 in upfront expenses and requiring only a few hours of labor.\n\nAnother intriguing experiment involves mapping a town with sensors placed every few blocks to monitor localized CO2 concentrations. This data can be correlated with consumer, commercial, and industrial activities, providing valuable insights into the town's environmental impact.\n\nOther applications include monitoring the respiratory activity of plants by measuring CO2 exchange in greenhouse or agricultural research settings. This can offer insights into plant health, photosynthetic efficiency, and growth patterns. Pairing this with R/G/B, UV, and light sensors can help determine several growth parameters. Note that NPK (Nitrogen/Phosphorous/Potassium) sensors are often unreliable based on my research. Therefore, it's better to use actual chemical testing methods or automate the chemical testing apparatus rather than relying on electronic sensors for these measurements.\n\nIn biotechnology and biochemical engineering contexts, monitoring CO2 levels in cellular cultures and bioreactors is essential. Maintaining precise CO2 concentrations ensures the optimal growth of microorganisms, which can significantly reduce production costs. This is particularly important for the pharmaceutical industry, biofuel production, and other bio-based manufacturing processes.\n\n### Personal Testing\n\nIn the recent heat wave I noted that it took roughly 30 minutes to air out the house and cut CO2 levels from \\~1200ppm to \\~650ppm.\n\n![](CO2_Reduction.jpg)\n\nIts interesting to note that the temperature jumped only a few degrees over the 30 minutes per below:\n\n![](Temp_Humidity.jpeg)\n\nThe actual \"enclosure\" of the sensor is just an old Raspberry Pi 5 Case box, a FLIRC model. The solid wire coming from the main board is hooked up to a smaller board used for data display, switching wifi/calibration on/off, and alerting users to high CO2(1500ppm). Note that I didn't feel like potentially burning the board or buying a soldering attachment to safely remove the LED so I covered it with some cardboard to remove some of the interference caused by the light on the sensor. See below:\n\nRaw Boards, no case\n\n![](SCD41_NoBox.jpg)\n\nWifi/Calibration Screen, with case\n\n![](SwitchesScreen.jpg)\n\nNormal Output, with case\n\n![](SCD41_Example_Data.jpg)\n\n### Conclusion\n\nThe SCD41 sensor offers a versatile and accurate solution for CO2 monitoring in various applications. For our particular application, provided we either calibrate it once at the beginning then once more every year we can enjoy accurate CO2 monitoring at a low price.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}