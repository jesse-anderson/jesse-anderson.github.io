{
  "hash": "416615b1d53643e9eb73e7ec2073e29e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Efficient Data Logging with ESP32\nsubtitle: A  Guide to Using Google Sheets/MongoDB/PostgreSQL/ThingSpeak for IoT\nauthor: Jesse Anderson\ndate: '2024-05-26'\ncategories:\n  - ESP32\n  - IoT\nformat: html\nimage: images/Real_Life_ESP32_Setup.jpg\nfreeze: true\nexecute:\n  freeze: true\n---\n\nTo begin with, we are using an [ESP32-Wroom-32 Expressif board purchased from Microcenter for \\$10.](https://www.microcenter.com/product/613822/inland-esp32-wroom-32d-module) These boards can be found for as low as \\$4-\\$5 on Amazon, and more capable boards are available in the \\$10-\\$20 range. This makes the ESP32 a cost-effective alternative to the Raspberry Pi, especially when the task is primarily logging sensor data. Additionally, the ESP32 outperforms the Raspberry Pi Pico significantly; it is approximately five times faster with integer arithmetic and 60-70 times faster with floating-point calculations, as demonstrated in this youtube video: <https://www.youtube.com/watch?v=zGog29YNLmk&ab_channel=Tomsvideos>\n\nThe code for this project is written in MicroPython. Although rewriting it in C/C++ could potentially yield a 10x performance improvement, the time and effort required to handle compilation issues are not justifiable for this use case. If this were a production environment, opting for C/C++ would be an obvious choice.\n\n## What is an ESP32-WROOM-32 Expressif Board?\n\nThe ESP32-WROOM-32 is a powerful, low-cost Wi-Fi and Bluetooth microcontroller module developed by Espressif Systems. It is designed for a wide range of applications, from simple IoT projects to complex systems requiring wireless connectivity and advanced processing capabilities. Here are some key features and specifications of the ESP32-WROOM-32 board:\n\n1.  **Dual-Core Processor**: The ESP32-WROOM-32 features a dual-core Tensilica Xtensa LX6 microprocessor, with clock speeds up to 240 MHz. This provides ample processing power for a variety of tasks, including real-time data processing and multitasking.\n\n2.  **Wireless Connectivity**:\n\n    -   **Wi-Fi**: The board supports 802.11 b/g/n Wi-Fi, making it ideal for IoT applications that require internet connectivity. It can operate in both Station and Access Point modes, allowing it to connect to existing networks or create its own.\n\n    -   **Bluetooth**: It includes Bluetooth 4.2 (BLE and Classic), enabling communication with other Bluetooth devices, such as sensors, smartphones, and peripherals.\n\n3.  **Memory**:\n\n    -   **Flash Memory**: The module typically comes with 4 MB of flash memory, used for storing the firmware and other data.\n\n    -   **SRAM**: It has 520 KB of on-chip SRAM, providing sufficient space for running programs and handling data.\n\n4.  **GPIO and Peripherals**:\n\n    -   The board features numerous General Purpose Input/Output (GPIO) pins, which can be used for interfacing with various sensors, actuators, and other peripherals.\n\n    -   It includes a variety of built-in peripherals, such as UART, SPI, I2C, PWM, ADC, and DAC, making it highly versatile for different types of projects.\n\n5.  **Power Management**:\n\n    -   The ESP32-WROOM-32 is designed with power efficiency in mind, offering multiple power-saving modes, such as deep sleep and light sleep. This makes it suitable for battery-powered applications where low power consumption is crucial.\n\n6.  **Development Environment**:\n\n    -   The board is compatible with popular development environments like Arduino IDE, PlatformIO, and Espressif’s own ESP-IDF (Espressif IoT Development Framework). This flexibility allows developers to choose their preferred tools and programming languages.\n\nThe ESP32-WROOM-32 board is widely used in various applications, including Internet of Things (IoT), industrial automation, home automation, robotics, health monitoring, and educational projects. It enables the creation of smart home devices, environmental monitoring systems, wearable health trackers, and remote industrial monitoring solutions. Additionally, it is suitable for controlling autonomous robots and drones, developing smart appliances, and building voice assistants. Its versatility makes it an excellent choice for learning and prototyping in STEM education, providing a hands-on experience with microcontrollers, IoT, and embedded systems.\n\nHowever, the ESP32-WROOM-32 has some limitations that need to be considered. Its processing power and memory are limited compared to more powerful systems, which can be a constraint for complex applications. While it offers various power-saving modes, its power consumption is higher than simpler microcontrollers, making it less ideal for ultra-low-power applications. The board's real-time performance may not meet the needs of highly time-sensitive tasks, and its limited GPIO pins might require additional hardware for larger projects. Additionally, it may not be suitable for extreme environmental conditions without protective measures, and its complexity can present a steep learning curve for beginners.\n\nThe datasheet for the ESP32 can be found [here](esp32-wroom-32_datasheet_en.pdf).\n\n### CPU and Internal Memory\n\nESP32-D0WDQ6 contains two low-power Xtensa® 32-bit LX6 microprocessors. The internal memory includes:\n\n-   448 KB of ROM for booting and core functions.\n\n-   520 KB of on-chip SRAM for data and instructions.\n\n-   8 KB of SRAM in RTC, which is called RTC FAST Memory and can be used for data storage; it is accessed by the main CPU during RTC Boot from the Deep-sleep mode.\n\n-   8 KB of SRAM in RTC, which is called RTC SLOW Memory and can be accessed by the co-processor during the Deep-sleep mode.\n\n-   1 Kbit of eFuse: 256 bits are used for the system (MAC address and chip configuration) and the remaining 768 bits are reserved for customer applications, including flash-encryption and chip-ID.\n\nGet the esptool via pip:\n\n``` bash\npip install esptool\n```\n\nSee usage:\n\n``` bash\nesptool\n```\n\nNext find your port after plugging in your ESP32 device via USB:\n\nIn Windows at least its **`Device Manager -> Ports(Com & LPT)`** and look for a device named USB-Serial CH340 or Silicon Labs CP210x USB to UART Bridge or similar. I had two devices in my ports so I noted the ports in use, unplugged the board, then plugged it back in to get the port. This of course didn't work and I had to add the COM port manually...\n\n**Adding COM ports manually.**\n\n1.  Open Device Manager on your computer.\n\n2.  Click on the **Action** option from menu bar.\n\n3.  Choose **Add legacy hardware** from the menu to open the Add Hardware window.\n\n4.  Click on the **Next** button to move on.\n\n5.  Check **Install the hardware that I manually select from a list (Advanced)** and press **Next**.\n\n6.  Select **Ports (COM & LPT)** from the given list and press the **Next** button.\n\n7.  Choose **Standard port types** option or the manufacturer for the ports; then, click **Next**.\n\n8.  Click on the **Finish** button to complete.\n\nYou'll note a new COM port, in my case COM4 and that's what you'll need for the next step.\n\nFollow this guide if you're not seeing things or some other nonsense: <https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/establish-serial-connection.html>\n\nIf you're experiencing driver issues, this resource might help:\n\n<https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=overview>\n\nI used the \"with serial enumeration\" file, and it worked well for me. The device was recognized and assigned to COM4, which I then used for my setup.\n\nAfter installing PuTTY, everything worked smoothly. Using both the drivers and PuTTY resolved my issues, reminding me to be more patient and consult the documentation before rushing. If you've already flashed something, follow the steps to reset while monitoring COM# on PuTTY. You should see the download mode activate. Reset the device by holding the Boot button and pressing the reset button, then holding Boot while flashing.\n\n## **Getting Started with MicroPython**\n\nFor the most part refer to the instructions at: <https://docs.micropython.org/en/latest/esp32/tutorial/intro.html>\n\nDownload firmware for your ESP32 board:\n\n<https://micropython.org/download/#esp32>\n\nSpecifically the Microcenter Inland WROOM Board:\n\n<https://micropython.org/download/ESP32_GENERIC/>\n\nEnsure your device is erased with:\n\n``` bash\nesptool.py -p COM4 erase_flash\n```\n\nTake care to replace the 'COM4' with your port.\n\nNext flash MicroPython to the board:\n\n``` bash\nesptool.py --chip esp32 --port COM4 --baud 460800 write_flash -z 0x1000 esp32-20190125-v1.10.bin\n```\n\n***Make sure you replace the .bin file with the file you downloaded and ensure you're in the correct directory.***\n\nNext I got up and running with Thonny(<https://thonny.org/>). Its a very lightweight Python IDE that's ESP32 friendly. Make sure you select your device in the lower right corner and you'll be up and running.\n\n![](images/paste-1.png)\n\nYou can run a simple print(\"Hello World\") to ensure you're communicating with the device in the shell.\n\nHere's a schematic of my board setup, with swappable GPIO pins and an optional LED. I included an LED to provide a quick visual indicator that my board is running the code correctly during stress tests.\n\n![](images/CircuitSetup_bb_edit.png)\n\nAnd the Real Life Version:\n\n![](images/Real_Life_ESP32_Setup.jpg)\n\nPinouts courteousy of <https://github.com/natedogg2020/Inland_ESP32-Supplements>\n\nTop:\n\n![](images/Inland_ESP32_Top.jpg)\n\nBottom:\n\n![](images/Inland_ESP32_Bottom.jpg)\n\nAll pin references are looking from the top and will be either referenced Top Left or Top Right.\n\n### **DHT11**\n\nGround to Ground Line to Ground at Pin 19(Top Left)\n\nGPIO15 Power from Pin 4(Top Left)\n\nGPIO13 Signal from Pin 5(Top Left)\n\nGPIO Power from Pin 5(Top Right)(I know I should've kept it split, but I had to do some nonsense with the power after the wifi cut out due to the power demand)\n\n### **LED**\n\nResistor: 22ohm(Also used 10, but 22 works better to not blind me)\n\nLED Anode to Ground to Ground Line to Ground at Pin 6(Top Right)\n\nLED Cathode to Resistor(22 ohm) to GPIO2 Power from Pin 5(Again, I know I should've kept it separate. I'm not an EE.)\n\nNext, you'll want to test that your device can connect to the internet, read the sensor, and blink the LED. For now, we'll skip the Google App Script/Vercel PostgreSQL/MongoDB/ThingSpeak integration, and you will encounter errors when transmitting data.\n\nI'll provide the code below with explanations of the different parts. To save memory, especially with the Google Apps Script request, I used a lower-level form of POST than standard. This approach is necessary because the Google Response was overloading the memory. Adjust the timeouts according to your needs. Initially, disable the sensors and LED to ensure sufficient power for the wireless connection, then enable the sensors and allow a few seconds for them to register readings.\n\n<details>\n\n<summary>Code</summary>\n\n``` python\nimport network\nimport urequests as requests\nimport time as time_module\nfrom machine import Pin\nimport dht\nimport ntptime\nimport utime\nimport ujson as json\nimport gc\nfrom machine import freq\n\n# Wi-Fi credentials\nSSID = 'YOUR-WIFI-NAME'\nPASSWORD = 'YOUR-WIFI-PASSWORD'\n\n# Google Sheets settings\nSPREADSHEET_ID = 'YOUR-SPREADSHEET-ID'\nRANGE_NAME = 'Sheet1!A1:E1' #NOTE THAT THIS IS FOR DATE TIME HUMIDITY TEMP_F TEMP_C. WILL CHANGE COLUMN DESIGNATION IF YOU ADD/REMOVE DATA.\nSHEET_NAME = 'Sheet1'\nGOOGLE_URL = 'YOUR-GOOGLE-APP-SCRIPT'\n\n# ThingSpeak settings\nTHINGSPEAK_API_KEY = 'THINGSPEAK-API-KEY'\nTHINGSPEAK_URL = 'https://api.thingspeak.com/update'\nTHINGSPEAK_CHANNEL_ID = 0000000 # Replace with your ThingSpeak channel ID\nTHINGSPEAK_BULK_UPDATE_URL = 'https://api.thingspeak.com/channels/'+str(THINGSPEAK_CHANNEL_ID)+'/bulk_update.json'\n\n# MongoDB settings\nMONGODB_API_URL = 'YOUR_MONGO_DB_URL'\n#MONGODB_API_KEY = 'your_mongodb_api_key' #WE ARE NOT USING PYMONGO, DO NOT NEED.\nMONGODB__VERCEL_API_URL = 'YOUR-VERCEL-URL/api/sensorMongoDB'\n# Vercel settings\nVERCEL_API_URL = 'YOUR-VERCEL-URL/api/sensor'\nVERCEL_API_KEY = 'YOUR-VERCEL-API-KEY'\n\n# DHT11 sensor setup\nSENSOR_POWER_PIN = 13  # Change this to the pin connected to the power control of the sensor\nSENSOR_DATA_PIN = 15  # Change this to the pin connected to the data pin of the sensor\nLED_PIN = 2  # GPIO pin for the LED\n\n# Initialize the sensor power pin and LED pin\nsensor_power_pin = Pin(SENSOR_POWER_PIN, Pin.OUT)\nsensor_data_pin = Pin(SENSOR_DATA_PIN)\nled = Pin(LED_PIN, Pin.OUT)\n\n# Buffers to store data\ndata_buffer_vercel = []\ndata_buffer_mongodb = []\nthingspeak_buffer = []  # Buffer for ThingSpeak data\n\n# Control flags\nSEND_TO_VERCEL = True\nSEND_TO_GOOGLE_SHEETS = True\nSEND_TO_THINGSPEAK = True\nSEND_TO_MONGODB = True\n\ndef connect_wifi(ssid, password):\n    wlan = network.WLAN(network.STA_IF)\n    wlan.active(True)\n    wlan.connect(ssid, password)\n    while not wlan.isconnected():\n        time_module.sleep(1)\n        print(\"Connecting to WiFi...\")\n    print(\"Connected to WiFi\")\n    print(wlan.ifconfig())\n\n# Function to disable sensors\ndef disable_sensors():\n    sensor_power_pin.value(0)  # Turn off sensor by setting the power pin low\n\n# Function to enable sensors\ndef enable_sensors():\n    sensor_power_pin.value(1)  # Turn on sensor by setting the power pin high\n    time_module.sleep(2)  # Wait for the sensor to stabilize    \n# Function to get system status\ndef get_system_status(firstRun):\n    free_heap = gc.mem_free()\n    total_heap = gc.mem_alloc() + free_heap\n    free_heap_percent = (free_heap / total_heap) * 100\n    if firstRun == True:\n        print(f\"Total heap memory: {total_heap} bytes\")\n        # Additional information about the system\n        print(f\"Frequency: {freq()} Hz\")\n    print(f\"Free heap memory: {free_heap} bytes ({free_heap_percent:.2f}%)\")\n    \ndef get_time_chicago():\n    max_retries = 100\n    for attempt in range(max_retries):\n        try:\n            ntptime.settime()\n            current_time = utime.localtime()\n            break\n        except OSError as e:\n            print(f\"Failed to get NTP time, attempt {attempt + 1} of {max_retries}. Error: {e}\")\n            time_module.sleep(1)\n    else:\n        print(\"Could not get NTP time, proceeding without time synchronization.\")\n        return utime.localtime()\n\n    # Determine if it is daylight saving time (DST)\n    month = current_time[1]\n    day = current_time[2]\n    hour = current_time[3]\n    if (month > 3 and month < 11) or (month == 3 and day >= 8 and hour >= 2) or (month == 11 and day < 1 and hour < 2):\n        is_dst = True\n    else:\n        is_dst = False\n    \n    offset = -6 * 3600 if not is_dst else -5 * 3600\n    local_time = utime.mktime(current_time) + offset\n    return utime.localtime(local_time)\n\ndef read_sensor():\n    try:\n        led.off()\n        sensor = dht.DHT11(sensor_data_pin)\n        time_module.sleep(1) #the DHT11 sensor takes 1 second\n        sensor.measure()\n        led.on()\n        temp = sensor.temperature()\n        hum = sensor.humidity()\n        return temp, hum\n    except OSError as e:\n        print(\"Failed to read sensor. Exception: \", e)\n        return None, None\n# Read the access token from the file uploaded earlier\ndef read_access_token():\n    with open('access_token.txt', 'r') as token_file:\n        return token_file.read().strip()\n\n# ACCESS_TOKEN = read_access_token()\n# print(ACCESS_TOKEN)\n\nimport usocket as socket\nimport ssl\ndef send_data_to_google_sheets(temp_c, temp_f, humidity, time_str, date_str):\n#     print(time_module.time())\n    url = GOOGLE_URL  # Define your Google URL here\n    headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n    }\n    data = {\n        'Date': date_str,\n        'Time': time_str,\n        'Humidity %': humidity,\n        'Temp F': temp_f,\n        'Temp C': temp_c\n    }\n#     print(time_module.time())\n    # Construct the URL-encoded string manually\n    encoded_data = (\n        \"Date=\" + date_str +\n        \"&Time=\" + time_str +\n        \"&Humidity %=\" + str(humidity) +\n        \"&Temp F=\" + str(temp_f) +\n        \"&Temp C=\" + str(temp_c)\n     ) \n    try:\n        # Extract host and path from URL\n        _, _, host, path = url.split('/', 3)\n        \n        # Set up a socket connection\n        addr = socket.getaddrinfo(host, 443)[0][-1]\n        s = socket.socket()\n        s.connect(addr)\n        s = ssl.wrap_socket(s)\n        \n        # Create the HTTP request manually\n        request = f\"POST /{path} HTTP/1.1\\r\\nHost: {host}\\r\\n\"\n        request += \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n        request += f\"Content-Length: {len(encoded_data)}\\r\\n\\r\\n\"\n        request += encoded_data\n\n        # Send the request\n        s.write(request)\n        \n#         # Read the response\n#         response = s.read(1024)  # Read up to 2048 bytes from the response, THIS TAKES A WHILE, SET TO WHATEVER. 128-1024\n#         print('Data sent to Google Sheets:', response)  \n        # Close the socket\n        s.close()\n        print('Data sent to Google Sheets!')\n#         print(time_module.time())\n    except Exception as e:\n        print('Failed to send data to Google Sheets:', e)\n\n# # Function to send data to Google Sheets\n# def send_data_to_google_sheets(temp_c, temp_f, humidity,time_str,date_str):\n#     print(time_module.time())\n#     url = GOOGLE_URL\n#     headers = {\n#         'Content-Type': 'application/x-www-form-urlencoded'\n#     }\n#     # Construct the URL-encoded string manually\n#     print(time_module.time())\n#     encoded_data = (\n#         \"Date=\" + date_str +\n#         \"&Time=\" + time_str +\n#         \"&Humidity %=\" + str(humidity) +\n#         \"&Temp F=\" + str(temp_f) +\n#         \"&Temp C=\" + str(temp_c)\n#     )\n#     print(encoded_data)\n#     print(time_module.time())\n#     print(\"request\")\n#     try:\n#         # Get initial free memory\n#         # Run garbage collection to get a clean slate\n#         gc.collect()\n#         initial_free = gc.mem_free()\n#         response = requests.post(url, data=encoded_data, headers=headers) #DRAGS... Also\n#         # Run garbage collection again\n#         gc.collect()\n#         # Get final free memory\n#         final_free = gc.mem_free()\n# \n#         # Calculate memory used by the variable\n#         memory_used = initial_free - final_free\n#         print('Data sent to Google Sheets:')\n#         print(time_module.time())\n#         print('Size of response: ', memory_used, 'bytes') # Size of response:  46352 bytes. Crazy.... That's like ~4635 date strings.\n#     except Exception as e:\n#         print('Failed to send data to Google Sheets:', e)\n\ndef send_data_to_thingspeak():\n    \"\"\"Send data to ThingSpeak.\"\"\"\n    if SEND_TO_THINGSPEAK and thingspeak_buffer:\n        if len(thingspeak_buffer) > 1:\n            # Bulk update\n            payload = {\n                    'write_api_key': THINGSPEAK_API_KEY,\n                    'updates': []\n                }\n            for data in thingspeak_buffer:\n                update = {\n                    'created_at': f\"{data['date']} {data['time']} -0500\",\n                    'field1': data['temperature_C'],\n                    'field2': data['temperature_F'],\n                    'field3': data['humidityPercent'],\n                    'field4': data['time'],\n                    'field5': data['date']\n                }\n                payload['updates'].append(update)\n\n            try:\n                # Send the bulk update request to ThingSpeak\n                headers = {'Content-Type': 'application/json'}\n                #print(len(thingspeak_buffer))\n                #print(headers)\n                #print(json.dumps(payload))\n                # Convert the data payload to JSON format\n                json_data = json.dumps(payload)\n                response = requests.post(THINGSPEAK_BULK_UPDATE_URL,headers=headers,data=json_data)\n                if response.status_code == 202:\n                    print('Data posted to ThingSpeak (bulk update):', response.text)\n                    thingspeak_buffer.clear()  # Clear the buffer after successful update\n                else:\n                    print(f'Failed to send data to ThingSpeak (bulk update): {response.status_code}, {response.text}')\n            except Exception as e:\n                print('Failed to send data to ThingSpeak (bulk update):', e)\n        else:\n            data = thingspeak_buffer.pop(0)  # Get the first item in the buffer\n            print(data)\n            payload = {\n            'api_key': THINGSPEAK_API_KEY,\n            'field1': data['temperature_C'],\n            'field2': data['temperature_F'],\n            'field3': data['humidityPercent'],\n            'field4': data['time'],\n            'field5': data['date']\n        }\n            try:\n                response = requests.post(THINGSPEAK_URL, json=payload)\n                print('Data posted to ThingSpeak', response.text)\n                print(payload)\n                thingspeak_buffer.clear()  # Clear the buffer after successful update\n            except Exception as e:\n                print('Failed to send data to ThingSpeak:', e)\n                thingspeak_buffer.clear()\ndef send_data_to_mongodb():\n    url = MONGODB__VERCEL_API_URL\n    headers = {\n        'x-api-key': VERCEL_API_KEY,\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        # Convert the data dictionary to a JSON string\n        json_data = json.dumps(data_buffer_mongodb)\n        \n        # Print the request details for debugging\n#         print(\"Sending data to:\", url)\n#         print(\"Headers:\", headers)\n#         print(\"Payload:\", json_data)\n        \n        response = requests.post(url, data=json_data, headers=headers)\n        \n        # Print the response details for debugging\n        print(\"Status Code:\", response.status_code)\n        print(\"Response Text:\", response.text)\n        data_buffer_mongodb.clear()\n    except Exception as e:\n        print(\"Failed to send data to Vercel MongoDB API:\", e)\n        data_buffer_mongodb.clear()\ndef send_data_to_vercel():\n    url = VERCEL_API_URL\n    headers = {\n        'x-api-key': VERCEL_API_KEY,\n        'Content-Type': 'application/json'\n    }\n\n    try:\n        # Convert the data dictionary to a JSON string\n        json_data = json.dumps(data_buffer_vercel)\n        \n        # Print the request details for debugging\n#         print(\"Sending data to:\", url)\n#         print(\"Headers:\", headers)\n#         print(\"Payload:\", json_data)\n        \n        response = requests.post(url, data=json_data, headers=headers)\n        \n        # Print the response details for debugging\n        print(\"Status Code:\", response.status_code)\n        print(\"Response Text:\", response.text)\n    except Exception as e:\n        print(\"Failed to send data to Vercel:\", e)\n\ndef main():\n    firstRun = True\n    enable_sensors()\n    temp,hum=read_sensor()\n    print(temp,hum)\n    led.off()\n    disable_sensors()\n    connect_wifi(SSID, PASSWORD)\n    enable_sensors()\n    last_google_sheets_update = time_module.time()\n    last_thingspeak_update = time_module.time()\n    last_vercel_update = time_module.time()\n    last_mongodb_update = time_module.time()\n    iter = 0\n    while True:\n        try:\n            led.on()\n            enable_sensors() #enable the sensors via GPIO\n            temp_c, humidity = read_sensor() #log readings\n            led.off()\n            disable_sensors()# disable the sensors so wifi transmission doesn't run into power issues.\n            if temp_c is not None and humidity is not None:\n                temp_f = temp_c * 9 / 5 + 32\n                local_time = get_time_chicago()\n                date_str = f\"{local_time[0]}-{local_time[1]:02d}-{local_time[2]:02d}\"\n                time_str = f\"{local_time[3]:02d}:{local_time[4]:02d}:{local_time[5]:02d}\"\n                print(f'[{iter}]Date: {date_str}, Time: {time_str}, Temperature: {temp_c}°C, Humidity: {hum}%, Temperature: {temp_f}°F ')\n    #             print(date_str)\n    #             print(time_str)\n                # Add data to buffers\n                data = {\n                        'date': date_str,\n                        'time': time_str,\n                        'humidityPercent': humidity,\n                        'temperatureFahrenheit': temp_f,\n                        'temperatureCelsius': temp_c\n                    }\n                data_buffer_vercel={\n                    'date': date_str,\n                    'time': time_str,\n                    'humidityPercent': humidity,\n                    'temperatureFahrenheit': temp_f,\n                    'temperatureCelsius': temp_c\n                }\n                thingspeak_buffer.append({\n                    'temperature_C': temp_c,\n                    'temperature_F': temp_f,\n                    'humidityPercent': humidity,\n                    'time': time_str,\n                    'date': date_str\n                })\n                data_buffer_mongodb.append({\n                    'date': date_str,\n                    'time': time_str,\n                    'humidityPercent': humidity,\n                    'temperatureFahrenheit': temp_f,\n                    'temperatureCelsius': temp,\n                })\n                print(\"ThingSpeak Buffer:\",len(thingspeak_buffer),\"|Vercel Buffer:\",len(data_buffer_vercel),\"|MongoDB Buffer:\",len(data_buffer_mongodb))\n                 # Check if it's time to send data to Google Sheets \n                if time_module.time() - last_google_sheets_update >= 5:\n                    \n                    send_data_to_google_sheets(temp_c, temp_f, humidity, time_str, date_str)\n                    last_google_sheets_update = time_module.time()\n\n                # Check if it's time to send data to ThingSpeak\n                if time_module.time() - last_thingspeak_update >= 15:\n                    send_data_to_thingspeak()\n                    last_thingspeak_update = time_module.time()\n\n    #             # Check if it's time to send data to Vercel\n    #Vercel DB no good for this low level stuff. Overflow error and out of memory.\n    #No append operation as a result.\n                if time_module.time() - last_vercel_update >= 3600:\n                    send_data_to_vercel()\n                    last_vercel_update = time_module.time()\n\n                # Check if it's time to send data to MongoDB\n                if time_module.time() - last_mongodb_update >= 15:\n                    send_data_to_mongodb()\n                    last_mongodb_update = time_module.time()\n                led.on()    \n#                 time_module.sleep(1)  # Wait for 1 seconds before logging the next reading. Note sensor sampling times!\n                led.off()\n                get_system_status(firstRun)\n                print(\" \")\n                firstRun = False\n                iter = iter+1\n        except Exception as e:\n            print(f\"Error in main loop: {e}\") # usually some one off memory error. It'll reset while still connected to wifi and everyone will be happy.\n            \nif __name__ == '__main__':\n    main()\n```\n\n</details>\n\nAnd a breakdown:\n\n<details>\n\n<summary>Code breakdown</summary>\n\n#### **Import Necessary Libraries**\n\nFirst, we import the necessary libraries required for the project:\n\n-   **`network`** for managing Wi-Fi connectivity.\n\n-   **`urequests`** for making HTTP requests to various APIs.\n\n-   **`time`** and **`utime`** for handling time-related functions.\n\n-   **`dht`** for interacting with the DHT11 sensor.\n\n-   **`ntptime`** for synchronizing time with an NTP server.\n\n-   **`ujson`** for handling JSON data.\n\n-   **`gc`** for garbage collection to manage memory.\n\n-   **`machine`** for controlling hardware components like GPIO pins.\n\n#### **Wi-Fi and API Credentials**\n\nWe define constants to store Wi-Fi credentials and API details:\n\n-   **`SSID`** and **`PASSWORD`** for Wi-Fi network credentials.\n\n-   **`SPREADSHEET_ID`**, **`RANGE_NAME`**, **`SHEET_NAME`**, and **`GOOGLE_URL`** for Google Sheets integration.\n\n-   **`THINGSPEAK_API_KEY`**, **`THINGSPEAK_URL`**, **`THINGSPEAK_CHANNEL_ID`**, and **`THINGSPEAK_BULK_UPDATE_URL`** for ThingSpeak integration.\n\n-   **`MONGODB_API_URL`**, **`MONGODB_VERCEL_API_URL`** for MongoDB integration.\n\n-   **`VERCEL_API_URL`** and **`VERCEL_API_KEY`** for Vercel integration.\n\n#### **Setting Up GPIO Pins**\n\nWe configure the GPIO pins on the ESP32:\n\n-   **`SENSOR_POWER_PIN`** to control the power to the DHT11 sensor.\n\n-   **`SENSOR_DATA_PIN`** to read data from the DHT11 sensor.\n\n-   **`LED_PIN`** to control an LED used for indicating status.\n\n#### **Data Buffers and Control Flags**\n\nBuffers are initialized to temporarily store data before sending it to the respective services:\n\n-   **`data_buffer_vercel`**, **`data_buffer_mongodb`**, and **`thingspeak_buffer`** store data for Vercel, MongoDB, and ThingSpeak, respectively.\n\nControl flags (**`SEND_TO_VERCEL`**, **`SEND_TO_GOOGLE_SHEETS`**, **`SEND_TO_THINGSPEAK`**, **`SEND_TO_MONGODB`**) determine whether data should be sent to each service.\n\n#### **Connecting to Wi-Fi**\n\nThe **`connect_wifi`** function manages the connection to the Wi-Fi network:\n\n-   Activates the WLAN interface.\n\n-   Connects to the specified Wi-Fi network using the provided SSID and password.\n\n-   Continuously checks the connection status and prints the IP configuration once connected.\n\n#### **Sensor Control Functions**\n\nTwo functions manage the power state of the DHT11 sensor:\n\n-   **`disable_sensors`** sets the power pin low to turn off the sensor.\n\n-   **`enable_sensors`** sets the power pin high and waits for the sensor to stabilize.\n\n#### **System Status Function**\n\nThe **`get_system_status`** function provides insights into the system's memory usage and CPU frequency:\n\n-   Calculates the total and free heap memory.\n\n-   Prints the memory statistics and CPU frequency.\n\n#### **Time Synchronization**\n\nThe **`get_time_chicago`** function synchronizes the ESP32's clock with an NTP server:\n\n-   Attempts to set the time using NTP up to a maximum number of retries.\n\n-   Adjusts the time based on whether daylight saving time (DST) is in effect for the Chicago timezone.\n\n#### **Reading Sensor Data**\n\nThe **`read_sensor`** function reads temperature and humidity data from the DHT11 sensor:\n\n-   Measures the temperature and humidity.\n\n-   Returns the values or **`None`** if the reading fails.\n\n#### **Sending Data to Google Sheets**\n\nThe **`send_data_to_google_sheets`** function sends sensor data to Google Sheets:\n\n-   Constructs the data payload and URL-encodes it.\n\n-   Sends the data using an HTTP POST request.\n\n-   Handles errors during the data sending process.\n\n#### **Sending Data to ThingSpeak**\n\nThe **`send_data_to_thingspeak`** function sends data to ThingSpeak:\n\n-   Supports both single data point updates and bulk updates.\n\n-   Constructs the payload and sends it using an HTTP POST request.\n\n-   Handles errors and clears the buffer after successful updates.\n\n#### **Sending Data to MongoDB via Vercel API**\n\nThe **`send_data_to_mongodb`** function sends data to a MongoDB instance via a Vercel API:\n\n-   Converts the data buffer to JSON.\n\n-   Sends the data using an HTTP POST request.\n\n-   Handles errors and clears the buffer after successful updates.\n\n#### **Sending Data to Vercel API**\n\nThe **`send_data_to_vercel`** function sends data to a Vercel API endpoint:\n\n-   Converts the data buffer to JSON.\n\n-   Sends the data using an HTTP POST request.\n\n-   Handles errors during the data sending process(NO BUFFER DUE TO MEMORY LIMITATIONS AND VERCEL LIMITS).\n\n#### **Main Function**\n\nThe **`main`** function orchestrates the entire process:\n\n-   Initializes the sensor and connects to Wi-Fi.\n\n-   Enters an infinite loop where it periodically reads sensor data, stores it in buffers, and sends it to the configured services.\n\n-   Controls the LED to indicate the status of operations.\n\n-   Manages the timing of data sending to ensure that each service receives data at the specified intervals.\n\n-   Logs system status and handles errors in the main loop.\n\n-   Upon encountering an error, most likely memory related, begins the loop again.\n\n</details>\n\nTest the code and verify that your circuit is functioning correctly. After that, configure Vercel or another API endpoint and Google App Script. Configuration details for Vercel can be found at: <https://jesse-anderson.github.io/Blog/_site/posts/Pi-Sensor-Proj-May-2024/>, so I'll skip that part. Create the JavaScript file(`sensorMongoDB.js`) below and place it in your /api folder. Ensure all changes are pushed to GitHub.\n\n<details>\n\n<summary>Code</summary>\n\n``` javascript\nconst { MongoClient } = require('mongodb');\n\nconst API_KEY = process.env.API_KEY; // Retrieve the API key from environment variables\nconst MONGO_URI = process.env.MONGODB_URI; // MongoDB connection string from environment variables\n\nconst MONGODB_DB_NAME = 'Raspberry_Pi'; // Database name\nconst MONGODB_COLLECTION_NAME = 'Readings'; // Collection name\n\nlet client;\n\nconst connectToMongo = async () => {\n    if (!client) {\n        client = new MongoClient(MONGO_URI, {\n            useNewUrlParser: true,\n            useUnifiedTopology: true,\n        });\n        await client.connect();\n    }\n    return client.db(MONGODB_DB_NAME);\n};\n\nconst handleSensorData = async (req, res) => {\n    if (req.method !== 'POST') {\n        return res.status(405).json({ error: 'Method not allowed' });\n    }\n\n    try {\n        console.log('Request received');  // For debugging purposes\n\n        // Extract API key from request headers\n        const providedApiKey = req.headers['x-api-key'];\n        console.log('Provided API Key:', providedApiKey);  // For debugging purposes\n\n        // Check if API key is provided and matches the expected API key\n        if (!providedApiKey || providedApiKey !== API_KEY) {\n            return res.status(401).json({ error: 'Unauthorized' });\n        }\n\n        // Extract data from request body\n        const data = req.body;\n\n        // Log the data received to console for verification\n        console.log('Received data:', JSON.stringify(data, null, 2));\n\n        const db = await connectToMongo();\n        const collection = db.collection(MONGODB_COLLECTION_NAME);\n\n        let result;\n\n        if (Array.isArray(data)) {\n            // Insert multiple readings\n            result = await collection.insertMany(data.map(entry => ({\n                ...entry,\n                temperatureCelsius: entry.temperatureCelsius !== null && entry.temperatureCelsius !== undefined ? entry.temperatureCelsius : 0,\n                temperatureFahrenheit: entry.temperatureFahrenheit !== null && entry.temperatureFahrenheit !== undefined ? entry.temperatureFahrenheit : 0,\n                humidityPercent: entry.humidityPercent !== null && entry.humidityPercent !== undefined ? entry.humidityPercent : 0,\n                date: entry.date !== null && entry.date !== undefined ? entry.date : new Date().toISOString().split('T')[0],\n                time: entry.time !== null && entry.time !== undefined ? entry.time : new Date().toISOString().split('T')[1].split('.')[0]\n            })));\n        } else {\n            // Insert a single reading\n            result = await collection.insertOne({\n                temperatureCelsius: data.temperatureCelsius !== null && data.temperatureCelsius !== undefined ? data.temperatureCelsius : 0,\n                temperatureFahrenheit: data.temperatureFahrenheit !== null && data.temperatureFahrenheit !== undefined ? data.temperatureFahrenheit : 0,\n                humidityPercent: data.humidityPercent !== null && data.humidityPercent !== undefined ? data.humidityPercent : 0,\n                date: data.date !== null && data.date !== undefined ? data.date : new Date().toISOString().split('T')[0],\n                time: data.time !== null && data.time !== undefined ? data.time : new Date().toISOString().split('T')[1].split('.')[0]\n            });\n        }\n\n        console.log('Data stored in MongoDB:', result);\n\n        // Send a successful response back to the client\n        res.status(200).json({ message: 'Data received and stored successfully!', data: result });\n    } catch (e) {\n        // Handle errors and send an error response\n        console.error(\"Error connecting to MongoDB or inserting data:\", e);\n        res.status(500).json({ error: 'Failed to connect to database or insert data', details: e.message });\n    }\n};\n\n// Export the function for Vercel\nmodule.exports = handleSensorData;\n```\n\n</details>\n\nI'll omit breaking down the code as it is similar enough to the code described in the earlier post.\n\n### Setting up Google Apps Script\n\nTo set up Google Apps Script, create a new project in Google App Script. Generate a new Google Sheet named 'ESP32' or a name of your choice. Populate the first row with \"Date \\| Time \\| Humidity % \\| Temp F \\| Temp C.\" Then, go to Extensions -\\> Apps Script and create a new script. Enter the code below and run the setup function by selecting it and clicking the play button.\n\n<details>\n\n<summary>Code</summary>\n\n``` javascript\n// 1. Enter sheet name where data is to be written below\nvar SHEET_NAME = \"Sheet1\";\n\nvar SCRIPT_PROP = PropertiesService.getScriptProperties(); // new property service\n\nfunction doGet(e) {\n  return handleResponse(e);\n}\n\nfunction doPost(e) {\n  return handleResponse(e);\n}\n\nfunction handleResponse(e) {\n  Logger.log(\"Request received: \" + JSON.stringify(e.parameter));\n  \n  var lock = LockService.getPublicLock();\n  lock.waitLock(500);  // wait 0.5 seconds before conceding defeat. Try 30 with more complicated \n  //We are essentially trying to prevent a race condition in which we have concurrent writes to the same spreadsheet. For this simple 1 python post to 1 spreadsheet this is essentially a non issue. Set to higher values if developing more complex nonsense.\n  try {\n    var docId = SCRIPT_PROP.getProperty(\"key\");\n    Logger.log(\"Using document ID: \" + docId);\n    var doc = SpreadsheetApp.openById(docId);\n    var sheet = doc.getSheetByName(SHEET_NAME);\n\n    var headRow = e.parameter.header_row || 1;\n    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];\n    var nextRow = sheet.getLastRow() + 1; // get next row\n    var row = [];\n    \n    for (var i in headers) {\n      if (headers[i] == \"Timestamp\") {\n        row.push(new Date());\n      } else {\n        row.push(e.parameter[headers[i]]);\n      }\n    }\n    \n    sheet.getRange(nextRow, 1, 1, row.length).setValues([row]);\n    \n    var output = JSON.stringify({\"result\": \"success\", \"row\": nextRow});\n    Logger.log(\"Data written to row: \" + nextRow);\n    \n    if (e.parameter.callback) {\n      return ContentService.createTextOutput(e.parameter.callback + \"(\" + output + \");\")\n                           .setMimeType(ContentService.MimeType.JAVASCRIPT);\n    } else {\n      return ContentService.createTextOutput(output)\n                           .setMimeType(ContentService.MimeType.JSON);\n    }\n  } catch (error) {\n    Logger.log(\"Error: \" + error.toString());\n    var output = JSON.stringify({\"result\": \"error\", \"error\": error.toString()});\n    if (e.parameter.callback) {\n      return ContentService.createTextOutput(e.parameter.callback + \"(\" + output + \");\")\n                           .setMimeType(ContentService.MimeType.JAVASCRIPT);\n    } else {\n      return ContentService.createTextOutput(output)\n                           .setMimeType(ContentService.MimeType.JSON);\n    }\n  } finally {\n    lock.releaseLock();\n  }\n}\n\nfunction setup() {\n  var doc = SpreadsheetApp.getActiveSpreadsheet();\n  SCRIPT_PROP.setProperty(\"key\", doc.getId());\n  Logger.log(\"Script property 'key' set to: \" + doc.getId());\n}\n```\n\n</details>\n\n<details>\n\n<summary>Code Summary</summary>\n\n#### **1. Setting Up Sheet Name and Script Properties**\n\nFirst, the script defines the name of the sheet where data will be written. It also initializes a property service to store script properties, which can be useful for managing script configurations and data across different executions.\n\n#### **2. Handling HTTP Requests**\n\nThe script includes functions to handle GET and POST requests. These functions delegate the request handling to a common function called **`handleResponse`**, which simplifies the code by centralizing the request processing logic.\n\n#### **3. Processing Incoming Requests**\n\nThe core of the script is the **`handleResponse`** function, which processes incoming HTTP requests. This function:\n\n-   **Logs the Request**: It logs the received parameters for debugging purposes, providing visibility into the incoming data.\n\n-   **Locks the Sheet**: Uses a public lock to prevent race conditions, ensuring that only one instance of the script writes to the sheet at a time. This is crucial for avoiding data corruption when multiple requests are processed simultaneously.\n\n-   **Accesses the Spreadsheet**: Retrieves the Google Sheet document ID from script properties, opens the sheet, and selects the specified sheet by name.\n\n-   **Prepares the Data Row**: Reads the headers from the first row of the sheet and constructs a new row of data based on the incoming request parameters. If a header is \"Timestamp\", it adds the current date and time.\n\n-   **Writes Data to the Sheet**: Writes the constructed row to the next available row in the sheet and logs the row number where data was written.\n\n-   **Generates the Response**: Constructs a JSON response indicating success and the row number. If a JSONP callback is specified, it formats the response accordingly.\n\n-   **Handles Errors**: Catches any errors that occur during the process, logs the error, and returns a JSON response indicating failure.\n\n-   **Releases the Lock**: Ensures that the lock is released at the end of the function, whether it completes successfully or encounters an error.\n\n#### **4. Setting Up the Script**\n\nA setup function is included to configure the script properties. It retrieves the active spreadsheet's ID and stores it in the script properties, allowing the **`handleResponse`** function to access the correct document.\n\n</details>\n\nAfter running setup you will get a key in the Execution log:\n\n``` plaintext\nInfo\nScript property 'key' set to: 130pgZ23ixGPtasNlpytXfubkbNfdskflsdfgbsjkdbfgsj\n```\n\nMake sure to check that this key matches your google sheet spreadsheet ID:\n\n``` plaintext\nhttps://docs.google.com/spreadsheets/d/<Your Spreadsheet ID>/edit\n```\n\nNext, go to the top right corner of the screen, select New deployment, populate the description, choose \"Execute As\" \"Me,\" and set \"Anyone\" under \"Who has access.\" Deploy the project, and you will receive a Deployment ID and Web App URL. Copy the Web App URL, which you will use for sending data.\n\nThe web app URL should be of the following form:\n\n``` plaintext\nhttps://script.google.com/macros/s/AKfycbzNi7_SbooXqXYjEfJdP233EaJ4EfsdgnjsdgdfskjgDF9/exec\n```\n\n### Running the Program with Data Logging\n\nAt this point, everything should be set up and ready for data logging. Run the program, and it should connect to Wi-Fi, enable the sensors, and start posting to your databases. Be aware that buffer sizes can cause errors, so I kept them small. One can increase the buffer size up to the point where you begin to get memory errors(the program will throw an exception and retry the data upload loop). Using an SD card for local logging is an option, but I haven't tried it yet. It could involve logging locally, then using a local web server to push data as needed.\n\n### Flashing the Program\n\nNext we put the ESP32 into download mode by holding boot and pressing reset and then saving the Thonny file to the ESP32 as main.py. After this test that your program is running by unplugging and plugging the ESP32 back in and listening to the COM4 port on Putty or observing the LED. Once you've verified this go back into Thonny and select File-\\>Open-\\>MicroPython device-\\>boot.py. Simply type import main as a new line and the program should boot every time you are connected to power. Note that this is a nuclear option and generally main.py should run on power up. From here you should be able to move the board wherever you want within your home or even hand solder the connection points with something like this:\n\n<https://www.amazon.com/Adafruit-Accessories-Perma-Proto-Full-Breadboard/dp/B00SK8KAMM>\n\nUse good wire and solder!\n\nA general diagram of the flow for the ESP32 is below:\n\n![](images/ESP32%20Sensor%20Flow.png)\n\nWe will make a few changes to the Google Apps Script so we can access the Sheet concurrently with the data logging:\n\n<details>\n\n<summary>Code</summary>\n\n``` javascript\n// 1. Enter sheet name where data is to be written below\nvar SHEET_NAME = \"Sheet1\";\n\nvar SCRIPT_PROP = PropertiesService.getScriptProperties(); // new property service\n\nfunction doGet(e) {\n  Logger.log(\"doGet called with parameters: \" + JSON.stringify(e.parameter));\n  if (e.parameter.action && e.parameter.action === 'getLastRow') {\n    Logger.log(\"Calling getLastRowData function\");\n    return getLastRowData();\n  } else if (e.parameter.action && e.parameter.action === 'getLast6000Rows') {\n    Logger.log(\"Calling getLast6000Rows function\");\n    return getLast6000Rows();\n  } else {\n    Logger.log(\"Invalid action or no action specified\");\n    return ContentService.createTextOutput(JSON.stringify({ error: \"Invalid action or no action specified\" })).setMimeType(ContentService.MimeType.JSON);\n  }\n}\n\n\nfunction doPost(e) {\n  Logger.log(\"doPost called with parameters: \" + JSON.stringify(e.parameter));\n  return handleResponse(e);\n}\n\nfunction handleResponse(e) {\n    var action = e.parameter.action;\n    Logger.log(\"handleResponse called with action: \" + e.parameter);\n\n    if (action === 'getLastRow') {\n        Logger.log(\"Calling getLastRowData function\");\n        return getLastRowData();\n    } else if (action === 'getLast6000Rows') {\n        Logger.log(\"Calling getLast6000Rows function\");\n        return getLast6000Rows();\n    } else {\n        try {\n            return handleDataSubmission(e);\n        } catch (error) {\n            Logger.log(\"Error in handleDataSubmission: \" + error.message);\n            return ContentService.createTextOutput(JSON.stringify({ error: \"Invalid action or no action specified\" })).setMimeType(ContentService.MimeType.JSON);\n        }\n    }\n}\n\nfunction handleDataSubmission(e) {\n  Logger.log(\"handleDataSubmission called with parameters: \" + JSON.stringify(e.parameter));\n  \n  var lock = LockService.getPublicLock();\n  lock.waitLock(500);  // wait 0.5 seconds before conceding defeat. Try 30 with more complicated \n  //We are essentially trying to prevent a race condition in which we have concurrent writes to the same spreadsheet. For this simple 1 python post to 1 spreadsheet this is essentially a non issue. Set to higher values if developing more complex nonsense.\n  try {\n    var docId = SCRIPT_PROP.getProperty(\"key\");\n    Logger.log(\"Using document ID: \" + docId);\n    var doc = SpreadsheetApp.openById(docId);\n    var sheet = doc.getSheetByName(SHEET_NAME);\n\n    var headRow = e.parameter.header_row || 1;\n    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];\n    var nextRow = sheet.getLastRow() + 1; // get next row\n    var row = [];\n    \n    for (var i in headers) {\n      if (headers[i] == \"Timestamp\") {\n        row.push(new Date());\n      } else {\n        row.push(e.parameter[headers[i]]);\n      }\n    }\n    \n    sheet.getRange(nextRow, 1, 1, row.length).setValues([row]);\n    \n    var output = JSON.stringify({\"result\": \"success\", \"row\": nextRow});\n    Logger.log(\"Data written to row: \" + nextRow);\n    \n    if (e.parameter.callback) {\n      return ContentService.createTextOutput(e.parameter.callback + \"(\" + output + \");\")\n                           .setMimeType(ContentService.MimeType.JAVASCRIPT);\n    } else {\n      return ContentService.createTextOutput(output)\n                           .setMimeType(ContentService.MimeType.JSON);\n    }\n  } catch (error) {\n    Logger.log(\"Error: \" + error.toString());\n    var output = JSON.stringify({\"result\": \"error\", \"error\": error.toString()});\n    if (e.parameter.callback) {\n      return ContentService.createTextOutput(e.parameter.callback + \"(\" + output + \");\")\n                           .setMimeType(ContentService.MimeType.JAVASCRIPT);\n    } else {\n      return ContentService.createTextOutput(output)\n                           .setMimeType(ContentService.MimeType.JSON);\n    }\n  } finally {\n    lock.releaseLock();\n  }\n}\n\nfunction setup() {\n  var doc = SpreadsheetApp.getActiveSpreadsheet();\n  SCRIPT_PROP.setProperty(\"key\", doc.getId());\n  Logger.log(\"Script property 'key' set to: \" + doc.getId());\n}\n\nfunction getLastRowData() {\n  try {\n    Logger.log(\"getLastRowData function called\");\n    // Open the spreadsheet by ID and get the specified sheet\n    var sheet = SpreadsheetApp.openById(SCRIPT_PROP.getProperty(\"key\")).getSheetByName(SHEET_NAME);\n    Logger.log('Sheet accessed successfully');\n    \n    // Get the last row number\n    var lastRow = sheet.getLastRow();\n    Logger.log('Last row number: ' + lastRow);\n    \n    // Get the values of the last row\n    var lastRowData = sheet.getRange(lastRow, 1, 1, sheet.getLastColumn()).getValues()[0];\n    Logger.log('Last row data: ' + JSON.stringify(lastRowData));\n    \n    // Get the headers from the first row\n    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];\n    Logger.log('Headers: ' + JSON.stringify(headers));\n    \n    // Create an object to store the last row data\n    var result = {};\n    \n    // Populate the result object with the headers as keys and last row data as values\n    headers.forEach(function(header, index) {\n      if (header === 'Date') {\n        result[header] = formatDate(lastRowData[index], \"America/Chicago\");\n      } else if (header === 'Time') {\n        result[header] = formatTime(lastRowData[index], \"America/Chicago\");\n      } else {\n        result[header] = lastRowData[index];\n      }\n    });\n    Logger.log('Result object: ' + JSON.stringify(result));\n    \n    // Convert the result object to JSON\n    var json = JSON.stringify(result);\n    Logger.log('JSON output: ' + json);\n    \n    // Ensure ContentService is defined and working\n    if (typeof ContentService === 'undefined') {\n      throw new Error('ContentService is not defined.');\n    }\n\n    // Return the JSON output\n    var output = ContentService.createTextOutput(json).setMimeType(ContentService.MimeType.JSON);\n    Logger.log('Output object created successfully.');\n    Logger.log('Output object: ' + output.getContent());\n    return output;\n  } catch (error) {\n    Logger.log('Error: ' + error.message);\n    return ContentService.createTextOutput(JSON.stringify({ error: error.message })).setMimeType(ContentService.MimeType.JSON);\n  }\n}\n\nfunction formatDate(dateString, timeZone) {\n  var date = new Date(dateString);\n  return Utilities.formatDate(date, timeZone, \"yyyy-MM-dd\");\n}\n\nfunction formatTime(timeString, timeZone) {\n  var date = new Date(timeString);\n  return Utilities.formatDate(date, timeZone, \"hh:mm:ss a\");\n}\n\nfunction getLast6000Rows() {\n  try {\n    Logger.log(\"getLast6000Rows function called\");\n    var sheet = SpreadsheetApp.openById(SCRIPT_PROP.getProperty(\"key\")).getSheetByName(SHEET_NAME);\n    Logger.log('Sheet accessed successfully');\n    \n    var lastRow = sheet.getLastRow();\n    Logger.log('Last row number: ' + lastRow);\n\n    var startRow = lastRow > 6000 ? lastRow - 5999 : 1; // Adjust the start row if there are fewer than 6000 rows\n    Logger.log('Start row number: ' + startRow);\n    \n    var numRows = lastRow - startRow + 1;\n    Logger.log('Number of rows to fetch: ' + numRows);\n\n    var dataRange = sheet.getRange(startRow, 1, numRows, sheet.getLastColumn());\n    var data = dataRange.getValues();\n    Logger.log('Fetched data: ' + JSON.stringify(data));\n\n    var headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];\n    Logger.log('Headers: ' + JSON.stringify(headers));\n\n    var result = data.map(function(row) {\n      var rowObject = {};\n      headers.forEach(function(header, index) {\n        if (header === 'Date') {\n          rowObject[header] = formatDate(row[index], \"America/Chicago\");\n        } else if (header === 'Time') {\n          rowObject[header] = formatTime(row[index], \"America/Chicago\");\n        } else {\n          rowObject[header] = row[index];\n        }\n      });\n      return rowObject;\n    });\n    Logger.log('Result object: ' + JSON.stringify(result));\n    \n    var json = JSON.stringify(result);\n    Logger.log('JSON output: ' + json);\n\n    var output = ContentService.createTextOutput(json).setMimeType(ContentService.MimeType.JSON);\n    Logger.log('Output object created successfully.');\n    Logger.log('Output object: ' + output.getContent());\n    return output;\n  } catch (error) {\n    Logger.log('Error: ' + error.message);\n    return ContentService.createTextOutput(JSON.stringify({ error: error.message })).setMimeType(ContentService.MimeType.JSON);\n  }\n}\n```\n\n</details>\n\nAnd here's a visual of what's going on:\n\n![](images/Google%20Apps%20Script%20GetPost.png)\n\nAnd here's the requests form to see the data:\n\nLatest sensor reading Google Sheets(button loads latest data):\n\n\n```{=html}\n<!-- Google Sheets Data Display -->\n<section>\n    <h2>Google Sheets Data Display</h2>\n    <button class=\"load-button\" onclick=\"loadLastRowGoogle()\">Load Google Sheets Data</button>\n    <table id=\"google-data-table\">\n<thead>\n<tr>\n<th>Date</th>\n<th>Time</th>\n<th>Humidity %</th>\n<th>Temp F</th>\n<th>Temp C</th>\n</tr>\n</thead>\n<tbody>\n<!-- Data will be inserted here -->\n</tbody>\n</table>\n</section>\n<script>\n    async function loadLastRowGoogle() {\n        const url = 'https://script.google.com/macros/s/AKfycbzNi7_SbooXqXYjEfJdP233EaJ4EVswgHxm6nWxMG6G5nfmmXfJsV3q5CzEigp_6D-8/exec?action=getLastRow';\n\n         try {\n            console.log('Fetching data from URL:', url);\n            const response = await fetch(url);\n            console.log('Response status:', response.status);\n            \n            if (!response.ok) {\n                throw new Error('Network response was not ok ' + response.statusText);\n            }\n\n            const json = await response.json();\n            console.log('Fetched data:', json);\n            \n            if (json) {\n                displayTableGoogle(json);\n            } else {\n                console.log('No data found.');\n            }\n        } catch (error) {\n            console.error(\"Error fetching data from Google Sheets:\", error);\n        }\n    }\n\n\n    function displayTableGoogle(row) {\n        console.log('Displaying data in Google Sheets table:', row);\n        const table = document.getElementById('google-data-table');\n        const tbody = table.querySelector('tbody');\n        //tbody.innerHTML = ''; // Clear any existing rows\n\n        const newRow = tbody.insertRow();\n        newRow.id = 'google-data-table-row';\n\n        const fields = ['Date', 'Time', 'Humidity %', 'Temp F', 'Temp C'];\n\n        const formattedRow = {\n            'Date': row['Date'],\n            'Time': row['Time'],\n            'Humidity %': row['Humidity %'],\n            'Temp F': row['Temp F'],\n            'Temp C': row['Temp C']\n        };\n\n        fields.forEach((field, index) => {\n            const newCell = newRow.insertCell();\n            newCell.id = `google-data-table-cell-${index + 1}`;\n            const text = document.createTextNode(formattedRow[field] || '');\n            newCell.appendChild(text);\n        });\n    }\n</script>\n<style>\n    #google-data-table {\n        width: 50%;\n        border-collapse: collapse;\n        margin: 50px auto;\n    }\n    #google-data-table th, #google-data-table td {\n        padding: 10px;\n        border: 1px solid #ddd;\n        text-align: center;\n    }\n    #google-data-table th {\n        background-color: #f2f2f2;\n    }\n    .load-button {\n        display: block;\n        margin: 20px auto;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n    }\n</style>\n```\n\nLatest Sensor Reading ThingSpeak(press button):\n\n\n```{=html}\n<!-- ThingSpeak Data Display -->\n<section>\n    <h2>ThingSpeak Data Display</h2>\n    <button class=\"load-button\" onclick=\"loadThingSpeakData()\">Load ThingSpeak Data</button>\n    <table id=\"thingspeak-data-table\">\n<thead>\n<tr>\n<th>Date</th>\n<th>Time</th>\n<th>Humidity %</th>\n<th>Temp F</th>\n<th>Temp C</th>\n</tr>\n</thead>\n<tbody>\n<!-- Data will be inserted here -->\n</tbody>\n</table>\n</section>\n\n<script>\n    async function loadThingSpeakData() {\n        const url = 'https://api.thingspeak.com/channels/2545447/feeds.json?results=1';\n\n        try {\n            const response = await fetch(url);\n            const json = await response.json();\n            if (json.feeds && json.feeds.length) {\n                const lastFeed = json.feeds[json.feeds.length - 1];\n                displayTableThingSpeak(lastFeed);\n            } else {\n                console.log('No data found.');\n            }\n        } catch (error) {\n            console.error(\"Error fetching data from ThingSpeak:\", error);\n        }\n    }\n\n    function displayTableThingSpeak(feed) {\n        const table = document.getElementById('thingspeak-data-table');\n        const tbody = table.querySelector('tbody');\n        const newRow = tbody.insertRow();\n        newRow.id = 'thingspeak-data-table-row';\n\n        const fields = ['field5', 'field4', 'field3', 'field2', 'field1'];\n        fields.forEach((field) => {\n            const newCell = newRow.insertCell();\n            newCell.id = `thingspeak-data-table-cell-${field}`;\n            const text = document.createTextNode(feed[field] || '');\n            newCell.appendChild(text);\n        });\n    }\n</script>\n\n<style>\n    #thingspeak-data-table {\n        width: 50%;\n        border-collapse: collapse;\n        margin: 50px auto;\n    }\n    #thingspeak-data-table th, #thingspeak-data-table td {\n        padding: 10px;\n        border: 1px solid #ddd;\n        text-align: center;\n    }\n    #thingspeak-data-table th {\n        background-color: #f2f2f2;\n    }\n    .load-button {\n        display: block;\n        margin: 20px auto;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n    }\n</style>\n```\n\nLatest Sensor Reading MongoDB(Read-Only User):\n\n\n```{=html}\n<!-- MongoDB Data Display -->\n<section>\n    <h2>MongoDB Data Display</h2>\n    <button class=\"load-button\" onclick=\"loadMongoDBData()\">Load MongoDB Data</button>\n    <table id=\"mongodb-data-table\">\n<thead>\n<tr>\n<th>Date</th>\n<th>Time</th>\n<th>Humidity %</th>\n<th>Temp F</th>\n<th>Temp C</th>\n</tr>\n</thead>\n<tbody>\n<!-- Data will be inserted here -->\n</tbody>\n</table>\n</section>\n<script>\n    async function loadMongoDBData() {\n        const url = 'https://vercel-raspberry-pi-server.vercel.app/api/displayLastRowSQLMongoDB';\n\n        try {\n            const response = await fetch(url);\n            const json = await response.json();\n            if (json) {\n                setTimeout(() => displayTableMongo(json), 3000); // Wait for 3 seconds before populating the table\n            } else {\n                console.log('No data found.');\n            }\n        } catch (error) {\n            console.error(\"Error fetching data:\", error);\n        }\n    }\n\n    function displayTableMongo(data) {\n        const table = document.getElementById('mongodb-data-table');\n        const tbody = table.querySelector('tbody');\n        const newRow = tbody.insertRow();\n\n        const fields = ['date', 'time', 'humidityPercent', 'temperatureFahrenheit', 'temperatureCelsius'];\n        fields.forEach((field) => {\n            const newCell = newRow.insertCell();\n            newCell.id = `mongodb-data-table-cell-${field}`;\n            const text = document.createTextNode(data[field] || '');\n            newCell.appendChild(text);\n        });\n    }\n</script>\n<style>\n    #mongodb-data-table {\n        width: 50%;\n        border-collapse: collapse;\n        margin: 50px auto;\n    }\n    #mongodb-data-table th, #mongodb-data-table td {\n        padding: 10px;\n        border: 1px solid #ddd;\n        text-align: center;\n    }\n    #mongodb-data-table th {\n        background-color: #f2f2f2;\n    }\n    .load-button {\n        display: block;\n        margin: 20px auto;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n    }\n</style>\n```\n\nLatest Sensor Reading Vercel PostgreSQL(Read-Only User):\n\n\n```{=html}\n<!-- Vercel Data Display -->\n<section>\n    <h2>Vercel Data Display</h2>\n    <button class=\"load-button\" onclick=\"loadVercelData()\">Load Vercel Data</button>\n    <table id=\"vercel-data-table\">\n<thead>\n<tr>\n<th>Date</th>\n<th>Time</th>\n<th>Humidity %</th>\n<th>Temp F</th>\n<th>Temp C</th>\n</tr>\n</thead>\n<tbody>\n<!-- Data will be inserted here -->\n</tbody>\n</table>\n</section>\n<script>\n    async function loadVercelData() {\n        const url = 'https://vercel-raspberry-pi-server.vercel.app/api/displayLastRowSQL';\n\n        try {\n            const response = await fetch(url);\n            const json = await response.json();\n            if (json) {\n                setTimeout(() => displayTableVercel(json), 3000); // Wait for 3 seconds before populating the table\n            } else {\n                console.log('No data found.');\n            }\n        } catch (error) {\n            console.error(\"Error fetching data:\", error);\n        }\n    }\n\n    function displayTableVercel(data) {\n        const table = document.getElementById('vercel-data-table');\n        const tbody = table.querySelector('tbody');\n        const newRow = tbody.insertRow();\n\n        const fields = ['date', 'time', 'humiditypercent', 'temperaturefahrenheit', 'temperaturecelsius'];\n        fields.forEach((field) => {\n            const newCell = newRow.insertCell();\n            newCell.id = `vercel-data-table-cell-${field}`;\n            const text = document.createTextNode(data[field] || '');\n            newCell.appendChild(text);\n        });\n    }\n</script>\n<style>\n    #vercel-data-table {\n        width: 50%;\n        border-collapse: collapse;\n        margin: 50px auto;\n    }\n    #vercel-data-table th, #vercel-data-table td {\n        padding: 10px;\n        border: 1px solid #ddd;\n        text-align: center;\n    }\n    #vercel-data-table th {\n        background-color: #f2f2f2;\n    }\n    .load-button {\n        display: block;\n        margin: 20px auto;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n    }\n</style>\n```\n\nFinally, as before in this post: <https://jesse-anderson.github.io/Blog/_site/posts/Pi-Sensor-Part-2/> We have a plot of the last 6000 or so values from Google this time. Note the changes in Google Apps Script above to make this possible...\n\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dynamic Plot</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns\"></script>\n    <style>\n        table {\n            width: 100%;\n            border-collapse: collapse;\n            margin-top: 20px;\n        }\n        th, td {\n            border: 1px solid #ddd;\n            padding: 8px;\n            text-align: center;\n        }\n        th {\n            background-color: #f2f2f2;\n        }\n        .loading-message {\n            text-align: center;\n            font-size: 1.2em;\n            margin-top: 20px;\n            display: none; /* Hide by default */\n        }\n    </style>\n</head>\n<body>\n    <h2>Pi Environment Test Data</h2>\n    <p><button onclick=\"loadCharts()\">Load Charts</button></p>\n    <p></p>\n    <p><button onclick=\"refreshData()\">Refresh</button></p>\n    <div id=\"loadingMessage\" class=\"loading-message\">Loading, please wait...</div>\n    <canvas id=\"tempChart\" width=\"400\" height=\"200\"></canvas>\n    <canvas id=\"humidityChart\" width=\"400\" height=\"200\"></canvas>\n    <div id=\"latestValues\"></div>\n    <script>\n        async function fetchData() {\n            try {\n                const response = await fetch('https://script.google.com/macros/s/AKfycbzNi7_SbooXqXYjEfJdP233EaJ4EVswgHxm6nWxMG6G5nfmmXfJsV3q5CzEigp_6D-8/exec?action=getLast6000Rows');\n                const data = await response.json();\n                console.log('Fetched data:', data);\n                if (data && Array.isArray(data)) {\n                    return data;\n                } else if (data && Array.isArray(data.rows)) {\n                    return data.rows;\n                } else {\n                    console.error('Unexpected data structure:', data);\n                    document.getElementById('latestValues').innerHTML = `<p>Unexpected data structure. Check console for details.</p>`;\n                    return [];\n                }\n            } catch (error) {\n                console.error('Error fetching data:', error);\n                document.getElementById('latestValues').innerHTML = `<p>Error fetching data. Check console for details.</p>`;\n                return [];\n            }\n        }\n\n        function processData(feeds) {\n            console.log('Processing data:', feeds);\n            if (!Array.isArray(feeds)) {\n                console.error('Data is not an array. Type:', typeof feeds);\n                console.log('Data value:', feeds);\n                document.getElementById('latestValues').innerHTML = `<p>Data is not an array. Type: ${typeof feeds}</p>`;\n                return { labels: [], tempF: [], humidity: [] };\n            }\n\n            const labels = feeds.map(feed => new Date(`${feed.Date} ${feed.Time}`));\n            const tempF = feeds.map(feed => parseFloat(feed['Temp F']));\n            const humidity = feeds.map(feed => parseFloat(feed['Humidity %']));\n            return { labels, tempF, humidity };\n        }\n\n        function displayLatestValues(labels, tempF, humidity) {\n            const latestTime = labels[labels.length - 1];\n            const latestTempF = tempF[tempF.length - 1];\n            const latestHumidity = humidity[humidity.length - 1];\n\n            const tableHTML = `\n                <table>\n    <tr>\n        <th>Time</th>\n        <th>Temp F</th>\n        <th>Humidity</th>\n    </tr>\n    <tr>\n        <td>${latestTime.toLocaleDateString('en-US')} ${latestTime.toLocaleTimeString('en-US')}</td>\n        <td>${latestTempF.toFixed(2)}</td>\n        <td>${latestHumidity.toFixed(2)}</td>\n    </tr>\n</table>\n            `;\n\n            document.getElementById('latestValues').innerHTML = tableHTML;\n        }\n\n        async function createCharts() {\n            document.getElementById('loadingMessage').style.display = 'block';\n\n            const feeds = await fetchData();\n            const { labels, tempF, humidity } = processData(feeds);\n\n            const tempCtx = document.getElementById('tempChart').getContext('2d');\n            const humidityCtx = document.getElementById('humidityChart').getContext('2d');\n\n            const tempChart = new Chart(tempCtx, {\n                type: 'line',\n                data: {\n                    labels: labels,\n                    datasets: [\n                        {\n                            label: 'Temperature F',\n                            data: tempF,\n                            borderColor: 'rgba(255, 165, 0, 1)',\n                            backgroundColor: 'rgba(255, 165, 0, 0.2)',\n                            borderWidth: 1,\n                            fill: true\n                        }\n                    ]\n                },\n                options: {\n                    scales: {\n                        x: {\n                            type: 'time',\n                            time: {\n                                unit: 'hour'\n                            }\n                        },\n                        y: {\n                            beginAtZero: true\n                        }\n                    }\n                }\n            });\n\n            const humidityChart = new Chart(humidityCtx, {\n                type: 'line',\n                data: {\n                    labels: labels,\n                    datasets: [\n                        {\n                            label: 'Humidity',\n                            data: humidity,\n                            borderColor: 'rgba(54, 162, 235, 1)',\n                            backgroundColor: 'rgba(54, 162, 235, 0.2)',\n                            borderWidth: 1,\n                            fill: true\n                        }\n                    ]\n                },\n                options: {\n                    scales: {\n                        x: {\n                            type: 'time',\n                            time: {\n                                unit: 'hour'\n                            }\n                        },\n                        y: {\n                            beginAtZero: true\n                        }\n                    }\n                }\n            });\n\n            displayLatestValues(labels, tempF, humidity);\n\n            document.getElementById('loadingMessage').style.display = 'none';\n\n            return { tempChart, humidityChart };\n        }\n\n        let chartInstances = {};\n\n        async function refreshData() {\n            document.getElementById('loadingMessage').style.display = 'block';\n\n            const feeds = await fetchData();\n            const { labels, tempF, humidity } = processData(feeds);\n\n            // Clear existing data\n            chartInstances.tempChart.data.labels = [];\n            chartInstances.tempChart.data.datasets[0].data = [];\n\n            chartInstances.humidityChart.data.labels = [];\n            chartInstances.humidityChart.data.datasets[0].data = [];\n\n            // Update with new data\n            chartInstances.tempChart.data.labels = labels;\n            chartInstances.tempChart.data.datasets[0].data = tempF;\n\n            chartInstances.humidityChart.data.labels = labels;\n            chartInstances.humidityChart.data.datasets[0].data = humidity;\n\n            // Update charts\n            chartInstances.tempChart.update();\n            chartInstances.humidityChart.update();\n\n            displayLatestValues(labels, tempF, humidity);\n\n            document.getElementById('loadingMessage').style.display = 'none';\n        }\n\n        async function loadCharts() {\n            document.getElementById('loadingMessage').style.display = 'block';\n\n            if (!chartInstances.tempChart && !chartInstances.humidityChart) {\n                chartInstances = await createCharts();\n            }\n\n            document.getElementById('loadingMessage').style.display = 'none';\n        }\n    </script>\n</body>\n</html>\n```\n\nMoving forward I'll likely add an LCD display, enclosure and more sensors, but the main point of this exercise was to become more familiar with the simpler, cost effective IoT devices. Additionally extending Google Apps script's functionality to include pulling data for plotting is tremendously useful for anyone who doesn't want to pay for ThingSpeak.\n\nOther thoughts:\n\n-   Getting the sensor to reliably take readings was a pain. Slightly moving the sensor caused readings to fail and no data to be transmitted.\n\n    -   Moving beyond a simple breadboard and hand soldering connections makes sense, but only for production. If that were the case, the odd 4-8 hours of getting a C/C++ version of this code up and running would make sense.\n\n-   Google Apps Script is awesome and its usually on me if something breaks. The fact that I can log about four-ish years worth of data at 1 log/min\n\n    -   2 million rows at 5 entries per row / 60 entries per hour / 24 hours per year / 365.25 days per year = 3.8 years\n\n    -   At 2 logs/min or 30 seconds per log: 1.9 years.\n\n-   The amount of processing power/memory and power(wattage) delivered to an ESP32 forced me to re evaluate the order of operations at several steps. Notably I spent some time debugging the wifi until I tried selectively powering things on or off. I also found that the program would randomly crash during POSTs and it would be the size of the response received that would cause a memory error.\n\n-   With the previous post most of the leg work in setting up the web interfaces was already taken care of so all I had to do was the wiring, some rewriting of Python code(notably Google Sheets sending), and overhauling the Google Apps script. Luckily I finally moved away from ThingSpeak for plotting/data acquistion for plotting and now I grab directly from Google. Its a little bit longer now and I could halve the time by grabbing less data. 6,000 data points is a lot and eventually, at a 30 second sampling time, that's nearly 50 hours of data with each plot.\n\n-   A breakout board would have sped up figuring out the circuit before placing everything down. I picked one up for a Pi Pico I'm tinkering with for a plant project and an Adafruit Pi Cobbler(basically a breakout board) for a raspberry pi and I notice the faster reference time is nice. It would likely be best to have a high quality breakout board alongside a final proto board to make sure the design sticks and loose connections don't hurt me.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}