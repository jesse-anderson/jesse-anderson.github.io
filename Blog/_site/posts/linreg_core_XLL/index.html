<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jesse Anderson">
<meta name="dcterms.date" content="2026-02-25">

<title>Jesse Anderson’s Blog - From DLL to XLL: Building an Excel Add-in in Pure Rust</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5CSPYCMY55"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5CSPYCMY55', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Jesse Anderson’s Blog - From DLL to XLL: Building an Excel Add-in in Pure Rust">
<meta property="og:description" content="">
<meta property="og:image" content="linreg_core_example_workbook_XLL.png">
<meta property="og:site_name" content="Jesse Anderson's Blog">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jesse Anderson’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Archive</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://portfolio.jesse-anderson.net/"> <i class="bi bi-Folder symlink fill" role="img">
</i> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jesse-anderson/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jesse-anderson-a7c5/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">From DLL to XLL: Building an Excel Add-in in Pure Rust</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Rust</div>
                <div class="quarto-category">VBA</div>
                <div class="quarto-category">Statistics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jesse Anderson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 25, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="from-dll-to-xll-building-an-excel-add-in-in-pure-rust" class="level1">
<h1>From DLL to XLL: Building an Excel Add-in in Pure Rust</h1>
<p>Skip VBA and call Rust from Excel formulas by building a pure‑Rust XLL add‑in. This article shows how XLLs work, how to bridge Excel’s XLOPER12 types, and how to ship 27 UDFs without the SDK.</p>
<p><strong>Table of Contents</strong></p>
<ol type="1">
<li><p><a href="#Section1">Introduction</a></p></li>
<li><p><a href="#Section2">What Is an XLL?</a></p></li>
<li><p><a href="#Section3">Pure Rust: No SDK, No C Compiler</a></p></li>
<li><p><a href="#Section4">The XLOPER12 Type: Excel’s Universal Value</a></p></li>
<li><p><a href="#Section5">Memory Ownership</a></p></li>
<li><p><a href="#Section6">The Excel12v Trampoline</a></p></li>
<li><p><a href="#Section7">UDF Registration</a></p></li>
<li><p><a href="#Section8">Converting Between Worlds</a></p></li>
<li><p><a href="#Section9">Error Handling</a></p></li>
<li><p><a href="#Section10">Testing Without Excel</a></p></li>
<li><p><a href="#Section11">From 2 UDFs to 27</a></p></li>
<li><p><a href="#Section12">VBA vs XLL</a></p></li>
<li><p><a href="#Section13">Building and Installing the XLL</a></p></li>
<li><p><a href="#Section14">Lessons Learned</a></p></li>
<li><p><a href="#Section15">Conclusion</a></p></li>
</ol>
<section id="Section1" class="level2">
<h2 class="anchored" data-anchor-id="Section1">1. Introduction</h2>
<p>The <a href="https://blog.jesse-anderson.net/posts/linreg_core_VBA_FFI/">previous article</a> ended with a working system: a Rust DLL callable from Excel VBA. Three lines of code to run an OLS regression, a few more to paste the results into a sheet. It works. But “it works” is not the same as “someone will use it.”</p>
<p>I have written scientific code that failed to get adopted. One project had an interface so ugly that nobody touched it. Another eventually gained traction, but only after I went back and made it user-friendly. The lesson I took away was simple and painful: think about other people using your code, not just yourself. Document the tooling. Do not assume that the variable names are second nature to anyone but you.</p>
<p>That lesson is what made me look at the VBA approach with honest eyes. The DLL itself is solid. But the delivery mechanism has friction. Even with the high-level VBA wrappers (where a user calls <code>LinReg_OLS</code> and gets a 2D array back), they still need to import a <code>.bas</code> module into their workbook and wire up a <code>Workbook_Open</code> event to call <code>LR_Init</code>. Under the hood, the wrapper is allocating VBA arrays, calling <code>VarPtr()</code> to pass raw pointers across the FFI boundary, checking a handle for zero, calling getter functions to extract results, and freeing the handle. If a user needs to go beyond the wrappers or debug a problem, they are face-to-face with all of that machinery.</p>
<p>I was debating how viable this actually was for a fellow engineer to pick up and use. The person I had in mind is a mechanical engineer who runs regressions but has only ever touched Excel, has no idea what you are talking about when you mention elastic net, ridge, lasso, or the LINE conditions for linear regression. For that person, the VBA approach is not viable. Not because it is broken, but because the distance between “open a workbook” and “get a regression output” is too large. They are not going to import a <code>.bas</code> module. They are not going to debug a <code>Workbook_Open</code> event that did not fire.</p>
<p>The question I kept coming back to: what if Excel could call Rust directly? No VBA, no macros, no handles, no <code>Declare PtrSafe Function</code>. Just a formula in a cell:</p>
<pre><code>=LINREG.OLS(A1:A20, B1:E20)</code></pre>
<p>Type it, press Enter, and a formatted coefficient table spills into the adjacent cells. Coefficients, standard errors, t-statistics, p-values, R-squared, F-statistic. Recalculates automatically when the data changes.</p>
<p>That is what an XLL is. And you do not need an SDK to build one.</p>
<hr>
<section id="what-this-xll-exposes" class="level3">
<h3 class="anchored" data-anchor-id="what-this-xll-exposes">What This XLL Exposes</h3>
<p>The add-in registers 27 worksheet UDFs across six categories, all powered by the same Rust core that backs the VBA DLL, the WASM module, and the Python bindings:</p>
<p><strong>Core regression</strong> (6 UDFs): OLS, WLS, Ridge, Lasso, Elastic Net, Polynomial</p>
<p><strong>Diagnostics</strong> (14 UDFs): Breusch-Pagan, White, Jarque-Bera, Shapiro-Wilk, Anderson-Darling, Harvey-Collier, Rainbow, RESET, Durbin-Watson, Breusch-Godfrey, VIF, Cook’s Distance, DFFITS, DFBETAS</p>
<p><strong>Cross-validation</strong> (4 UDFs): K-Fold for OLS, Ridge, Lasso, Elastic Net</p>
<p><strong>Prediction intervals</strong> (1 UDF): Point predictions with lower/upper bounds, standard errors, and leverage</p>
<p><strong>Lambda path</strong> (1 UDF): Logarithmically-spaced regularization parameter sequence</p>
<p><strong>Utility</strong> (1 UDF): Library version</p>
<p>Most formulas follow the same pattern: <code>=LINREG.FUNCTIONNAME(y_range, x_range, ...)</code>. The regularized methods (Ridge, Lasso, Elastic Net) and their cross-validation variants require additional parameters like <code>lambda</code> and <code>alpha</code>. A few UDFs diverge further: <code>LINREG.VERSION()</code> takes no arguments, <code>LINREG.WLS</code> adds a weights range, and <code>LINREG.PREDICTIONINTERVALS</code> adds a new-data range. The Function Wizard provides per-argument help text for all of them. Results spill automatically in Excel 365+.</p>
</section>
<section id="what-is-intentionally-excluded" class="level3">
<h3 class="anchored" data-anchor-id="what-is-intentionally-excluded">What Is Intentionally Excluded</h3>
<p>Not everything in linreg-core maps cleanly to a worksheet formula.</p>
<p><strong>LOESS</strong> is excluded because it takes a different input shape: a 1-D x vector rather than the row-major predictor matrix that every other UDF expects. Exposing it would require either a different argument convention (confusing) or silent reshaping (dangerous).</p>
<p><strong>Feature importance</strong> (SHAP values, permutation importance, standardized coefficients) involves multi-step workflows: fit a model, then compute importance relative to that fit. Worksheet formulas are stateless; there is no “fit, then query” pattern. These are better served by VBA or Python, where the user can hold a reference to the fitted model.</p>
<p><strong>Serialization</strong> (model save/load) does not map to cell formulas at all.</p>
<p><strong>Regularized polynomial variants</strong> and <strong>regularized prediction intervals</strong> are future work. The core implementations exist, but the XLL wrappers have not been written yet. The 27 UDFs cover the use cases that make sense as single-formula operations.</p>
<hr>
</section>
<section id="the-end-result" class="level3">
<h3 class="anchored" data-anchor-id="the-end-result">The End Result</h3>
<p>Here is the simplest use case. A user with data in columns A through E types this formula in cell G1:</p>
<pre><code>=LINREG.OLS(A1:A20, B1:E20)</code></pre>
<p>The result spills automatically:</p>
<pre><code>| Term          | Coefficient | Std Error | t Stat  | p-Value |
| Intercept     | 1.2345      | 0.4567    | 2.7034  | 0.0156  |
| X1            | 0.8901      | 0.1234    | 7.2131  | 0.0000  |
| X2            | -0.3456     | 0.0987    | -3.5015 | 0.0032  |
| X3            | 0.5678      | 0.2345    | 2.4209  | 0.0278  |
| X4            | 0.1234      | 0.1567    | 0.7875  | 0.4425  |
| R-squared     | 0.9234      |           |         |         |
| Adj R-squared | 0.9030      |           |         |         |
| F-statistic   | 45.2341     |           |         |         |
| F p-value     | 0.0000      |           |         |         |
| MSE           | 0.3456      |           |         |         |
| RMSE          | 0.5879      |           |         |         |</code></pre>
<p>No VBA. No macros. No handles. No paste step. Change a cell in the input range and the entire output recalculates.</p>
<p>Getting to that formula required solving problems in Excel’s C API, <code>#[repr(C)]</code> memory layout, runtime callback resolution, and ownership transfer, all in pure Rust, with no external SDK and zero new dependencies. The rest of this article walks through each of those in turn.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Section1_End_Result.png" class="lightbox" data-glightbox="description: .lightbox-desc-1" data-gallery="quarto-lightbox-gallery-1" title="Figure 1: A single formula spills a full regression table; no VBA required."><img src="Section1_End_Result.png" class="img-fluid figure-img" alt="A worksheet cell with =LINREG.OLS(...) and the spilled regression table (headers, coefficients, and summary rows)."></a></p>
<figcaption>Figure 1: A single formula spills a full regression table; no VBA required.</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="Section2" class="level2">
<h2 class="anchored" data-anchor-id="Section2">2. What Is an XLL?</h2>
<p>An XLL is a DLL with a specific set of exported callback functions that Excel knows to look for. You rename the file from <code>.dll</code> to <code>.xll</code>, point Excel at it through the Add-in Manager, and Excel loads it into its own process. From that point on, Excel is the caller and your code is the callee. This is the fundamental inversion from the VBA/DLL approach.</p>
<section id="the-inversion-of-control" class="level3">
<h3 class="anchored" data-anchor-id="the-inversion-of-control">The Inversion of Control</h3>
<p>In the VBA article, the control flow was: VBA calls <code>LR_OLS</code>, the DLL does work, VBA retrieves results via getter functions. VBA owned the conversation. It decided when to call, what to pass, and what to do with the output.</p>
<p>With an XLL, Excel owns the conversation. When the add-in loads, Excel calls your <code>xlAutoOpen</code> function and asks: what do you have? You respond by registering your UDFs. From then on, whenever a user types <code>=LINREG.OLS(...)</code> in a cell, Excel calls your exported function directly, passing the cell contents as structured data. Your function computes the result, returns it in Excel’s native format, and Excel displays it. When Excel is done with the returned data, it calls your <code>xlAutoFree12</code> function to let you clean up.</p>
<p>You do not initiate the conversation. Excel does. (You do call <em>back</em> into Excel for specific tasks like UDF registration, retrieving the DLL path, and freeing Excel-owned memory, but those calls happen through a callback pointer that Excel provides. The distinction matters: you are responding within Excel’s protocol, not driving it.)</p>
</section>
<section id="required-exports" class="level3">
<h3 class="anchored" data-anchor-id="required-exports">Required Exports</h3>
<p>Excel recognizes a DLL as an XLL if it exports <code>xlAutoOpen</code>. In practice, a well-behaved XLL exports three functions:</p>
<p><strong><code>xlAutoOpen</code></strong> is called once when Excel loads the add-in. This is where you register every UDF you want to expose. Registration tells Excel the function’s exported symbol name, what it should be called in the worksheet, what argument types it accepts, what category it belongs to in the Function Wizard, and what help text to display. If <code>xlAutoOpen</code> returns without registering anything, the add-in loads but does nothing.</p>
<p><strong><code>xlAutoFree12</code></strong> is called by Excel after it has finished copying a value returned by one of your UDFs. This is the memory management callback. When a UDF returns a heap-allocated result (a string, a 2D array), it sets a flag (<code>xlbitDLLFree</code>) that tells Excel: “call me back when you are done so I can free this.” Without this function, every returned string and every returned array leaks.</p>
<p><strong><code>xlAutoClose</code></strong> is called when Excel unloads the add-in. In this XLL, it does nothing (returns 1). The only global state in the XLL is a single <code>AtomicPtr</code> that caches the address of Excel’s internal callback function, and that is just a memory address, not an allocated resource. There are no connections to close, no threads to join, no allocations to free. The export is not strictly required for XLL recognition, but providing it is good practice.</p>
</section>
<section id="optional-export" class="level3">
<h3 class="anchored" data-anchor-id="optional-export">Optional Export</h3>
<p><strong><code>xlAddInManagerInfo12</code></strong> is called by Excel’s Add-in Manager dialog to get a display name for the add-in. When Excel passes <code>1</code> as the argument, you return a string. I return <code>"LinReg Core"</code>. This is purely cosmetic, but it is better than seeing the raw filename in the manager list.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1"></a><span class="at">#[</span>no_mangle<span class="at">]</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span> xlAddInManagerInfo12(action<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="cf">if</span> <span class="op">!</span>action<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>        <span class="kw">let</span> oper <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span>action <span class="op">};</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>        <span class="kw">let</span> is_one <span class="op">=</span> <span class="cf">match</span> oper<span class="op">.</span>base_type() <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>            XLTYPE_NUM <span class="op">=&gt;</span> (<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>num <span class="op">}</span>) <span class="op">==</span> <span class="dv">1.0</span><span class="op">,</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>            XLTYPE_INT <span class="op">=&gt;</span> (<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>w <span class="op">}</span>) <span class="op">==</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>            _ <span class="op">=&gt;</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="op">};</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>        <span class="cf">if</span> is_one <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>            <span class="cf">return</span> <span class="dt">Box</span><span class="pp">::</span>into_raw(<span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">XLOPER12::</span>from_str(<span class="st">"LinReg Core"</span>)))<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    return_xl_error(XLERR_VALUE)</span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-data-type-at-the-boundary" class="level3">
<h3 class="anchored" data-anchor-id="the-data-type-at-the-boundary">The Data Type at the Boundary</h3>
<p>Every value that crosses the XLL boundary is an <code>XLOPER12</code>. This is Excel’s universal value type: a C struct with a type tag and a union of possible values. A single cell with a number is an <code>XLOPER12</code>. A range of cells is an <code>XLOPER12</code> containing a 2D array of <code>XLOPER12</code>s. An error like <code>#VALUE!</code> is an <code>XLOPER12</code>. A missing optional argument is an <code>XLOPER12</code>.</p>
<p>In the VBA article, the boundary types were raw scalars: <code>*const f64</code> for arrays, <code>i32</code> for counts, <code>usize</code> for handles. The types were simple but the protocol was complex (allocate a buffer, pass its pointer and size, check return values, call getters individually, free the handle).</p>
<p>Here, the types are complex but the protocol is simple: Excel gives you <code>XLOPER12</code>s, you give one back. One function call, one return value. The complexity moves from the calling convention into the data structure itself.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="xll_architecture.png" class="lightbox" data-glightbox="description: .lightbox-desc-2" data-gallery="quarto-lightbox-gallery-2" title="Figure 2: Architecture: Excel calls XLL UDFs; XLOPER12 crosses the boundary to the Rust core."><img src="xll_architecture.png" class="img-fluid figure-img" alt="Three‑layer architecture: Excel -> XLL boundary layer -> Rust core, with XLOPER12 crossing the boundary and xlAutoFree12"></a></p>
<figcaption>Figure 2: Architecture: Excel calls XLL UDFs; XLOPER12 crosses the boundary to the Rust core.</figcaption>
</figure>
</div>
<p>The next three sections cover that data structure: what <code>XLOPER12</code> looks like in Rust, how memory ownership works, and how to call back into Excel without linking against anything.</p>
<hr>
</section>
</section>
<section id="Section3" class="level2">
<h2 class="anchored" data-anchor-id="Section3">3. Pure Rust: No SDK, No C Compiler</h2>
<p>The conventional approach to building an XLL involves external tooling. You need header files for the type definitions, a C source file for the callback trampoline, and an import library to link against. You compile the C source into an object file, link it alongside your code, and hope the versions match.</p>
<p>I took a different path: implement the entire XLL infrastructure in pure Rust. No C compiler in the build chain, no external files to download, no import library to link against.</p>
<section id="what-i-replaced" class="level3">
<h3 class="anchored" data-anchor-id="what-i-replaced">What I Replaced</h3>
<p>Three things typically come from outside your project when building an XLL:</p>
<p><strong>Type definitions.</strong> The <code>XLOPER12</code> struct, its union variants, the type tag constants, the error codes. I defined all of these as <code>#[repr(C)]</code> Rust structs and constants in <code>types.rs</code>. The layout must match what Excel expects byte-for-byte, but the definitions themselves are straightforward. A <code>u32</code> type tag, a union of value variants, and a handful of integer constants.</p>
<p><strong>The callback trampoline.</strong> To call back into Excel (for UDF registration, retrieving the DLL path, freeing Excel-owned memory), you need to reach Excel’s internal entry point. The conventional approach links against a library that provides this. I resolve it at runtime instead: <code>GetModuleHandleA(NULL)</code> returns the host process handle (which is Excel itself, since the XLL is loaded into Excel’s process), and <code>GetProcAddress("MdCallBack12")</code> finds the callback function. The result is cached in an <code>AtomicPtr</code> on first use. The entire mechanism lives in <code>entrypoint.rs</code>, a single file of about 100 lines including type definitions, the cached lookup, and convenience wrappers.</p>
<p><strong>The import library.</strong> Not needed. When you resolve the entry point dynamically via <code>GetProcAddress</code>, there is nothing to link against at build time. The dependency is resolved at runtime, inside Excel’s process.</p>
<p>The result: the XLL feature in <code>Cargo.toml</code> is defined as <code>xll = []</code>. No optional dependencies. No <code>build.rs</code> logic (the existing <code>build.rs</code> only fires for the <code>ffi</code> feature on 32-bit targets). The XLL compiles with the same toolchain you already have installed for Rust on Windows.</p>
</section>
<section id="why-not-use-an-existing-crate" class="level3">
<h3 class="anchored" data-anchor-id="why-not-use-an-existing-crate">Why Not Use an Existing Crate?</h3>
<p>Early on I found the <code>xladd</code> and <code>xladd-derive</code> crates on crates.io. I spent about an hour trying to get a simple example working. The crate had not been updated in roughly four years (as of early 2025, when I evaluated it), and I ran into issues that suggested it was not compatible with my version of Rust. I did not want to sink more hours into it only to discover a deeper incompatibility later.</p>
<p>Walking away from <code>xladd</code> turned out to be the right call. Building from the ground up gave me very fine granular control over the type layout, the memory management protocol, and the registration process. More control than I would have had importing a crate that abstracted those details away. The initial investment was significant (the ideation-to-first-working-UDF phase took roughly 20 hours), but it paid off when scaling from 1 UDF to 27, because I understood every layer of the stack.</p>
</section>
<section id="what-this-means-for-the-build" class="level3">
<h3 class="anchored" data-anchor-id="what-this-means-for-the-build">What This Means for the Build</h3>
<p>The XLL build command is:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="ex">cargo</span> build <span class="at">--release</span> <span class="at">--features</span> xll <span class="at">--no-default-features</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>--features xll</code> enables the XLL module. <code>--no-default-features</code> disables the default <code>wasm</code> feature, because WASM and XLL are mutually exclusive build targets: one targets a browser sandbox, the other targets Excel’s native C API.</p>
<p>The output is <code>target/release/linreg_core.dll</code>. Rename it to <code>.xll</code> and Excel can load it as an add-in. The entire build uses <code>rustc</code> and the MSVC linker, nothing else.</p>
<hr>
</section>
</section>
<section id="Section4" class="level2">
<h2 class="anchored" data-anchor-id="Section4">4. The XLOPER12 Type: Excel’s Universal Value</h2>
<p>Every value that crosses the XLL boundary, in either direction, is an <code>XLOPER12</code>. A cell containing a number, a range of cells, an error code, a missing optional argument: all of them arrive as the same struct. Understanding this struct is the prerequisite for everything that follows.</p>
<section id="the-layout" class="level3">
<h3 class="anchored" data-anchor-id="the-layout">The Layout</h3>
<p>The <code>XLOPER12</code> is a tagged union. A <code>u32</code> type tag says what kind of value it holds, and a C union provides the storage for that value:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1"></a><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">pub</span> <span class="kw">struct</span> XLOPER12 <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">pub</span> val<span class="op">:</span> XLOPER12Val<span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">pub</span> xltype<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">pub</span> <span class="kw">union</span> XLOPER12Val <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="kw">pub</span> num<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span>                              <span class="co">// xltypeNum</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="kw">pub</span> str_<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u16</span><span class="op">,</span>                        <span class="co">// xltypeStr</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">pub</span> xbool<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span>                            <span class="co">// xltypeBool</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="kw">pub</span> err<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span>                              <span class="co">// xltypeErr</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="kw">pub</span> w<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span>                                <span class="co">// xltypeInt</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="kw">pub</span> array<span class="op">:</span> ManuallyDrop<span class="op">&lt;</span>XLOPER12Array<span class="op">&gt;,</span>     <span class="co">// xltypeMulti</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="kw">pub</span> sref<span class="op">:</span> ManuallyDrop<span class="op">&lt;</span>XLOPER12SRef<span class="op">&gt;,</span>       <span class="co">// xltypeSRef</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">pub</span> mref<span class="op">:</span> ManuallyDrop<span class="op">&lt;</span>XLOPER12MRef<span class="op">&gt;,</span>       <span class="co">// xltypeMRef</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>#[repr(C)]</code> is critical. Without it, Rust is free to reorder fields and insert padding however it likes. With it, the struct layout matches what Excel’s C API expects byte-for-byte.</p>
</section>
<section id="the-variants-that-matter" class="level3">
<h3 class="anchored" data-anchor-id="the-variants-that-matter">The Variants That Matter</h3>
<p>Not every variant in the union gets used. For a statistical regression library, five variants carry the load:</p>
<p><strong><code>xltypeNum</code></strong> (<code>0x0001</code>): an <code>f64</code>. This is what a cell containing a number looks like when it arrives as an argument. A single cell <code>A1</code> containing <code>42.0</code> arrives as an XLOPER12 with <code>xltype = 1</code> and <code>val.num = 42.0</code>.</p>
<p><strong><code>xltypeStr</code></strong> (<code>0x0002</code>): a pointer to a length-counted UTF-16 buffer. The first <code>u16</code> is the character count, followed by that many UTF-16 code units. Not null-terminated. This is a Pascal-style string encoding, not a C string. I use this for output labels (“Term”, “Coefficient”, “R-squared”) and the version string.</p>
<p><strong><code>xltypeMulti</code></strong> (<code>0x0040</code>): a 2D array of XLOPER12s. When Excel passes a range like <code>A1:E20</code>, it arrives as an <code>xltypeMulti</code> containing 100 XLOPER12 elements in row-major order. Each element is itself an XLOPER12 (usually <code>xltypeNum</code> for numeric cells). This is also how I return results: a grid of mixed-type cells (string labels in column 0, numeric values in the other columns).</p>
<p><strong><code>xltypeErr</code></strong> (<code>0x0010</code>): an Excel error code. The <code>err</code> field holds an integer that maps to a specific error cell:</p>
<table class="table">
<thead>
<tr class="header">
<th>Error Code</th>
<th>Constant</th>
<th>Excel Display</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>XLERR_NULL</code></td>
<td><code>#NULL!</code></td>
</tr>
<tr class="even">
<td>7</td>
<td><code>XLERR_DIV0</code></td>
<td><code>#DIV/0!</code></td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>XLERR_VALUE</code></td>
<td><code>#VALUE!</code></td>
</tr>
<tr class="even">
<td>23</td>
<td><code>XLERR_REF</code></td>
<td><code>#REF!</code></td>
</tr>
<tr class="odd">
<td>29</td>
<td><code>XLERR_NAME</code></td>
<td><code>#NAME?</code></td>
</tr>
<tr class="even">
<td>36</td>
<td><code>XLERR_NUM</code></td>
<td><code>#NUM!</code></td>
</tr>
<tr class="odd">
<td>42</td>
<td><code>XLERR_NA</code></td>
<td><code>#N/A</code></td>
</tr>
</tbody>
</table>
<p>I map Rust errors to these codes via <code>linreg_err_to_xl()</code>. A singular matrix becomes <code>#NUM!</code>. A dimension mismatch becomes <code>#VALUE!</code>. The user sees a native Excel error cell, indistinguishable from one produced by a built-in function.</p>
<p><strong><code>xltypeMissing</code></strong> (<code>0x0080</code>): the argument was not provided. When a UDF is registered with optional parameters and the user leaves one out, that parameter arrives as <code>xltypeMissing</code>. I check for this and apply defaults (e.g., <code>alpha</code> defaults to 0.05 for prediction intervals, <code>n_folds</code> defaults to 5 for cross-validation).</p>
</section>
<section id="the-manuallydrop-requirement" class="level3">
<h3 class="anchored" data-anchor-id="the-manuallydrop-requirement">The <code>ManuallyDrop</code> Requirement</h3>
<p>Three union variants (<code>array</code>, <code>sref</code>, <code>mref</code>) contain structs with pointer fields. Rust does not allow types that implement <code>Drop</code> to live inside a union, because the compiler cannot know which variant is active and therefore cannot run the correct destructor. <code>ManuallyDrop&lt;T&gt;</code> solves this by wrapping the struct and suppressing its <code>Drop</code> implementation, telling the compiler: “I will handle cleanup myself.” Memory for these variants is managed externally through <code>xlAutoFree12</code>, not through Rust’s drop semantics.</p>
</section>
<section id="constructors" class="level3">
<h3 class="anchored" data-anchor-id="constructors">Constructors</h3>
<p>Building XLOPER12 values by hand every time would be tedious and error-prone. A few constructors cover the common cases:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">impl</span> XLOPER12 <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">pub</span> <span class="kw">fn</span> from_f64(v<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>            val<span class="op">:</span> XLOPER12Val <span class="op">{</span> num<span class="op">:</span> v <span class="op">},</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>            xltype<span class="op">:</span> XLTYPE_NUM<span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>        <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="kw">pub</span> <span class="kw">fn</span> from_err(code<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>            val<span class="op">:</span> XLOPER12Val <span class="op">{</span> err<span class="op">:</span> code <span class="op">},</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>            xltype<span class="op">:</span> XLTYPE_ERR<span class="op">,</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>    <span class="kw">pub</span> <span class="kw">fn</span> from_str(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>        <span class="kw">let</span> utf16<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u16</span><span class="op">&gt;</span> <span class="op">=</span> s<span class="op">.</span>encode_utf16()<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>        <span class="kw">let</span> len <span class="op">=</span> utf16<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>        <span class="cf">if</span> len <span class="op">&gt;</span> <span class="dv">32767</span> <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>            <span class="cf">return</span> <span class="dt">Self</span><span class="pp">::</span>from_err(XLERR_VALUE)<span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>        <span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a>        <span class="kw">let</span> <span class="kw">mut</span> buf<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(len <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>        buf<span class="op">.</span>push(len <span class="kw">as</span> <span class="dt">u16</span>)<span class="op">;</span>        <span class="co">// length prefix</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>        buf<span class="op">.</span>extend_from_slice(<span class="op">&amp;</span>utf16)<span class="op">;</span> <span class="co">// character data</span></span>
<span id="cb7-26"><a href="#cb7-26"></a></span>
<span id="cb7-27"><a href="#cb7-27"></a>        <span class="kw">let</span> ptr <span class="op">=</span> buf<span class="op">.</span>as_mut_ptr()<span class="op">;</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>        <span class="pp">std::mem::</span>forget(buf)<span class="op">;</span>         <span class="co">// transfer ownership to Excel</span></span>
<span id="cb7-29"><a href="#cb7-29"></a></span>
<span id="cb7-30"><a href="#cb7-30"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb7-31"><a href="#cb7-31"></a>            val<span class="op">:</span> XLOPER12Val <span class="op">{</span> str_<span class="op">:</span> ptr <span class="op">},</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>            xltype<span class="op">:</span> XLTYPE_STR <span class="op">|</span> XLBIT_DLL_FREE<span class="op">,</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>        <span class="op">}</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>    <span class="op">}</span></span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>from_f64</code> and <code>from_err</code> are trivial: set the union field, set the type tag. <code>from_str</code> is where it gets interesting.</p>
<p>The string must be UTF-16 with a length prefix. <code>encode_utf16()</code> handles the encoding. The length is pushed as the first <code>u16</code>, then the character data follows. The <code>Vec</code> is then leaked via <code>std::mem::forget</code>: this transfers ownership of the buffer from Rust’s allocator to the XLOPER12. The <code>XLBIT_DLL_FREE</code> flag in the type tag tells Excel to call <code>xlAutoFree12</code> when it is done, at which point I reclaim the memory with <code>Vec::from_raw_parts</code>. If the string exceeds 32,767 characters (Excel’s limit for cell values), it falls back to an error instead.</p>
<p>This pattern, <code>Vec</code> to raw pointer via <code>forget</code>, raw pointer back to <code>Vec</code> via <code>from_raw_parts</code>, is the same ownership transfer idiom that Rust uses everywhere at the FFI boundary. It is explicit and auditable, and because the allocation and reclamation are each concentrated in one function (<code>from_str</code> and <code>xlAutoFree12</code>), correctness is enforced by review and tests rather than scattered across call sites. The mechanics of that reclamation are covered in the next section.</p>
</section>
<section id="contrast-with-the-dll-approach" class="level3">
<h3 class="anchored" data-anchor-id="contrast-with-the-dll-approach">Contrast with the DLL Approach</h3>
<p>In the VBA article, the boundary was raw scalars. A <code>*const f64</code> pointer and an <code>i32</code> count for arrays. A <code>usize</code> handle for stored results. The types were simple, but the calling protocol was multi-step: call a fit function, check the handle, call individual getters, pass pre-allocated buffers, check return counts, free the handle.</p>
<p>Here, a single XLOPER12 contains the entire input or the entire output. A range of 20 rows and 5 columns arrives as one argument. The full regression result, headers and statistics included, goes back as one return value. The type is more complex, but the protocol disappears.</p>
<hr>
</section>
</section>
<section id="Section5" class="level2">
<h2 class="anchored" data-anchor-id="Section5">5. Memory Ownership</h2>
<p>The XLOPER12 type is straightforward once you see the layout. The hard part is knowing who owns the memory behind each XLOPER12, and when that memory gets freed. Get this wrong and the XLL either leaks memory on every call or crashes Excel with a double-free.</p>
<p>Three rules govern ownership at the XLL boundary.</p>
<section id="rule-1-input-xloper12s-are-excel-owned" class="level3">
<h3 class="anchored" data-anchor-id="rule-1-input-xloper12s-are-excel-owned">Rule 1: Input XLOPER12s Are Excel-Owned</h3>
<p>When Excel calls a UDF, the XLOPER12 pointers it passes as arguments belong to Excel. The UDF can read them but must not free them, modify them, or store pointers into them past the return of the function. Excel manages their lifetime.</p>
<p>In practice, this means every UDF’s first step is to <em>copy</em> the data out of the input XLOPER12s into Rust-owned <code>Vec&lt;f64&gt;</code> vectors. Once the data is in a <code>Vec</code>, Rust owns it and can do whatever it wants. The input pointers are never touched again.</p>
</section>
<section id="rule-2-returned-xloper12s-are-dll-owned" class="level3">
<h3 class="anchored" data-anchor-id="rule-2-returned-xloper12s-are-dll-owned">Rule 2: Returned XLOPER12s Are DLL-Owned</h3>
<p>When a UDF returns a result to Excel, the DLL allocates it on the heap and hands Excel a raw pointer. The XLOPER12 must have the <code>xlbitDLLFree</code> flag set in its <code>xltype</code> field. This flag tells Excel: “I allocated this. When you are done copying the data, call <code>xlAutoFree12</code> so I can free it.”</p>
<p>The allocation side looks like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// Returning a string (xl_linreg_version)</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">let</span> result <span class="op">=</span> <span class="pp">XLOPER12::</span>from_str(<span class="pp">env!</span>(<span class="st">"CARGO_PKG_VERSION"</span>))<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="dt">Box</span><span class="pp">::</span>into_raw(<span class="dt">Box</span><span class="pp">::</span>new(result))</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">// Returning a 2D array (build_multi)</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">let</span> result <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(XLOPER12 <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    val<span class="op">:</span> XLOPER12Val <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>        array<span class="op">:</span> <span class="pp">ManuallyDrop::</span>new(XLOPER12Array <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>            lparray<span class="op">,</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>            rows<span class="op">:</span> rows <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>            columns<span class="op">:</span> cols <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>        <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="op">},</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    xltype<span class="op">:</span> XLTYPE_MULTI <span class="op">|</span> XLBIT_DLL_FREE<span class="op">,</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="dt">Box</span><span class="pp">::</span>into_raw(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Box::into_raw</code> is the key function. It takes a heap-allocated value and returns a raw pointer, <em>without</em> running the destructor. Ownership transfers from Rust’s allocator to the raw pointer. Nothing will free this memory until someone explicitly reclaims it.</p>
<p>That is where <code>xlAutoFree12</code> comes in.</p>
</section>
<section id="rule-3-xloper12s-from-excel12v-are-excel-owned" class="level3">
<h3 class="anchored" data-anchor-id="rule-3-xloper12s-from-excel12v-are-excel-owned">Rule 3: XLOPER12s from Excel12v Are Excel-Owned</h3>
<p>When the XLL calls back into Excel (via the <code>MdCallBack12</code> trampoline), Excel may return an XLOPER12 that Excel allocated. These must be freed by calling <code>xlFree</code>, which tells Excel to reclaim its own memory. The XLL must not attempt to free these with <code>Box::from_raw</code> or <code>Vec::from_raw_parts</code>, because they were not allocated by Rust’s allocator.</p>
<p>This comes up in one place: <code>Reg::new()</code> calls <code>xlGetName</code> to retrieve the DLL’s file path from Excel. Excel returns a string XLOPER12 that it allocated. When the <code>Reg</code> struct is dropped, that string is freed via <code>excel_free</code>, which calls back into Excel with <code>xlFree</code> so Excel can reclaim its own memory.</p>
</section>
<section id="the-xlautofree12-implementation" class="level3">
<h3 class="anchored" data-anchor-id="the-xlautofree12-implementation">The <code>xlAutoFree12</code> Implementation</h3>
<p>This is the function that makes Rule 2 work. Excel calls it when it is done with a DLL-allocated XLOPER12. The implementation must correctly reclaim every allocation, including nested ones inside arrays:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1"></a><span class="at">#[</span>no_mangle<span class="at">]</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span> xlAutoFree12(p<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12) <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="cf">if</span> p<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>        <span class="kw">let</span> base <span class="op">=</span> (<span class="op">*</span>p)<span class="op">.</span>xltype <span class="op">&amp;</span> <span class="dv">0x0FFF</span><span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">match</span> base <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>            XLTYPE_STR <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>                <span class="kw">let</span> ptr <span class="op">=</span> (<span class="op">*</span>p)<span class="op">.</span>val<span class="op">.</span>str_<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>                <span class="cf">if</span> <span class="op">!</span>ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>                    <span class="kw">let</span> len <span class="op">=</span> <span class="op">*</span>ptr <span class="kw">as</span> <span class="dt">usize</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// length prefix + chars</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>                    <span class="kw">let</span> _ <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>from_raw_parts(ptr<span class="op">,</span> len<span class="op">,</span> len)<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>                <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>            <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>            XLTYPE_MULTI <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>                <span class="kw">let</span> arr <span class="op">=</span> <span class="op">&amp;*</span><span class="pp">std::ptr::addr_of!</span>((<span class="op">*</span>p)<span class="op">.</span>val<span class="op">.</span>array)<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>                <span class="kw">let</span> total <span class="op">=</span> (arr<span class="op">.</span>rows <span class="op">*</span> arr<span class="op">.</span>columns) <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>                <span class="co">// Free strings inside array elements</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>total <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>                    <span class="kw">let</span> elem <span class="op">=</span> <span class="op">&amp;*</span>arr<span class="op">.</span>lparray<span class="op">.</span>add(i)<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>                    <span class="cf">if</span> (elem<span class="op">.</span>xltype <span class="op">&amp;</span> <span class="dv">0x0FFF</span>) <span class="op">==</span> XLTYPE_STR <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>                        <span class="kw">let</span> ptr <span class="op">=</span> elem<span class="op">.</span>val<span class="op">.</span>str_<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>                        <span class="cf">if</span> <span class="op">!</span>ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>                            <span class="kw">let</span> len <span class="op">=</span> <span class="op">*</span>ptr <span class="kw">as</span> <span class="dt">usize</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>                            <span class="kw">let</span> _ <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>from_raw_parts(ptr<span class="op">,</span> len<span class="op">,</span> len)<span class="op">;</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>                        <span class="op">}</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>                    <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>                <span class="op">}</span></span>
<span id="cb9-30"><a href="#cb9-30"></a>                <span class="co">// Free the array of XLOPER12s itself</span></span>
<span id="cb9-31"><a href="#cb9-31"></a>                <span class="kw">let</span> _ <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>from_raw_parts(arr<span class="op">.</span>lparray<span class="op">,</span> total<span class="op">,</span> total)<span class="op">;</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>            <span class="op">}</span></span>
<span id="cb9-33"><a href="#cb9-33"></a>            _ <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>        <span class="op">}</span></span>
<span id="cb9-35"><a href="#cb9-35"></a>        <span class="co">// Free the XLOPER12 struct (was Box::into_raw)</span></span>
<span id="cb9-36"><a href="#cb9-36"></a>        <span class="kw">let</span> _ <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>from_raw(p)<span class="op">;</span></span>
<span id="cb9-37"><a href="#cb9-37"></a>    <span class="op">}</span></span>
<span id="cb9-38"><a href="#cb9-38"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The function walks the structure from the outside in:</p>
<ol type="1">
<li><strong>Mask off the memory flags</strong> (<code>&amp; 0x0FFF</code>) to get the base type.</li>
<li><strong>For strings</strong>: reclaim the UTF-16 buffer with <code>Vec::from_raw_parts</code>. The length is the prefix value plus one (the prefix itself occupies one <code>u16</code> slot).</li>
<li><strong>For arrays</strong>: first walk every element and free any strings inside them. Then free the element array itself with <code>Vec::from_raw_parts</code>. This two-pass approach is necessary because the array contains a mix of types: string elements have their own allocations, numeric elements do not.</li>
<li><strong>For everything else</strong> (numbers, errors, nil): no inner allocations to reclaim.</li>
<li><strong>Finally</strong>: reclaim the XLOPER12 struct itself with <code>Box::from_raw</code>, undoing the <code>Box::into_raw</code> that created it.</li>
</ol>
<p>The <code>let _ =</code> pattern is intentional. <code>Vec::from_raw_parts</code> and <code>Box::from_raw</code> reconstruct the original Rust types, and assigning them to <code>_</code> lets them drop immediately, running their destructors and freeing the underlying memory. This is Rust’s standard idiom for “reclaim and deallocate in one step.”</p>
</section>
<section id="why-xlbitdllfree-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-xlbitdllfree-matters">Why <code>xlbitDLLFree</code> Matters</h3>
<p>Without the <code>xlbitDLLFree</code> flag, Excel assumes the returned XLOPER12 is stack-allocated or otherwise transient. It copies the data but never calls <code>xlAutoFree12</code>. The heap-allocated XLOPER12 and all of its inner allocations (string buffers, array element buffers) are leaked. Every call to the UDF leaks. Over a long session with recalculating formulas, memory usage grows without bound.</p>
<p>This is not a hypothetical. It was the first thing I verified in the stress tests: 500 iterations per stress test, with each test targeting a specific UDF or group of UDFs, checking heap usage at intervals. The <code>xlbitDLLFree</code> flag and the corresponding <code>xlAutoFree12</code> implementation are what keep the memory flat.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="xll_ownership_lifecycle.png" class="lightbox" data-glightbox="description: .lightbox-desc-3" data-gallery="quarto-lightbox-gallery-3" title="Figure 3: Ownership lifecycle for returned XLOPER12 values (allocate -> return -> callback -> reclaim)."><img src="xll_ownership_lifecycle.png" class="img-fluid figure-img" alt="Allocation -> return to Excel -> Excel copy -> xlAutoFree12 callback -> reclaim."></a></p>
<figcaption>Figure 3: Ownership lifecycle for returned XLOPER12 values (allocate -&gt; return -&gt; callback -&gt; reclaim).</figcaption>
</figure>
</div>
</section>
<section id="contrast-with-the-vba-approach" class="level3">
<h3 class="anchored" data-anchor-id="contrast-with-the-vba-approach">Contrast with the VBA Approach</h3>
<p>In the VBA article, I invented the handle store to manage object lifetime across the boundary. A <code>HashMap</code> behind a <code>Mutex</code>, a monotonic ID counter, explicit <code>LR_Free</code> calls. The handle store was the centerpiece design decision, and getting it right required thinking about thread safety, idempotent frees, and what happens when VBA forgets to call <code>LR_Free</code>.</p>
<p>Here, Excel provides the protocol. The DLL does not need to store anything between calls. It allocates, sets a flag, returns a pointer, and Excel calls back when it is done. No <code>HashMap</code>. No <code>Mutex</code>. No handle lifecycle. The statefulness that dominated the VBA design is gone entirely.</p>
<p>The trade-off is that the memory management is lower-level. <code>Box::into_raw</code> / <code>Box::from_raw</code> and <code>Vec::from_raw_parts</code> are unsafe operations with no compiler guardrails. But they are concentrated in two places (<code>build_multi</code>/<code>from_str</code> on the way out, <code>xlAutoFree12</code> on the way back), and the pattern is the same every time. Once it works, it works for all 27 UDFs.</p>
<hr>
</section>
</section>
<section id="Section6" class="level2">
<h2 class="anchored" data-anchor-id="Section6">6. The Excel12v Trampoline</h2>
<p>Sections 4 and 5 covered the data that crosses the XLL boundary. But there is a second boundary that matters: calling <em>back</em> into Excel. UDF registration, retrieving the DLL’s file path, freeing Excel-owned memory. All of these require the XLL to invoke Excel’s internal callback function, and that function is not available through a normal linker symbol. You have to find it at runtime.</p>
<section id="the-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-problem">The Problem</h3>
<p>When Excel loads an XLL, the XLL runs inside Excel’s process. Excel’s internal callback, <code>MdCallBack12</code>, is exported from the host executable, not from a separate DLL. The conventional approach links against an import library that provides a stub for this callback. I did not want an import library or a C compiler in the build chain, so I resolved the callback dynamically instead.</p>
</section>
<section id="the-discovery" class="level3">
<h3 class="anchored" data-anchor-id="the-discovery">The Discovery</h3>
<p>Finding <code>MdCallBack12</code> by name took trial and error. Documentation on this entry point is sparse, at least for non-C++ consumers. I spent quite some time searching before stumbling on a C++ XLL library that referenced it by name. Not a eureka moment. Just persistent searching, the kind of discovery that only happens when you are willing to dig through other people’s source code. Once I had the name, the implementation was straightforward.</p>
</section>
<section id="the-resolution" class="level3">
<h3 class="anchored" data-anchor-id="the-resolution">The Resolution</h3>
<p>Two Win32 calls, one cache, and a transmute:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span><span class="op">{</span>AtomicPtr<span class="op">,</span> Ordering<span class="op">};</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">type</span> HMODULE <span class="op">=</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">type</span> FARPROC <span class="op">=</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u8</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">extern</span> <span class="st">"system"</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">fn</span> GetModuleHandleA(lpModuleName<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">u8</span>) <span class="op">-&gt;</span> HMODULE<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="kw">fn</span> GetProcAddress(hModule<span class="op">:</span> HMODULE<span class="op">,</span> lpProcName<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">u8</span>) <span class="op">-&gt;</span> FARPROC<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="kw">type</span> Excel12Proc <span class="op">=</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span>(</span>
<span id="cb10-12"><a href="#cb10-12"></a>    xlfn<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    coper<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    rgpxloper12<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12<span class="op">,</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    xloper12Res<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12<span class="op">,</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="kw">static</span> ENTRY_PT<span class="op">:</span> AtomicPtr<span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">AtomicPtr::</span>new(<span class="pp">std::ptr::</span>null_mut())<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="kw">fn</span> fetch_entry_pt() <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Excel12Proc<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="kw">let</span> <span class="kw">mut</span> ptr <span class="op">=</span> ENTRY_PT<span class="op">.</span>load(<span class="pp">Ordering::</span>Acquire)<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="cf">if</span> ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>            <span class="kw">let</span> hmod <span class="op">=</span> GetModuleHandleA(<span class="pp">std::ptr::</span>null())<span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>            <span class="cf">if</span> hmod<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>                <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>            <span class="op">}</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>            ptr <span class="op">=</span> GetProcAddress(hmod<span class="op">,</span> <span class="st">b"MdCallBack12</span><span class="sc">\0</span><span class="st">"</span><span class="op">.</span>as_ptr())<span class="op">;</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>            <span class="cf">if</span> ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>                <span class="cf">return</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>            <span class="op">}</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>            ENTRY_PT<span class="op">.</span>store(ptr<span class="op">,</span> <span class="pp">Ordering::</span>Release)<span class="op">;</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>        <span class="op">}</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>    <span class="op">}</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>    <span class="cn">Some</span>(<span class="kw">unsafe</span> <span class="op">{</span> <span class="pp">std::mem::</span>transmute(ptr) <span class="op">}</span>)</span>
<span id="cb10-36"><a href="#cb10-36"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>GetModuleHandleA(NULL)</code> returns a handle to the host process. Because the XLL is loaded into Excel’s address space, the host process <em>is</em> Excel. <code>GetProcAddress</code> finds <code>MdCallBack12</code> by name, and the result is cached in an <code>AtomicPtr</code>. On subsequent calls, the load from the atomic is the only cost.</p>
<p>The <code>std::mem::transmute</code> converts the raw function pointer into the typed <code>Excel12Proc</code> signature. This is the one truly unsafe line in the entire mechanism: if the signature does not match what Excel exports, the call will corrupt the stack. The signature (<code>int PASCAL MdCallBack12(int xlfn, int coper, LPXLOPER12 *rgpxloper12, LPXLOPER12 xloper12Res)</code>) comes from the Excel C API documentation and has not changed since Excel 2007 introduced the XLOPER12 type.</p>
</section>
<section id="the-public-api" class="level3">
<h3 class="anchored" data-anchor-id="the-public-api">The Public API</h3>
<p>Two wrappers sit on top of the raw callback. The first is a thin <code>unsafe</code> wrapper that mirrors the C calling convention:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> excel12v(</span>
<span id="cb11-2"><a href="#cb11-2"></a>    xlfn<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    oper_res<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12<span class="op">,</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    count<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    opers<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12<span class="op">,</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="cf">match</span> fetch_entry_pt() <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="cn">Some</span>(f) <span class="op">=&gt;</span> f(xlfn<span class="op">,</span> count<span class="op">,</span> opers<span class="op">,</span> oper_res)<span class="op">,</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="cn">None</span> <span class="op">=&gt;</span> XLRET_FAILED<span class="op">,</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="op">}</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The second is a safe convenience wrapper that handles the boilerplate of creating a result XLOPER12 and passing pointer arrays:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">pub</span> <span class="kw">fn</span> excel12(xlfn<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> args<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="op">*</span><span class="kw">mut</span> XLOPER12]) <span class="op">-&gt;</span> (<span class="dt">i32</span><span class="op">,</span> XLOPER12) <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">let</span> <span class="kw">mut</span> result <span class="op">=</span> <span class="pp">XLOPER12::</span>nil()<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">let</span> ret <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>        excel12v(</span>
<span id="cb12-5"><a href="#cb12-5"></a>            xlfn<span class="op">,</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>            <span class="op">&amp;</span><span class="kw">mut</span> result<span class="op">,</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>            args<span class="op">.</span>len() <span class="kw">as</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>            args<span class="op">.</span>as_ptr()<span class="op">,</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>        )</span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="op">};</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>    (ret<span class="op">,</span> result)</span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Nearly everything in the XLL that talks to Excel goes through <code>excel12</code>. UDF registration passes <code>xlfRegister</code> as the function number. Retrieving the DLL path passes <code>xlGetName</code>. The one exception is <code>excel_free</code>, which calls <code>excel12v</code> directly because its calling convention differs (one argument, no result to inspect). The mechanism is the same in every case: identify the Excel function number, build an array of XLOPER12 pointers, call through the cached trampoline.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="xll_trampoline.png" class="lightbox" data-glightbox="description: .lightbox-desc-4" data-gallery="quarto-lightbox-gallery-4" title="Figure 4: Excel12v trampoline: runtime lookup and cached callback."><img src="xll_trampoline.png" class="img-fluid figure-img" alt="Runtime lookup of MdCallBack12 (GetModuleHandleA + GetProcAddress), caching, then excel12 calls to Excel APIs."></a></p>
<figcaption>Figure 4: Excel12v trampoline: runtime lookup and cached callback.</figcaption>
</figure>
</div>
</section>
<section id="what-this-replaces" class="level3">
<h3 class="anchored" data-anchor-id="what-this-replaces">What This Replaces</h3>
<p>In a conventional XLL, the callback mechanism comes from a compiled C source file and an import library. You compile the C file into an object file, link it alongside your code, and trust that the versions match. That approach works, but it adds a C compiler to the build chain and an external dependency that has to be maintained.</p>
<p>Here, the entire mechanism is about 100 lines of Rust in a single file. No import library, no C source, no object files. The dependency on Excel is resolved at runtime inside Excel’s own process, which is the only place the XLL will ever run.</p>
<hr>
</section>
</section>
<section id="Section7" class="level2">
<h2 class="anchored" data-anchor-id="Section7">7. UDF Registration</h2>
<p>The trampoline from Section 6 gives the XLL the ability to call back into Excel. The first thing it does with that ability is register UDFs. In <code>xlAutoOpen</code>, the XLL tells Excel: here are my functions, here is what they are called, here is what arguments they take, and here is the help text for each one.</p>
<section id="how-registration-works" class="level3">
<h3 class="anchored" data-anchor-id="how-registration-works">How Registration Works</h3>
<p>Each UDF is registered by calling <code>xlfRegister</code> through the <code>excel12</code> trampoline. The call takes 10 base XLOPER12 arguments, plus one additional XLOPER12 for each argument that needs help text in the Function Wizard. Every one of these arguments is a string or integer packed into an XLOPER12.</p>
<p>The 10 base arguments, in order:</p>
<ol type="1">
<li><strong>DLL path</strong> - the full path to the XLL file on disk, retrieved from Excel via <code>xlGetName</code></li>
<li><strong>Export name</strong> - the symbol name of the exported function (e.g., <code>"xl_linreg_ols"</code>)</li>
<li><strong>Type string</strong> - a terse encoding of the return type, argument types, and modifiers</li>
<li><strong>Excel name</strong> - the name the user types in a cell (e.g., <code>"LINREG.OLS"</code>)</li>
<li><strong>Argument names</strong> - comma-separated names shown in the Function Wizard (e.g., <code>"y_range, x_range"</code>)</li>
<li><strong>Macro type</strong> - <code>1</code> for a worksheet function, <code>2</code> for a command</li>
<li><strong>Category</strong> - the group in the Function Wizard (all 27 UDFs use <code>"LinReg"</code>)</li>
<li><strong>Shortcut key</strong> - unused (passed as <code>xltypeMissing</code>)</li>
<li><strong>Help topic</strong> - unused (passed as <code>xltypeMissing</code>)</li>
<li><strong>Description</strong> - the one-line summary shown in the Function Wizard</li>
</ol>
<p>Arguments 11 and beyond are per-argument help strings. When the user clicks on a function in the Function Wizard, each argument gets its own help text. These are the strings that explain what <code>y_range</code> means, what valid values for <code>lambda</code> are, what the default for <code>standardize</code> is.</p>
</section>
<section id="the-type-string" class="level3">
<h3 class="anchored" data-anchor-id="the-type-string">The Type String</h3>
<p>The type string is one of the less intuitive parts of XLL registration. It is a compact encoding where each character represents a type or a modifier:</p>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>Character</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Q</code></td>
<td>XLOPER12 passed by reference (the workhorse type)</td>
</tr>
<tr class="even">
<td><code>B</code></td>
<td><code>f64</code> (IEEE double)</td>
</tr>
<tr class="odd">
<td><code>J</code></td>
<td><code>i32</code> (signed 32-bit integer)</td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td>Thread-safe (Excel may call from any recalculation thread)</td>
</tr>
<tr class="odd">
<td><code>!</code></td>
<td>Volatile (recalculated on every sheet change)</td>
</tr>
</tbody>
</table>
<p>The first character is the return type. The remaining characters (before the modifiers) are the argument types. So <code>"QQQ$"</code> means: returns an XLOPER12, takes two XLOPER12 arguments, and is thread-safe.</p>
<p>Every UDF in this XLL uses <code>Q</code> for both arguments and return values, because XLOPER12 is the universal type that handles numbers, strings, ranges, errors, and missing values. The type string grows by one <code>Q</code> per argument: <code>"Q$"</code> for zero-argument functions, <code>"QQQ$"</code> for two arguments, <code>"QQQQQ$"</code> for four arguments.</p>
</section>
<section id="the-reg-helper" class="level3">
<h3 class="anchored" data-anchor-id="the-reg-helper">The <code>Reg</code> Helper</h3>
<p>Building 10+ XLOPER12 values by hand for every UDF would be verbose and error-prone. The <code>Reg</code> struct wraps this into a single <code>add()</code> call:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Reg <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    dll_name<span class="op">:</span> XLOPER12<span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="kw">impl</span> Reg <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        <span class="kw">let</span> (_<span class="op">,</span> dll_name) <span class="op">=</span> excel12(XL_GET_NAME<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> [])<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>        Reg <span class="op">{</span> dll_name <span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">pub</span> <span class="kw">fn</span> add(</span>
<span id="cb13-12"><a href="#cb13-12"></a>        <span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>        fn_name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>        type_str<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>        excel_name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>        arg_names<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-17"><a href="#cb13-17"></a>        category<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>        description<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb13-19"><a href="#cb13-19"></a>        arg_help<span class="op">:</span> <span class="op">&amp;</span>[<span class="op">&amp;</span><span class="dt">str</span>]<span class="op">,</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>    ) <span class="op">{</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>        <span class="co">// ... builds XLOPER12 array, calls xlfRegister, frees temp strings</span></span>
<span id="cb13-22"><a href="#cb13-22"></a>    <span class="op">}</span></span>
<span id="cb13-23"><a href="#cb13-23"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Reg::new()</code> calls <code>xlGetName</code> to retrieve the DLL path from Excel and caches it. Each call to <code>add()</code> converts the Rust string arguments into XLOPER12 string values, assembles the pointer array, calls <code>xlfRegister</code>, and then frees the temporary XLOPER12 strings it allocated. The cached DLL path is reused across all 27 registrations without being freed until the <code>Reg</code> is dropped.</p>
</section>
<section id="a-concrete-registration" class="level3">
<h3 class="anchored" data-anchor-id="a-concrete-registration">A Concrete Registration</h3>
<p>Here is how the OLS regression UDF is registered:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1"></a>reg<span class="op">.</span>add(</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="st">"xl_linreg_ols"</span><span class="op">,</span>           <span class="co">// exported symbol name</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="st">"QQQ$"</span><span class="op">,</span>                    <span class="co">// returns XLOPER12, takes 2 XLOPER12 args, thread-safe</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="st">"LINREG.OLS"</span><span class="op">,</span>              <span class="co">// name in Excel</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="st">"y_range, x_range"</span><span class="op">,</span>        <span class="co">// argument names for Function Wizard</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="st">"LinReg"</span><span class="op">,</span>                  <span class="co">// category</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="st">"OLS regression — returns coefficient table and fit statistics"</span><span class="op">,</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="op">&amp;</span>[</span>
<span id="cb14-9"><a href="#cb14-9"></a>        <span class="st">"Response variable (single column)"</span><span class="op">,</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>        <span class="st">"Predictor variables (one or more columns)"</span><span class="op">,</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    ]<span class="op">,</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When a user clicks the <code>fx</code> button in Excel and navigates to the LinReg category, they see <code>LINREG.OLS</code> with the description “OLS regression…” and per-argument help text explaining what <code>y_range</code> and <code>x_range</code> expect. This is the same level of integration that built-in Excel functions have.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Function_Wizard.png" class="lightbox" data-glightbox="description: .lightbox-desc-5" data-gallery="quarto-lightbox-gallery-5" title="Figure 5: Function Wizard integration with per‑argument help."><img src="Function_Wizard.png" class="img-fluid figure-img" alt="Figure 5: Function Wizard integration with per‑argument help."></a></p>
<figcaption>Figure 5: Function Wizard integration with per‑argument help.</figcaption>
</figure>
</div>
</section>
<section id="thread-safety-for-free" class="level3">
<h3 class="anchored" data-anchor-id="thread-safety-for-free">Thread Safety for Free</h3>
<p>Every UDF in this XLL is registered with the <code>$</code> modifier, which tells Excel the function is thread-safe. During a recalculation, Excel may call the same UDF from multiple threads simultaneously.</p>
<p>This works because XLL UDFs are stateless. There is no handle store, no shared computation state, no data that persists between calls. Each invocation copies the input data into Rust-owned Vecs, runs the computation, builds a fresh XLOPER12 result, and returns it.</p>
<p>Contrast this with the VBA approach, where the <code>Mutex</code>-protected <code>HashMap</code> was necessary precisely because state persisted across calls. A user could call <code>LR_OLS</code>, hold the handle, and call <code>LR_GetCoefficients</code> later from a different context. That statefulness required synchronization. Here, there is nothing to synchronize.</p>
</section>
<section id="contrast-with-the-vba-approach-1" class="level3">
<h3 class="anchored" data-anchor-id="contrast-with-the-vba-approach-1">Contrast with the VBA Approach</h3>
<p>In the VBA article, making a function available to VBA required writing a <code>Declare PtrSafe Function</code> statement by hand. The user had to match the argument types, calling convention, and DLL name exactly. Get any of it wrong and the call either crashes or silently produces garbage.</p>
<p>Here, the DLL tells Excel about itself. The registration happens in Rust code that compiles and runs inside the XLL. The argument names, types, descriptions, and help text are all defined once, in the same file as the implementation. There is no separate declaration file to keep in sync.</p>
<p>The trade-off is a different kind of fragility. If the type string does not match the actual exported function signature, the call will crash or produce garbled arguments at runtime. There is no compile-time check. Getting <code>"QQQ$"</code> right for a two-argument function is simple enough. Getting <code>"QQQQQQQ$"</code> right for a six-argument function requires counting carefully. This is one of the motivations for a future <code>xllgen</code> proc-macro that would generate type strings from Rust function signatures automatically.</p>
<hr>
</section>
</section>
<section id="Section8" class="level2">
<h2 class="anchored" data-anchor-id="Section8">8. Converting Between Worlds</h2>
<p>Sections 4 through 7 covered the infrastructure: the XLOPER12 type, memory ownership, the trampoline, and registration. This section is where that infrastructure meets the actual data. Every UDF needs to convert Excel ranges into Rust types on the way in and Rust results into XLOPER12 arrays on the way out.</p>
<section id="input-range-to-vec" class="level3">
<h3 class="anchored" data-anchor-id="input-range-to-vec">Input: Range to Vec</h3>
<p>When a user types <code>=LINREG.OLS(A1:A20, B1:E20)</code>, Excel passes two XLOPER12 pointers to the UDF. The first is the y column, the second is the X matrix. Both arrive as <code>xltypeMulti</code> arrays in row-major order. The conversion functions turn them into the column-major <code>Vec&lt;f64&gt;</code> and <code>Vec&lt;Vec&lt;f64&gt;&gt;</code> types that the core regression functions expect.</p>
<p>Here is <code>xloper_to_f64_vec</code>, which handles the y variable:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">pub</span> <span class="kw">fn</span> xloper_to_f64_vec(p<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;,</span> <span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="cf">if</span> p<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>        <span class="cf">return</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="kw">let</span> oper <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span>p <span class="op">};</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="cf">match</span> oper<span class="op">.</span>base_type() <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>        XLTYPE_NUM <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="pp">vec!</span>[<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>num <span class="op">}</span>])<span class="op">,</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>        XLTYPE_INT <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="pp">vec!</span>[<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>w <span class="op">}</span> <span class="kw">as</span> <span class="dt">f64</span>])<span class="op">,</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>        XLTYPE_MISSING <span class="op">|</span> XLTYPE_NIL <span class="op">=&gt;</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>        XLTYPE_ERR <span class="op">=&gt;</span> <span class="cn">Err</span>(<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>err <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>        XLTYPE_MULTI <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>            <span class="kw">let</span> arr <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span><span class="pp">std::ptr::addr_of!</span>(oper<span class="op">.</span>val<span class="op">.</span>array) <span class="op">};</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>            <span class="kw">let</span> total <span class="op">=</span> (arr<span class="op">.</span>rows <span class="op">*</span> arr<span class="op">.</span>columns) <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>            <span class="kw">let</span> <span class="kw">mut</span> result <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(total)<span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>total <span class="op">{</span></span>
<span id="cb15-16"><a href="#cb15-16"></a>                <span class="kw">let</span> elem <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span>arr<span class="op">.</span>lparray<span class="op">.</span>add(i) <span class="op">};</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>                <span class="cf">match</span> elem<span class="op">.</span>base_type() <span class="op">{</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>                    XLTYPE_NUM <span class="op">=&gt;</span> result<span class="op">.</span>push(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>num <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>                    XLTYPE_INT <span class="op">=&gt;</span> result<span class="op">.</span>push(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>w <span class="op">}</span> <span class="kw">as</span> <span class="dt">f64</span>)<span class="op">,</span></span>
<span id="cb15-20"><a href="#cb15-20"></a>                    XLTYPE_NIL <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb15-21"><a href="#cb15-21"></a>                    XLTYPE_ERR <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>err <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb15-22"><a href="#cb15-22"></a>                    _ <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>                <span class="op">}</span></span>
<span id="cb15-24"><a href="#cb15-24"></a>            <span class="op">}</span></span>
<span id="cb15-25"><a href="#cb15-25"></a>            <span class="cn">Ok</span>(result)</span>
<span id="cb15-26"><a href="#cb15-26"></a>        <span class="op">}</span></span>
<span id="cb15-27"><a href="#cb15-27"></a>        _ <span class="op">=&gt;</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb15-28"><a href="#cb15-28"></a>    <span class="op">}</span></span>
<span id="cb15-29"><a href="#cb15-29"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Two things to notice. First, the function handles both <code>xltypeNum</code> (a single cell) and <code>xltypeMulti</code> (a range). A single cell arrives as a bare numeric XLOPER12, not as a 1x1 array. This tripped me up early on. Every conversion function needs both paths, or a formula that references a single cell will return <code>#VALUE!</code>.</p>
<p>Second, empty cells (<code>xltypeNil</code>) and error cells (<code>xltypeErr</code>) are rejected immediately. An empty cell in the middle of a data range is not a zero; it is invalid input. An error cell (maybe the user has a <code>#DIV/0!</code> somewhere in the range) is propagated: the UDF returns the same error code the cell already displays.</p>
</section>
<section id="input-row-major-to-column-major" class="level3">
<h3 class="anchored" data-anchor-id="input-row-major-to-column-major">Input: Row-Major to Column-Major</h3>
<p>The X matrix needs a different conversion. Excel stores its <code>xltypeMulti</code> arrays in row-major order, but the core regression functions expect column-major <code>Vec&lt;Vec&lt;f64&gt;&gt;</code> where each inner Vec is one predictor variable. <code>xloper_to_columns</code> does the transpose:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">pub</span> <span class="kw">fn</span> xloper_to_columns(p<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>(<span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;&gt;,</span> <span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)<span class="op">,</span> <span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="co">// ... null check, single-value path ...</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    XLTYPE_MULTI <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>        <span class="kw">let</span> arr <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span><span class="pp">std::ptr::addr_of!</span>(oper<span class="op">.</span>val<span class="op">.</span>array) <span class="op">};</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>        <span class="kw">let</span> n_rows <span class="op">=</span> arr<span class="op">.</span>rows <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>        <span class="kw">let</span> n_cols <span class="op">=</span> arr<span class="op">.</span>columns <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>        <span class="kw">let</span> <span class="kw">mut</span> columns <span class="op">=</span> <span class="pp">vec!</span>[<span class="dt">Vec</span><span class="pp">::</span>with_capacity(n_rows)<span class="op">;</span> n_cols]<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>        <span class="cf">for</span> row <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>n_rows <span class="op">{</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>            <span class="cf">for</span> col <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>n_cols <span class="op">{</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>                <span class="kw">let</span> idx <span class="op">=</span> row <span class="op">*</span> n_cols <span class="op">+</span> col<span class="op">;</span> <span class="co">// row-major in XLOPER12</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>                <span class="kw">let</span> elem <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span>arr<span class="op">.</span>lparray<span class="op">.</span>add(idx) <span class="op">};</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>                <span class="cf">match</span> elem<span class="op">.</span>base_type() <span class="op">{</span></span>
<span id="cb16-14"><a href="#cb16-14"></a>                    XLTYPE_NUM <span class="op">=&gt;</span> columns[col]<span class="op">.</span>push(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>num <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>                    XLTYPE_INT <span class="op">=&gt;</span> columns[col]<span class="op">.</span>push(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>w <span class="op">}</span> <span class="kw">as</span> <span class="dt">f64</span>)<span class="op">,</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>                    XLTYPE_NIL <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>                    XLTYPE_ERR <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(<span class="kw">unsafe</span> <span class="op">{</span> elem<span class="op">.</span>val<span class="op">.</span>err <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb16-18"><a href="#cb16-18"></a>                    _ <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb16-19"><a href="#cb16-19"></a>                <span class="op">}</span></span>
<span id="cb16-20"><a href="#cb16-20"></a>            <span class="op">}</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>        <span class="op">}</span></span>
<span id="cb16-22"><a href="#cb16-22"></a>        <span class="cn">Ok</span>((columns<span class="op">,</span> n_rows<span class="op">,</span> n_cols))</span>
<span id="cb16-23"><a href="#cb16-23"></a>    <span class="op">}</span></span>
<span id="cb16-24"><a href="#cb16-24"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The key line is <code>let idx = row * n_cols + col</code>. Excel’s row-major index maps to column-major storage by pushing each element into <code>columns[col]</code>. The result is <code>n_cols</code> vectors, each of length <code>n_rows</code>, which is exactly what <code>ols_regression</code> and the other core functions expect.</p>
</section>
<section id="optional-parameters" class="level3">
<h3 class="anchored" data-anchor-id="optional-parameters">Optional Parameters</h3>
<p>Some UDFs have optional parameters. Ridge regression has an optional <code>standardize</code> flag. Prediction intervals have an optional <code>alpha</code> significance level. Cross-validation has an optional <code>n_folds</code> count.</p>
<p>When a user omits an optional argument, Excel passes an XLOPER12 with <code>xltypeMissing</code>. Three helper functions handle the common cases:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">fn</span> parse_optional_f64(p<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12<span class="op">,</span> <span class="kw">default</span><span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">,</span> <span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="cf">if</span> p<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>        <span class="cf">return</span> <span class="cn">Ok</span>(<span class="kw">default</span>)<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">let</span> oper <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span>p <span class="op">};</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="cf">match</span> oper<span class="op">.</span>base_type() <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>        XLTYPE_MISSING <span class="op">|</span> XLTYPE_NIL <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="kw">default</span>)<span class="op">,</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        XLTYPE_NUM <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>num <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>        XLTYPE_INT <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>w <span class="op">}</span> <span class="kw">as</span> <span class="dt">f64</span>)<span class="op">,</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>        XLTYPE_ERR <span class="op">=&gt;</span> <span class="cn">Err</span>(<span class="kw">unsafe</span> <span class="op">{</span> oper<span class="op">.</span>val<span class="op">.</span>err <span class="op">}</span>)<span class="op">,</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        _ <span class="op">=&gt;</span> <span class="cn">Err</span>(XLERR_VALUE)<span class="op">,</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>parse_optional_f64</code> and <code>parse_optional_bool</code> both follow the same pattern: if the argument is missing or nil, return the default; otherwise extract the value. Integer parameters like <code>n_folds</code> are parsed as f64 and cast. <code>parse_required_f64</code> is the strict variant that returns <code>#VALUE!</code> on missing input.</p>
</section>
<section id="output-building-a-result-grid" class="level3">
<h3 class="anchored" data-anchor-id="output-building-a-result-grid">Output: Building a Result Grid</h3>
<p>The output side is where XLOPER12 gets interesting. A regression result is not a single number. It is a table: header labels, coefficient rows with four statistics each, summary rows with a single value. The output builder assembles this as a flat <code>Vec&lt;XLOPER12&gt;</code> in row-major order, mixing string and numeric types:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">fn</span> build_ols_output(r<span class="op">:</span> <span class="op">&amp;</span>RegressionOutput) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="kw">let</span> n_coefs <span class="op">=</span> r<span class="op">.</span>coefficients<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="kw">let</span> n_summary <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="kw">let</span> n_rows <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> n_coefs <span class="op">+</span> n_summary<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="kw">let</span> n_cols <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="kw">let</span> <span class="kw">mut</span> cells<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>XLOPER12<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(n_rows <span class="op">*</span> n_cols)<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a>    <span class="co">// Header row</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"Term"</span>))<span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"Coefficient"</span>))<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"Std Error"</span>))<span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"t Stat"</span>))<span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"p-Value"</span>))<span class="op">;</span></span>
<span id="cb18-15"><a href="#cb18-15"></a></span>
<span id="cb18-16"><a href="#cb18-16"></a>    <span class="co">// Coefficient rows</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span>n_coefs <span class="op">{</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="op">&amp;</span>r<span class="op">.</span>variable_names[i]))<span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_f64(r<span class="op">.</span>coefficients[i]))<span class="op">;</span></span>
<span id="cb18-20"><a href="#cb18-20"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_f64(r<span class="op">.</span>std_errors[i]))<span class="op">;</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_f64(r<span class="op">.</span>t_stats[i]))<span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_f64(r<span class="op">.</span>p_values[i]))<span class="op">;</span></span>
<span id="cb18-23"><a href="#cb18-23"></a>    <span class="op">}</span></span>
<span id="cb18-24"><a href="#cb18-24"></a></span>
<span id="cb18-25"><a href="#cb18-25"></a>    <span class="co">// Summary rows (value in col 1, rest empty)</span></span>
<span id="cb18-26"><a href="#cb18-26"></a>    <span class="kw">let</span> summary_rows<span class="op">:</span> [(<span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> <span class="dt">f64</span>)<span class="op">;</span> <span class="dv">6</span>] <span class="op">=</span> [</span>
<span id="cb18-27"><a href="#cb18-27"></a>        (<span class="st">"R-squared"</span><span class="op">,</span> r<span class="op">.</span>r_squared)<span class="op">,</span></span>
<span id="cb18-28"><a href="#cb18-28"></a>        (<span class="st">"Adj R-squared"</span><span class="op">,</span> r<span class="op">.</span>adj_r_squared)<span class="op">,</span></span>
<span id="cb18-29"><a href="#cb18-29"></a>        (<span class="st">"F-statistic"</span><span class="op">,</span> r<span class="op">.</span>f_statistic)<span class="op">,</span></span>
<span id="cb18-30"><a href="#cb18-30"></a>        (<span class="st">"F p-value"</span><span class="op">,</span> r<span class="op">.</span>f_p_value)<span class="op">,</span></span>
<span id="cb18-31"><a href="#cb18-31"></a>        (<span class="st">"MSE"</span><span class="op">,</span> r<span class="op">.</span>mse)<span class="op">,</span></span>
<span id="cb18-32"><a href="#cb18-32"></a>        (<span class="st">"RMSE"</span><span class="op">,</span> r<span class="op">.</span>rmse)<span class="op">,</span></span>
<span id="cb18-33"><a href="#cb18-33"></a>    ]<span class="op">;</span></span>
<span id="cb18-34"><a href="#cb18-34"></a></span>
<span id="cb18-35"><a href="#cb18-35"></a>    <span class="cf">for</span> (label<span class="op">,</span> value) <span class="kw">in</span> <span class="op">&amp;</span>summary_rows <span class="op">{</span></span>
<span id="cb18-36"><a href="#cb18-36"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(label))<span class="op">;</span></span>
<span id="cb18-37"><a href="#cb18-37"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_f64(<span class="op">*</span>value))<span class="op">;</span></span>
<span id="cb18-38"><a href="#cb18-38"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">""</span>))<span class="op">;</span></span>
<span id="cb18-39"><a href="#cb18-39"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">""</span>))<span class="op">;</span></span>
<span id="cb18-40"><a href="#cb18-40"></a>        cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">""</span>))<span class="op">;</span></span>
<span id="cb18-41"><a href="#cb18-41"></a>    <span class="op">}</span></span>
<span id="cb18-42"><a href="#cb18-42"></a></span>
<span id="cb18-43"><a href="#cb18-43"></a>    build_multi(cells<span class="op">,</span> n_rows<span class="op">,</span> n_cols)</span>
<span id="cb18-44"><a href="#cb18-44"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each row is a mix of types. The header row is all strings. Coefficient rows start with a string label, then four f64 values. Summary rows have a label and a value, then three empty cells to fill out the grid.</p>
</section>
<section id="the-nil-gotcha" class="level3">
<h3 class="anchored" data-anchor-id="the-nil-gotcha">The <code>nil()</code> Gotcha</h3>
<p>Those empty cells in the summary rows use <code>XLOPER12::from_str("")</code>, not <code>XLOPER12::nil()</code>. I discovered early on that <code>nil()</code> renders as <code>0</code> in Excel, not as a blank cell. A summary row like <code>R-squared | 0.9234 | 0 | 0 | 0</code> looks wrong. Using <code>from_str("")</code> gives you a visually empty cell that displays as blank.</p>
<p>This is a minor point, but it took me time to track down. The <code>nil</code> type means “no value” inside the XLOPER12 type system, but Excel renders it as a numeric zero when it appears in a spilled array. Empty strings are the correct way to represent blank cells in output arrays.</p>
</section>
<section id="the-full-pattern" class="level3">
<h3 class="anchored" data-anchor-id="the-full-pattern">The Full Pattern</h3>
<p>Putting it all together, the simplest complete UDF is <code>xl_linreg_version</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span> xl_linreg_version() <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XLOPER12::</span>from_str(<span class="pp">env!</span>(<span class="st">"CARGO_PKG_VERSION"</span>))<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">Box</span><span class="pp">::</span>into_raw(<span class="dt">Box</span><span class="pp">::</span>new(result))</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One line of construction, one line of ownership transfer. The string version of the <code>from_str</code> / <code>Box::into_raw</code> / <code>xlAutoFree12</code> cycle from Section 5.</p>
<p>The more representative pattern is <code>xl_linreg_ols</code>, which shows all five steps:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span> xl_linreg_ols(</span>
<span id="cb20-2"><a href="#cb20-2"></a>    y_range<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12<span class="op">,</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    x_range<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12<span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="co">// 1. Parse y vector</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="cf">match</span> xloper_to_f64_vec(y_range) <span class="op">{</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>        <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> v<span class="op">,</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>        <span class="cn">Err</span>(code) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(code)<span class="op">,</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="op">};</span></span>
<span id="cb20-10"><a href="#cb20-10"></a></span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="co">// 2. Parse X matrix into column-major vectors</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="kw">let</span> (x_vars<span class="op">,</span> _n_rows<span class="op">,</span> n_cols) <span class="op">=</span> <span class="cf">match</span> xloper_to_columns(x_range) <span class="op">{</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>        <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> v<span class="op">,</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>        <span class="cn">Err</span>(code) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(code)<span class="op">,</span></span>
<span id="cb20-15"><a href="#cb20-15"></a>    <span class="op">};</span></span>
<span id="cb20-16"><a href="#cb20-16"></a></span>
<span id="cb20-17"><a href="#cb20-17"></a>    <span class="co">// 3. Build variable names: Intercept, X1, X2, ...</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    <span class="kw">let</span> <span class="kw">mut</span> names <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">"Intercept"</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb20-19"><a href="#cb20-19"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span>n_cols <span class="op">{</span></span>
<span id="cb20-20"><a href="#cb20-20"></a>        names<span class="op">.</span>push(<span class="pp">format!</span>(<span class="st">"X{}"</span><span class="op">,</span> i))<span class="op">;</span></span>
<span id="cb20-21"><a href="#cb20-21"></a>    <span class="op">}</span></span>
<span id="cb20-22"><a href="#cb20-22"></a></span>
<span id="cb20-23"><a href="#cb20-23"></a>    <span class="co">// 4. Run OLS</span></span>
<span id="cb20-24"><a href="#cb20-24"></a>    <span class="kw">let</span> result <span class="op">=</span> <span class="cf">match</span> ols_regression(<span class="op">&amp;</span>y<span class="op">,</span> <span class="op">&amp;</span>x_vars<span class="op">,</span> <span class="op">&amp;</span>names) <span class="op">{</span></span>
<span id="cb20-25"><a href="#cb20-25"></a>        <span class="cn">Ok</span>(r) <span class="op">=&gt;</span> r<span class="op">,</span></span>
<span id="cb20-26"><a href="#cb20-26"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(linreg_err_to_xl(<span class="op">&amp;</span>e))<span class="op">,</span></span>
<span id="cb20-27"><a href="#cb20-27"></a>    <span class="op">};</span></span>
<span id="cb20-28"><a href="#cb20-28"></a></span>
<span id="cb20-29"><a href="#cb20-29"></a>    <span class="co">// 5. Build output array</span></span>
<span id="cb20-30"><a href="#cb20-30"></a>    build_ols_output(<span class="op">&amp;</span>result)</span>
<span id="cb20-31"><a href="#cb20-31"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Parse inputs. Call core. Build output. Handle errors at each step with early returns. Every UDF in the XLL follows this same five-step structure. The only things that change are the specific inputs, the core function called, and the output builder used.</p>
<hr>
</section>
</section>
<section id="Section9" class="level2">
<h2 class="anchored" data-anchor-id="Section9">9. Error Handling</h2>
<p>The previous section showed the happy path: data comes in, results go out. But what happens when the data is bad? A singular matrix, a dimension mismatch, too few observations for the number of predictors. In the core Rust library, these are typed <code>Error</code> variants. The question is how they surface to the user in Excel.</p>
<section id="the-key-insight" class="level3">
<h3 class="anchored" data-anchor-id="the-key-insight">The Key Insight</h3>
<p>Rust errors cross the XLL boundary and become native Excel error cells. A user who types <code>=LINREG.OLS(A1:A5, B1:B5)</code> with perfectly collinear predictors sees <code>#NUM!</code> in the cell. Not a pop-up. Not a string to parse. Not a VBA error handler. Just the same error cell they would see from any built-in Excel function.</p>
<p>This is the <code>linreg_err_to_xl()</code> mapping:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">fn</span> linreg_err_to_xl(e<span class="op">:</span> <span class="op">&amp;</span><span class="kw">crate</span><span class="pp">::</span><span class="bu">Error</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::</span><span class="bu">Error</span><span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="cf">match</span> e <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>        <span class="bu">Error</span><span class="pp">::</span>SingularMatrix <span class="op">=&gt;</span> XLERR_NUM<span class="op">,</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>        <span class="bu">Error</span><span class="pp">::</span>InsufficientData <span class="op">{</span> <span class="op">..</span> <span class="op">}</span> <span class="op">=&gt;</span> XLERR_NUM<span class="op">,</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>        <span class="bu">Error</span><span class="pp">::</span>InvalidInput(_) <span class="op">=&gt;</span> XLERR_VALUE<span class="op">,</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>        <span class="bu">Error</span><span class="pp">::</span>DimensionMismatch <span class="op">{</span> <span class="op">..</span> <span class="op">}</span> <span class="op">=&gt;</span> XLERR_VALUE<span class="op">,</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="bu">Error</span><span class="pp">::</span>ComputationFailed(_) <span class="op">=&gt;</span> XLERR_NUM<span class="op">,</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>        _ <span class="op">=&gt;</span> XLERR_NA<span class="op">,</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="op">}</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Five match arms that bridge two type systems. Each Rust error variant maps to the Excel error code that best fits its meaning:</p>
<table class="table">
<colgroup>
<col style="width: 29%">
<col style="width: 31%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Rust Error</th>
<th>Excel Error</th>
<th>Trigger Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SingularMatrix</code></td>
<td><code>#NUM!</code></td>
<td>Perfectly collinear predictors where X’X cannot be inverted</td>
</tr>
<tr class="even">
<td><code>InsufficientData</code></td>
<td><code>#NUM!</code></td>
<td>2 observations with 5 predictors (n &lt; p)</td>
</tr>
<tr class="odd">
<td><code>InvalidInput</code></td>
<td><code>#VALUE!</code></td>
<td>A text cell mixed into a numeric range</td>
</tr>
<tr class="even">
<td><code>DimensionMismatch</code></td>
<td><code>#VALUE!</code></td>
<td>y has 10 rows but X has 8 rows</td>
</tr>
<tr class="odd">
<td><code>ComputationFailed</code></td>
<td><code>#NUM!</code></td>
<td>Coordinate descent fails to converge within max iterations</td>
</tr>
<tr class="even">
<td>Everything else</td>
<td><code>#N/A</code></td>
<td>Defensive fallback for unexpected failure modes</td>
</tr>
</tbody>
</table>
<p>The choice of <code>#NUM!</code> vs <code>#VALUE!</code> is deliberate. <code>#NUM!</code> means “the math cannot be done with these numbers.” <code>#VALUE!</code> means “the inputs are the wrong type or shape.” <code>#N/A</code> is the catch-all for anything that does not fit neatly into those categories.</p>
</section>
<section id="the-early-return-pattern" class="level3">
<h3 class="anchored" data-anchor-id="the-early-return-pattern">The Early-Return Pattern</h3>
<p>Errors can occur at two levels in a UDF. Input parsing errors (null pointer, empty cell, error cell in the range) are caught by the conversion functions and returned as Excel error codes directly. Computation errors (singular matrix, convergence failure) are caught after the core function runs and mapped through <code>linreg_err_to_xl()</code>.</p>
<p>Both use the same early-return pattern:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">// Input error — already an Excel error code</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">let</span> y <span class="op">=</span> <span class="cf">match</span> xloper_to_f64_vec(y_range) <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> v<span class="op">,</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="cn">Err</span>(code) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(code)<span class="op">,</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="op">};</span></span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="co">// Computation error — map from Rust error to Excel error code</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="kw">let</span> result <span class="op">=</span> <span class="cf">match</span> ols_regression(<span class="op">&amp;</span>y<span class="op">,</span> <span class="op">&amp;</span>x_vars<span class="op">,</span> <span class="op">&amp;</span>names) <span class="op">{</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>    <span class="cn">Ok</span>(r) <span class="op">=&gt;</span> r<span class="op">,</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(linreg_err_to_xl(<span class="op">&amp;</span>e))<span class="op">,</span></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The distinction matters for propagation. If the user has a <code>#DIV/0!</code> cell somewhere in their input range, <code>xloper_to_f64_vec</code> catches it and returns that same error code. The UDF propagates the original error rather than masking it with a generic <code>#VALUE!</code>. The user sees the same error they already have in their data, which points them to the right place to fix it.</p>
</section>
<section id="contrast-with-the-vba-approach-2" class="level3">
<h3 class="anchored" data-anchor-id="contrast-with-the-vba-approach-2">Contrast with the VBA Approach</h3>
<p>In the VBA article, error handling was a multi-step protocol. The DLL function returned <code>0</code> on failure. VBA had to check the return value, then call <code>LR_GetLastError</code> to retrieve a descriptive string from a thread-local buffer. The user saw a VBA error dialog or a message box, depending on how the VBA code was written.</p>
<p>Here, there is no separate error channel. The UDF returns an error XLOPER12 in the same slot where a successful result would go. Excel displays it as an error cell. The user does not need to write any error-handling code because there is no code to write. The error is the return value.</p>
</section>
<section id="diagnostic-errors-a-different-strategy" class="level3">
<h3 class="anchored" data-anchor-id="diagnostic-errors-a-different-strategy">Diagnostic Errors: A Different Strategy</h3>
<p>The core regression UDFs (OLS, WLS, Ridge, Lasso, Elastic Net, Polynomial) return bare Excel error cells because their failure modes are simple: the data cannot be fit. A single <code>#NUM!</code> or <code>#VALUE!</code> tells the user everything they need to know.</p>
<p>Diagnostic UDFs, cross-validation UDFs, and prediction intervals take a different approach. These can fail for subtle reasons (residuals near zero, numerically singular auxiliary regression, sample size outside the test’s valid range), and a bare error cell does not give the user enough information to understand why. So they return a labeled array with the error message embedded as a string:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">fn</span> build_diagnostic_error(e<span class="op">:</span> <span class="op">&amp;</span><span class="kw">crate</span><span class="pp">::</span><span class="bu">Error</span>) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="kw">let</span> msg <span class="op">=</span> <span class="pp">format!</span>(<span class="st">"#ERR: {}"</span><span class="op">,</span> e)<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    <span class="kw">let</span> <span class="kw">mut</span> cells <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(<span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"Statistic"</span>))<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="op">&amp;</span>msg))<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">"p-Value"</span>))<span class="op">;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    cells<span class="op">.</span>push(<span class="pp">XLOPER12::</span>from_str(<span class="st">""</span>))<span class="op">;</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>    build_multi(cells<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The output preserves the standard 2-column diagnostic layout (label in column 0, value in column 1), but replaces the numeric value with a string like <code>#ERR: residuals near zero</code>. The user sees the error in context, right next to the label that tells them which statistic failed.</p>
<p>This is a deliberate design split. Core regression failures mean “your data cannot be fit.” Diagnostic, cross-validation, and prediction interval failures mean “this specific computation cannot run, and here is why.” The first case needs a clean error cell. The second case needs an explanation.</p>
<hr>
</section>
</section>
<section id="Section10" class="level2">
<h2 class="anchored" data-anchor-id="Section10">10. Testing Without Excel</h2>
<p>I tested the first working UDF in Excel for about 30 minutes. The feedback loop was: change code, rebuild the DLL, close Excel (because it locks the file), copy the new XLL into the add-in directory, reopen Excel, load the add-in, type the formula, check the result. Repeat. For every change.</p>
<p>That loop was bad enough on its own. But my bigger concern was memory. I had spent years writing VBA in engineering environments where macros ran on datasets of unpredictable size, and I had developed the habit of setting variables to <code>Nothing</code> explicitly because I did not trust the runtime to clean up. The XLL has the same exposure: every UDF allocates heap memory for its return value, and if <code>xlAutoFree12</code> does not reclaim it correctly, the leak is silent. You will not notice until Excel’s memory usage has climbed to gigabytes over a long session. I needed a way to verify memory correctness systematically, not just hope.</p>
<p>I played a 45-minute game of Elden Ring to decompress (Souls games to relax, ironically).</p>
<p>I came back with a clearer head. Before the break, I had been thinking about some convoluted approach: export results from Excel into a file, then parse that file in a Rust test harness and compare. I have to rein in my convoluted designs sometimes. The simpler thought that emerged was: Rust is a low-level language. The XLOPER12 is a <code>#[repr(C)]</code> struct. I can construct one in test code, pass it to a UDF function, and inspect the result. No Excel needed.</p>
<p>That felt cursed. Constructing fake Excel data structures in a test harness, calling functions that are designed to be called by Excel, and then manually running the cleanup function that Excel would normally call. It sounded like the kind of thing that works on your machine and breaks everywhere else.</p>
<p>It turned out to be the right architecture.</p>
<section id="the-xlresultguard" class="level3">
<h3 class="anchored" data-anchor-id="the-xlresultguard">The XlResultGuard</h3>
<p>The core of the test infrastructure is an RAII wrapper called <code>XlResultGuard</code>. It wraps the raw <code>*mut XLOPER12</code> pointer that a UDF returns and calls <code>xlAutoFree12</code> when it goes out of scope:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">pub</span> <span class="kw">struct</span> XlResultGuard <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="kw">pub</span> ptr<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12<span class="op">,</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="op">}</span></span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="kw">impl</span> XlResultGuard <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(ptr<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="pp">assert!</span>(<span class="op">!</span>ptr<span class="op">.</span>is_null()<span class="op">,</span> <span class="st">"XLL function returned null pointer"</span>)<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>        <span class="dt">Self</span> <span class="op">{</span> ptr <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="op">}</span></span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="kw">pub</span> <span class="kw">fn</span> base_type(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>        <span class="kw">unsafe</span> <span class="op">{</span> (<span class="op">*</span><span class="kw">self</span><span class="op">.</span>ptr)<span class="op">.</span>base_type() <span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>    <span class="op">}</span></span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a>    <span class="kw">pub</span> <span class="kw">fn</span> is_multi(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb24-16"><a href="#cb24-16"></a>        <span class="kw">self</span><span class="op">.</span>base_type() <span class="op">==</span> XLTYPE_MULTI</span>
<span id="cb24-17"><a href="#cb24-17"></a>    <span class="op">}</span></span>
<span id="cb24-18"><a href="#cb24-18"></a></span>
<span id="cb24-19"><a href="#cb24-19"></a>    <span class="kw">pub</span> <span class="kw">fn</span> dimensions(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb24-20"><a href="#cb24-20"></a>        <span class="pp">assert!</span>(<span class="kw">self</span><span class="op">.</span>is_multi())<span class="op">;</span></span>
<span id="cb24-21"><a href="#cb24-21"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb24-22"><a href="#cb24-22"></a>            <span class="kw">let</span> arr <span class="op">=</span> <span class="op">&amp;*</span><span class="pp">std::ptr::addr_of!</span>((<span class="op">*</span><span class="kw">self</span><span class="op">.</span>ptr)<span class="op">.</span>val<span class="op">.</span>array)<span class="op">;</span></span>
<span id="cb24-23"><a href="#cb24-23"></a>            (arr<span class="op">.</span>rows <span class="kw">as</span> <span class="dt">usize</span><span class="op">,</span> arr<span class="op">.</span>columns <span class="kw">as</span> <span class="dt">usize</span>)</span>
<span id="cb24-24"><a href="#cb24-24"></a>        <span class="op">}</span></span>
<span id="cb24-25"><a href="#cb24-25"></a>    <span class="op">}</span></span>
<span id="cb24-26"><a href="#cb24-26"></a></span>
<span id="cb24-27"><a href="#cb24-27"></a>    <span class="kw">pub</span> <span class="kw">fn</span> cell_f64(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> row<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> col<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb24-28"><a href="#cb24-28"></a>        <span class="kw">let</span> cell <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>cell(row<span class="op">,</span> col)<span class="op">;</span></span>
<span id="cb24-29"><a href="#cb24-29"></a>        cell<span class="op">.</span>as_f64()<span class="op">.</span>unwrap_or_else(<span class="op">||</span> <span class="pp">panic!</span>(</span>
<span id="cb24-30"><a href="#cb24-30"></a>            <span class="st">"Cell ({}, {}) is not numeric, type={}"</span><span class="op">,</span></span>
<span id="cb24-31"><a href="#cb24-31"></a>            row<span class="op">,</span> col<span class="op">,</span> cell<span class="op">.</span>base_type()</span>
<span id="cb24-32"><a href="#cb24-32"></a>        ))</span>
<span id="cb24-33"><a href="#cb24-33"></a>    <span class="op">}</span></span>
<span id="cb24-34"><a href="#cb24-34"></a></span>
<span id="cb24-35"><a href="#cb24-35"></a>    <span class="kw">pub</span> <span class="kw">fn</span> cell_string(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> row<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> col<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb24-36"><a href="#cb24-36"></a>        <span class="kw">let</span> cell <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>cell(row<span class="op">,</span> col)<span class="op">;</span></span>
<span id="cb24-37"><a href="#cb24-37"></a>        cell<span class="op">.</span>as_string()<span class="op">.</span>unwrap_or_else(<span class="op">||</span> <span class="pp">panic!</span>(</span>
<span id="cb24-38"><a href="#cb24-38"></a>            <span class="st">"Cell ({}, {}) is not a string, type={}"</span><span class="op">,</span></span>
<span id="cb24-39"><a href="#cb24-39"></a>            row<span class="op">,</span> col<span class="op">,</span> cell<span class="op">.</span>base_type()</span>
<span id="cb24-40"><a href="#cb24-40"></a>        ))</span>
<span id="cb24-41"><a href="#cb24-41"></a>    <span class="op">}</span></span>
<span id="cb24-42"><a href="#cb24-42"></a><span class="op">}</span></span>
<span id="cb24-43"><a href="#cb24-43"></a></span>
<span id="cb24-44"><a href="#cb24-44"></a><span class="kw">impl</span> <span class="bu">Drop</span> <span class="cf">for</span> XlResultGuard <span class="op">{</span></span>
<span id="cb24-45"><a href="#cb24-45"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb24-46"><a href="#cb24-46"></a>        <span class="cf">if</span> <span class="op">!</span><span class="kw">self</span><span class="op">.</span>ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb24-47"><a href="#cb24-47"></a>            xlAutoFree12(<span class="kw">self</span><span class="op">.</span>ptr)<span class="op">;</span></span>
<span id="cb24-48"><a href="#cb24-48"></a>        <span class="op">}</span></span>
<span id="cb24-49"><a href="#cb24-49"></a>    <span class="op">}</span></span>
<span id="cb24-50"><a href="#cb24-50"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the key design decision. Every test that calls a UDF wraps the returned pointer in an <code>XlResultGuard</code>. The guard provides typed accessors (<code>cell_f64</code>, <code>cell_string</code>, <code>dimensions</code>, <code>is_error</code>) for inspecting the result, and its <code>Drop</code> implementation ensures <code>xlAutoFree12</code> runs when the guard goes out of scope. Every test exercises the full allocate-return-free cycle. If <code>xlAutoFree12</code> has a bug (wrong length in <code>Vec::from_raw_parts</code>, missing string cleanup inside an array, double-free), the test crashes immediately in debug builds.</p>
</section>
<section id="a-representative-test" class="level3">
<h3 class="anchored" data-anchor-id="a-representative-test">A Representative Test</h3>
<p>Here is a test that verifies OLS regression correctness end-to-end, from XLOPER12 construction through core computation through output inspection:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">fn</span> test_ols_simple_linear_coefficients() <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    <span class="co">// y = 2 + 3x -&gt; intercept ~ 2.0, slope ~ 3.0</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>    <span class="kw">let</span> (y_data<span class="op">,</span> x_data) <span class="op">=</span> simple_linear_data()<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="kw">let</span> (y_range<span class="op">,</span> _y_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>y_data)<span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_matrix_range(<span class="op">&amp;</span>[x_data])<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>    <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="op">&amp;</span>y_range<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9"></a></span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="kw">let</span> intercept <span class="op">=</span> result<span class="op">.</span>cell_f64(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="kw">let</span> slope <span class="op">=</span> result<span class="op">.</span>cell_f64(<span class="dv">2</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12"></a></span>
<span id="cb25-13"><a href="#cb25-13"></a>    <span class="pp">assert!</span>((intercept <span class="op">-</span> <span class="dv">2.0</span>)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-9</span><span class="op">,</span> <span class="st">"Intercept should be ~2.0, got {}"</span><span class="op">,</span> intercept)<span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14"></a>    <span class="pp">assert!</span>((slope <span class="op">-</span> <span class="dv">3.0</span>)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dv">1e-9</span><span class="op">,</span> <span class="st">"Slope should be ~3.0, got {}"</span><span class="op">,</span> slope)<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>build_column_range</code> and <code>build_matrix_range</code> are helper functions that construct XLOPER12 <code>xltypeMulti</code> arrays from Rust vectors, simulating the data Excel would pass. They build the same <code>#[repr(C)]</code> structs that Excel builds, in the same row-major layout, with the same type tags. The UDF function cannot tell the difference between a test-constructed XLOPER12 and one that came from an actual spreadsheet.</p>
<p>The <code>_y_cells</code> and <code>_x_cells</code> bindings are not unused. They own the backing <code>Vec&lt;XLOPER12&gt;</code> that the XLOPER12 array points into. Without them, the data would be dropped at the end of the <code>let</code> statement and the XLOPER12 pointer would dangle. The underscore prefix is Rust convention for “needed for lifetime, not used directly.”</p>
</section>
<section id="error-path-coverage" class="level3">
<h3 class="anchored" data-anchor-id="error-path-coverage">Error Path Coverage</h3>
<p>The error tests verify that bad inputs produce appropriate Excel error codes rather than crashes:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">fn</span> test_ols_null_y_returns_error() <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="kw">let</span> x_data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span><span class="op">,</span> <span class="dv">5.0</span>]<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>x_data)<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="pp">std::ptr::</span>null()<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>    <span class="pp">assert!</span>(result<span class="op">.</span>is_error()<span class="op">,</span> <span class="st">"Null y should return error"</span>)<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="pp">assert_eq!</span>(result<span class="op">.</span>error_code()<span class="op">,</span> XLERR_VALUE)<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">fn</span> test_ols_error_in_y_propagates() <span class="op">{</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>    <span class="kw">let</span> y_data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span><span class="op">,</span> <span class="dv">5.0</span>]<span class="op">;</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>    <span class="kw">let</span> (y_range<span class="op">,</span> _y_cells) <span class="op">=</span> build_column_with_error(<span class="op">&amp;</span>y_data<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> XLERR_NUM)<span class="op">;</span></span>
<span id="cb26-15"><a href="#cb26-15"></a>    <span class="kw">let</span> x_data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span><span class="op">,</span> <span class="dv">5.0</span>]<span class="op">;</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>    <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>x_data)<span class="op">;</span></span>
<span id="cb26-17"><a href="#cb26-17"></a></span>
<span id="cb26-18"><a href="#cb26-18"></a>    <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="op">&amp;</span>y_range<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>    <span class="pp">assert!</span>(result<span class="op">.</span>is_error()<span class="op">,</span> <span class="st">"Error cell in y should propagate"</span>)<span class="op">;</span></span>
<span id="cb26-20"><a href="#cb26-20"></a>    <span class="pp">assert_eq!</span>(result<span class="op">.</span>error_code()<span class="op">,</span> XLERR_NUM<span class="op">,</span> <span class="st">"Should propagate #NUM! from y"</span>)<span class="op">;</span></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first test passes a null pointer as the y argument. In Excel, this cannot happen. But if the UDF has a bug in its argument handling, or if the registration type string is wrong and Excel passes unexpected data, the null path should not crash. The test confirms it returns <code>#VALUE!</code>.</p>
<p>The second test constructs a range where the third cell is a <code>#NUM!</code> error, simulating a cell in the spreadsheet that already contains an error. The UDF should propagate that error code rather than masking it.</p>
</section>
<section id="stress-tests-with-heap-tracking" class="level3">
<h3 class="anchored" data-anchor-id="stress-tests-with-heap-tracking">Stress Tests with Heap Tracking</h3>
<p>The correctness tests verify that the right values come out. The stress tests verify that memory stays flat. Each stress test runs a UDF 500 times in a loop, calling <code>xlAutoFree12</code> on every result via the <code>XlResultGuard</code>, and logs heap usage at intervals:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">const</span> STRESS_ITERATIONS<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">const</span> LOG_INTERVAL<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> STRESS_ITERATIONS <span class="op">/</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="kw">fn</span> test_ols_stress_with_mem_tracking() <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="kw">let</span> (y_data<span class="op">,</span> x_data) <span class="op">=</span> simple_linear_data()<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>    <span class="kw">let</span> baseline <span class="op">=</span> <span class="pp">MemSnapshot::</span>now()<span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8"></a></span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span>STRESS_ITERATIONS <span class="op">{</span></span>
<span id="cb27-10"><a href="#cb27-10"></a>        <span class="kw">let</span> (y_range<span class="op">,</span> _y_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>y_data)<span class="op">;</span></span>
<span id="cb27-11"><a href="#cb27-11"></a>        <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_matrix_range(<span class="op">&amp;</span>[x_data<span class="op">.</span>clone()])<span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12"></a></span>
<span id="cb27-13"><a href="#cb27-13"></a>        <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="op">&amp;</span>y_range<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>        <span class="pp">assert!</span>(result<span class="op">.</span>is_multi()<span class="op">,</span> <span class="st">"Iteration {} should succeed"</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15"></a></span>
<span id="cb27-16"><a href="#cb27-16"></a>        <span class="cf">if</span> i <span class="op">%</span> LOG_INTERVAL <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb27-17"><a href="#cb27-17"></a>            log_mem(<span class="st">"ols_simple"</span><span class="op">,</span> i<span class="op">,</span> <span class="op">&amp;</span>baseline)<span class="op">;</span></span>
<span id="cb27-18"><a href="#cb27-18"></a>        <span class="op">}</span></span>
<span id="cb27-19"><a href="#cb27-19"></a>    <span class="op">}</span></span>
<span id="cb27-20"><a href="#cb27-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>MemSnapshot</code> is a wrapper around the Win32 <code>K32GetProcessMemoryInfo</code> API. It captures the process working set and committed virtual memory (pagefile usage) at a point in time. The <code>log_mem</code> function prints a status line with the delta from the baseline:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">pub</span> <span class="kw">struct</span> MemSnapshot <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="kw">pub</span> working_set<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="kw">pub</span> pagefile<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="kw">pub</span> peak_working_set<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="op">}</span></span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="kw">impl</span> MemSnapshot <span class="op">{</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="kw">pub</span> <span class="kw">fn</span> now() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>        <span class="kw">let</span> <span class="kw">mut</span> counters <span class="op">=</span> PROCESS_MEMORY_COUNTERS <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">};</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>            K32GetProcessMemoryInfo(</span>
<span id="cb28-12"><a href="#cb28-12"></a>                GetCurrentProcess()<span class="op">,</span></span>
<span id="cb28-13"><a href="#cb28-13"></a>                <span class="op">&amp;</span><span class="kw">mut</span> counters<span class="op">,</span></span>
<span id="cb28-14"><a href="#cb28-14"></a>                counters<span class="op">.</span>cb<span class="op">,</span></span>
<span id="cb28-15"><a href="#cb28-15"></a>            )<span class="op">;</span></span>
<span id="cb28-16"><a href="#cb28-16"></a>        <span class="op">}</span></span>
<span id="cb28-17"><a href="#cb28-17"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb28-18"><a href="#cb28-18"></a>            working_set<span class="op">:</span> counters<span class="op">.</span>WorkingSetSize<span class="op">,</span></span>
<span id="cb28-19"><a href="#cb28-19"></a>            pagefile<span class="op">:</span> counters<span class="op">.</span>PagefileUsage<span class="op">,</span></span>
<span id="cb28-20"><a href="#cb28-20"></a>            peak_working_set<span class="op">:</span> counters<span class="op">.</span>PeakWorkingSetSize<span class="op">,</span></span>
<span id="cb28-21"><a href="#cb28-21"></a>        <span class="op">}</span></span>
<span id="cb28-22"><a href="#cb28-22"></a>    <span class="op">}</span></span>
<span id="cb28-23"><a href="#cb28-23"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When you run these tests with <code>--nocapture</code>, the output looks like:</p>
<pre><code>  [ols_simple] iter    0 | heap: 14200 KB, working_set: 19452 KB, peak: 19452 KB | delta: +0 KB
  [ols_simple] iter   50 | heap: 14264 KB, working_set: 19516 KB, peak: 19516 KB | delta: +64 KB
  [ols_simple] iter  100 | heap: 14264 KB, working_set: 19516 KB, peak: 19516 KB | delta: +64 KB
  [ols_simple] iter  200 | heap: 14264 KB, working_set: 19516 KB, peak: 19516 KB | delta: +64 KB
  [ols_simple] iter  500 | heap: 14264 KB, working_set: 19516 KB, peak: 19516 KB | delta: +64 KB</code></pre>
<p>The heap rises slightly in the first 50 iterations (allocator pools warming up, thread-local caches filling) and then stabilizes. That non-monotonic pattern, rise then plateau, is the signature of allocator jitter, not a leak. A genuine leak would show linear growth: +64 KB at iteration 50, +128 KB at 100, +192 KB at 200, and so on.</p>
<p>The quantitative leak detection test makes this assertion explicit:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="kw">fn</span> test_ols_memory_leak_detection() <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="kw">let</span> (y_data<span class="op">,</span> x_cols) <span class="op">=</span> mtcars_subset()<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="co">// Warmup — let allocator pools stabilize</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">50</span> <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>        <span class="kw">let</span> (y_range<span class="op">,</span> _y_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>y_data)<span class="op">;</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>        <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_matrix_range(<span class="op">&amp;</span>x_cols)<span class="op">;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>        <span class="kw">let</span> _result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="op">&amp;</span>y_range<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>    <span class="op">}</span></span>
<span id="cb30-11"><a href="#cb30-11"></a></span>
<span id="cb30-12"><a href="#cb30-12"></a>    <span class="kw">let</span> baseline <span class="op">=</span> <span class="pp">MemSnapshot::</span>now()<span class="op">;</span></span>
<span id="cb30-13"><a href="#cb30-13"></a></span>
<span id="cb30-14"><a href="#cb30-14"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span>STRESS_ITERATIONS <span class="op">{</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>        <span class="kw">let</span> (y_range<span class="op">,</span> _y_cells) <span class="op">=</span> build_column_range(<span class="op">&amp;</span>y_data)<span class="op">;</span></span>
<span id="cb30-16"><a href="#cb30-16"></a>        <span class="kw">let</span> (x_range<span class="op">,</span> _x_cells) <span class="op">=</span> build_matrix_range(<span class="op">&amp;</span>x_cols)<span class="op">;</span></span>
<span id="cb30-17"><a href="#cb30-17"></a>        <span class="kw">let</span> result <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_ols(<span class="op">&amp;</span>y_range<span class="op">,</span> <span class="op">&amp;</span>x_range))<span class="op">;</span></span>
<span id="cb30-18"><a href="#cb30-18"></a>        <span class="pp">assert!</span>(result<span class="op">.</span>is_multi())<span class="op">;</span></span>
<span id="cb30-19"><a href="#cb30-19"></a></span>
<span id="cb30-20"><a href="#cb30-20"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">XlResultGuard::</span>new(xll_version())<span class="op">;</span></span>
<span id="cb30-21"><a href="#cb30-21"></a>        <span class="pp">assert!</span>(v<span class="op">.</span>is_string())<span class="op">;</span></span>
<span id="cb30-22"><a href="#cb30-22"></a>    <span class="op">}</span></span>
<span id="cb30-23"><a href="#cb30-23"></a></span>
<span id="cb30-24"><a href="#cb30-24"></a>    <span class="kw">let</span> final_snap <span class="op">=</span> <span class="pp">MemSnapshot::</span>now()<span class="op">;</span></span>
<span id="cb30-25"><a href="#cb30-25"></a>    <span class="kw">let</span> delta_kb <span class="op">=</span> final_snap<span class="op">.</span>heap_delta_from(<span class="op">&amp;</span>baseline) <span class="op">/</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb30-26"><a href="#cb30-26"></a></span>
<span id="cb30-27"><a href="#cb30-27"></a>    <span class="pp">assert!</span>(</span>
<span id="cb30-28"><a href="#cb30-28"></a>        delta_kb <span class="op">&lt;</span> <span class="dv">1024</span><span class="op">,</span></span>
<span id="cb30-29"><a href="#cb30-29"></a>        <span class="st">"Heap grew by {} KB over {} iterations — possible memory leak."</span><span class="op">,</span></span>
<span id="cb30-30"><a href="#cb30-30"></a>        delta_kb<span class="op">,</span></span>
<span id="cb30-31"><a href="#cb30-31"></a>        STRESS_ITERATIONS</span>
<span id="cb30-32"><a href="#cb30-32"></a>    )<span class="op">;</span></span>
<span id="cb30-33"><a href="#cb30-33"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The warmup phase runs 50 iterations to let the allocator stabilize before taking the baseline snapshot. Then 500 iterations of OLS plus version calls. If the heap grew by more than 1 MB total, the test fails. Each OLS call with the mtcars dataset allocates roughly 60 XLOPER12 cells with dozens of string buffers (header labels, coefficient names, summary labels, and empty-string placeholders). If <code>xlAutoFree12</code> leaked even one string per iteration, that would show up as at least 25 KB of growth. Full leaking (no free at all) would produce around 1 MB of growth over 500 iterations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Heap_Growth.exe.png" class="lightbox" data-glightbox="description: .lightbox-desc-6" data-gallery="quarto-lightbox-gallery-6" title="Figure 7: Heap deltas stabilize under stress tests (leak‑free behavior)."><img src="Heap_Growth.exe.png" class="img-fluid figure-img" alt="Console output or small chart showing heap delta stabilizing over iterations."></a></p>
<figcaption>Figure 7: Heap deltas stabilize under stress tests (leak‑free behavior).</figcaption>
</figure>
</div>
</section>
<section id="the-full-test-suite" class="level3">
<h3 class="anchored" data-anchor-id="the-full-test-suite">The Full Test Suite</h3>
<p>The test infrastructure covers 165 tests across 9 files:</p>
<table class="table">
<colgroup>
<col style="width: 26%">
<col style="width: 26%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Tests</th>
<th>What It Covers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>version.rs</code></td>
<td>5</td>
<td>String return, version format, <code>xlbitDLLFree</code> flag</td>
</tr>
<tr class="even">
<td><code>ols.rs</code></td>
<td>16</td>
<td>Output dimensions, headers, coefficients, R-squared, summary stats, single-cell inputs, blank cells</td>
</tr>
<tr class="odd">
<td><code>wls.rs</code></td>
<td>19</td>
<td>Weighted regression output, weights validation, summary layout</td>
</tr>
<tr class="even">
<td><code>regularized.rs</code></td>
<td>32</td>
<td>Ridge, Lasso, Elastic Net: coefficients, optional params, lambda path</td>
</tr>
<tr class="odd">
<td><code>diagnostics.rs</code></td>
<td>42</td>
<td>All 14 diagnostic UDFs: output format, value ranges, error handling</td>
</tr>
<tr class="even">
<td><code>cross_validation.rs</code></td>
<td>10</td>
<td>4 CV variants: fold count, metric ranges</td>
</tr>
<tr class="odd">
<td><code>prediction_intervals.rs</code></td>
<td>8</td>
<td>Bounds, alpha parameter, output layout</td>
</tr>
<tr class="even">
<td><code>polynomial.rs</code></td>
<td>8</td>
<td>Degree parameter, coefficient count, prediction</td>
</tr>
<tr class="odd">
<td><code>errors.rs</code></td>
<td>25</td>
<td>Null pointers, missing inputs, error propagation, dimension mismatch, collinearity, <code>xlbitDLLFree</code> flag, stress tests</td>
</tr>
</tbody>
</table>
<p>Every category of test in this table exercises the same code path that Excel would call. The XLOPER12 structs are byte-identical. The UDF functions are called with the same <code>extern "system"</code> calling convention. The <code>xlAutoFree12</code> cleanup runs on every returned result. The tests do not simulate the XLL interface; they <em>use</em> it.</p>
</section>
<section id="what-this-catches" class="level3">
<h3 class="anchored" data-anchor-id="what-this-catches">What This Catches</h3>
<p>Manual testing in Excel caught obvious failures: wrong output, crashes, formula errors. The automated tests catch things that are invisible in manual testing:</p>
<p><strong>Memory leaks.</strong> A missing <code>xlbitDLLFree</code> flag or a bug in <code>xlAutoFree12</code> leaks silently. The stress tests with heap tracking make leaks visible as linear growth patterns.</p>
<p><strong>Off-by-one in array dimensions.</strong> If a UDF builds a 9-row output but declares it as 8 rows in the XLOPER12, Excel displays garbage in the last row. The tests assert exact row and column counts.</p>
<p><strong>String encoding errors.</strong> A wrong length prefix in a Pascal-style UTF-16 string either truncates the text or reads past the buffer. The tests verify string content cell by cell.</p>
<p><strong>Missing <code>xlbitDLLFree</code> flags.</strong> This was a real bug found by code inspection during this article’s writing process. Error XLOPER12s were being returned without the flag, which meant Excel never called <code>xlAutoFree12</code> on them. Every error return leaked one XLOPER12 (32 bytes on x64). The automated tests did not catch it because <code>XlResultGuard</code> calls <code>xlAutoFree12</code> unconditionally, whether or not the flag is set. In production, Excel only calls <code>xlAutoFree12</code> when it sees the flag. The fix was a one-line change to set the flag on error returns. The version UDF test (<code>test_version_has_dll_free_bit</code>) already verified the flag on string returns; a similar check now exists for error returns.</p>
<p><strong>Error propagation.</strong> An error cell in the input range should produce the same error code in the output, not a generic <code>#VALUE!</code>. The propagation tests verify this for several common error types (<code>#NUM!</code>, <code>#DIV/0!</code>, <code>#VALUE!</code>, <code>#N/A</code>).</p>
<p>The VBA article mentioned “Testing FFI Without Excel” as a lesson learned. Here it became the centerpiece of the development process. I spent 30 minutes testing in Excel and about 15 hours writing and running automated tests. The ratio speaks for itself.</p>
<hr>
</section>
</section>
<section id="Section11" class="level2">
<h2 class="anchored" data-anchor-id="Section11">11. From 2 UDFs to 27</h2>
<p>The proof of concept had two UDFs: <code>LINREG.VERSION()</code> and <code>LINREG.OLS(y, X)</code>. The version UDF working was anticlimactic. It returns a string. Not much can go wrong. The OLS UDF finally working after coercing all the types was the real payoff. That was the moment it felt real.</p>
<p>The struggle with OLS was fundamentally a documentation problem. The XLOPER12 interface is not well-documented for non-C++ consumers. I spent quite some time tracking down exactly what types to use, what the layout was, how strings were encoded. My physical notepad was filled with random observations and a checklist of what was tried. I break larger tasks into smaller ones with checkboxes, sometimes quadruple-nested checkboxes. I also track time in a personal paper planner with 15-minute increments.</p>
<p>After OLS worked, things got more structured. Less hacking, more iterating on a design. The timeline tells the story: ideation to <code>LINREG.VERSION()</code> working took roughly 20 hours. VERSION to <code>LINREG.OLS()</code> working took roughly 10 hours. OLS to all 27 UDFs took roughly 5 hours. (Not counting boilerplate, testing, or documentation. Just getting things to work and play nicely.) The first UDF was the hard part. Once the pattern was established, scaling was mechanical.</p>
<section id="the-pattern" class="level3">
<h3 class="anchored" data-anchor-id="the-pattern">The Pattern</h3>
<p>Every UDF in the XLL follows the same structure:</p>
<ol type="1">
<li>Parse input XLOPER12s into Rust types</li>
<li>Parse optional parameters with defaults</li>
<li>Call the core Rust function</li>
<li>Handle errors with early returns</li>
<li>Build an output XLOPER12 array</li>
</ol>
<p>The OLS UDF from Section 8 shows this at its simplest: 30 lines covering all five steps. The more complex UDFs (Ridge, Elastic Net, cross-validation) add parameter parsing but follow the same skeleton.</p>
</section>
<section id="how-the-expansion-happened" class="level3">
<h3 class="anchored" data-anchor-id="how-the-expansion-happened">How the Expansion Happened</h3>
<p>The 27 UDFs were not added one at a time. They went in batches, grouped by the output format they needed:</p>
<p><strong>Batch 1: Regression UDFs</strong> (WLS, Ridge, Lasso, Elastic Net). WLS has its own output builder (<code>build_wls_output</code>) because it includes an extra Residual Std Error row that OLS does not. Ridge, Lasso, and Elastic Net each have their own 2-column output builders (Term + Coefficient, followed by method-specific summary statistics). Each UDF added roughly 35-55 lines of code.</p>
<p><strong>Batch 2: Diagnostics</strong> (14 UDFs). Nine of the diagnostic UDFs share a 2x2 label+value output format (<code>build_simple_diagnostic</code>, <code>build_diagnostic_2x2</code>). The remaining five use different shapes: Breusch-Godfrey builds a 3x2 table (adds a degrees-of-freedom row), VIF builds a variable-length 2-column table (one row per predictor), Cook’s Distance and DFFITS return single-column vectors (one value per observation), and DFBETAS returns a full matrix (observations by coefficients). Despite the output variety, most diagnostic UDFs are under 10 lines each because a <code>parse_yx!</code> macro extracts the input parsing. The shortest is 5 lines:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">pub</span> <span class="kw">extern</span> <span class="st">"system"</span> <span class="kw">fn</span> xl_linreg_breuschpagan(</span>
<span id="cb31-2"><a href="#cb31-2"></a>    y_range<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12<span class="op">,</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    x_range<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> XLOPER12<span class="op">,</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>) <span class="op">-&gt;</span> <span class="op">*</span><span class="kw">mut</span> XLOPER12 <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="kw">let</span> (y<span class="op">,</span> x_vars) <span class="op">=</span> <span class="pp">parse_yx!</span>(y_range<span class="op">,</span> x_range)<span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>    <span class="cf">match</span> <span class="pp">diagnostics::</span>breusch_pagan_test(<span class="op">&amp;</span>y<span class="op">,</span> <span class="op">&amp;</span>x_vars) <span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>        <span class="cn">Ok</span>(r) <span class="op">=&gt;</span> build_simple_diagnostic(<span class="op">&amp;</span>r)<span class="op">,</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> build_diagnostic_error(<span class="op">&amp;</span>e)<span class="op">,</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="op">}</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>parse_yx!</code> macro encapsulates the two input conversions and their error handling:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource rust number-lines code-with-copy"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">macro_rules!</span> parse_yx <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>    (<span class="op">$</span>y_range<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>x_range<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>        <span class="kw">let</span> y <span class="op">=</span> <span class="cf">match</span> xloper_to_f64_vec(<span class="op">$</span>y_range) <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>            <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> v<span class="op">,</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>            <span class="cn">Err</span>(code) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(code)<span class="op">,</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>        <span class="op">};</span></span>
<span id="cb32-7"><a href="#cb32-7"></a>        <span class="kw">let</span> (x_vars<span class="op">,</span> _n_rows<span class="op">,</span> _n_cols) <span class="op">=</span> <span class="cf">match</span> xloper_to_columns(<span class="op">$</span>x_range) <span class="op">{</span></span>
<span id="cb32-8"><a href="#cb32-8"></a>            <span class="cn">Ok</span>(v) <span class="op">=&gt;</span> v<span class="op">,</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>            <span class="cn">Err</span>(code) <span class="op">=&gt;</span> <span class="cf">return</span> return_xl_error(code)<span class="op">,</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>        <span class="op">};</span></span>
<span id="cb32-11"><a href="#cb32-11"></a>        (y<span class="op">,</span> x_vars)</span>
<span id="cb32-12"><a href="#cb32-12"></a>    <span class="op">}};</span></span>
<span id="cb32-13"><a href="#cb32-13"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Without this macro, every diagnostic UDF would repeat 8 lines of input parsing. With it, all 14 diagnostics fit in about 150 lines total.</p>
<p><strong>Batch 3: Cross-validation and prediction intervals</strong> (4 CV variants + 1 PI). These needed new output builders (<code>build_cv_output</code>, <code>build_pi_output</code>) but the UDF structure was familiar by this point. The CV UDFs add fold-count and standardization parameters. The PI UDF adds a new-data range and an alpha parameter.</p>
<p><strong>Batch 4: Polynomial and lambda path</strong> (2 UDFs). Polynomial reuses the OLS output builder (since polynomial regression is OLS on polynomial features). Lambda path needed its own single-column output builder.</p>
</section>
<section id="the-boilerplate-cost" class="level3">
<h3 class="anchored" data-anchor-id="the-boilerplate-cost">The Boilerplate Cost</h3>
<p>The per-UDF cost varies by complexity:</p>
<table class="table">
<colgroup>
<col style="width: 27%">
<col style="width: 37%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Category</th>
<th>Lines per UDF</th>
<th>What Varies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Diagnostics (simple)</td>
<td>5-10</td>
<td>Just the core function call</td>
</tr>
<tr class="even">
<td>Diagnostics (parameterized)</td>
<td>15-25</td>
<td>Extra parameter parsing</td>
</tr>
<tr class="odd">
<td>Regression (Ridge, Lasso)</td>
<td>35-40</td>
<td>Design matrix construction, options struct</td>
</tr>
<tr class="even">
<td>Regression (Elastic Net)</td>
<td>55-60</td>
<td>Most parameters of any UDF</td>
</tr>
<tr class="odd">
<td>Cross-validation</td>
<td>20-30</td>
<td>Fold count and optional standardization</td>
</tr>
</tbody>
</table>
<p>The output builders are shared across categories and account for most of the remaining code in <code>mod.rs</code>. <code>build_ols_output</code> serves OLS and Polynomial (polynomial delegates to it directly). WLS, Ridge, Lasso, and Elastic Net each have their own builders for their method-specific summary rows. The 9 simple diagnostics share <code>build_simple_diagnostic</code> and <code>build_diagnostic_2x2</code>; the influence diagnostics use <code>build_vector_column</code> (Cook’s Distance, DFFITS) and custom inline builders (VIF, DFBETAS, Breusch-Godfrey). <code>build_cv_output</code> serves all 4 CV variants.</p>
</section>
<section id="the-registration-side" class="level3">
<h3 class="anchored" data-anchor-id="the-registration-side">The Registration Side</h3>
<p>Each UDF also needs a <code>reg.add()</code> call in <code>xlAutoOpen</code>. These are about 10 lines each: the export name, type string, Excel name, argument names, category, description, and per-argument help text. For 27 UDFs, that is roughly 270 lines of registration calls. These are not generated. They are written by hand, and the type string must match the actual function signature. A mismatch (wrong number of <code>Q</code>s) means a crash or garbled arguments at runtime, with no compile-time warning.</p>
<p>This is the main motivation for a future <code>xllgen</code> proc-macro. The idea: annotate a Rust function with <code>#[xll_func]</code>, and the macro generates both the <code>extern "system"</code> wrapper and the registration call from the function signature. Similar to what <code>wasm-bindgen</code> does for WASM exports. That project has not started yet, but the 270 lines of hand-written registration calls are the clearest argument for it.</p>
<hr>
</section>
</section>
<section id="Section12" class="level2">
<h2 class="anchored" data-anchor-id="Section12">12. VBA vs XLL</h2>
<p>The VBA article and this article describe two ways to call the same Rust code from Excel. One goes through VBA macros and a DLL. The other goes through worksheet formulas and an XLL. Neither replaces the other. They are different delivery mechanisms for different use cases, powered by the same core library.</p>
<section id="side-by-side-comparison" class="level3">
<h3 class="anchored" data-anchor-id="side-by-side-comparison">Side-by-Side Comparison</h3>
<table class="table">
<colgroup>
<col style="width: 26%">
<col style="width: 46%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>VBA/DLL</th>
<th>XLL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>User interface</strong></td>
<td>VBA macro (Sub or Function)</td>
<td>Worksheet formula</td>
</tr>
<tr class="even">
<td><strong>Invocation</strong></td>
<td>User runs a macro or calls a VBA function</td>
<td>User types a formula in a cell</td>
</tr>
<tr class="odd">
<td><strong>Result delivery</strong></td>
<td>VBA pastes into a range</td>
<td>Excel spills automatically (365+)</td>
</tr>
<tr class="even">
<td><strong>Recalculation</strong></td>
<td>Manual (user re-runs the macro)</td>
<td>Automatic (input cells change, output updates)</td>
</tr>
<tr class="odd">
<td><strong>State</strong></td>
<td>Stateful: handle store, explicit free</td>
<td>No handles; cleanup via <code>xlAutoFree12</code> (Excel-managed)</td>
</tr>
<tr class="even">
<td><strong>Install</strong></td>
<td>Copy DLL + import <code>.bas</code> module</td>
<td>Copy <code>.xll</code> + add via Add-in Manager</td>
</tr>
<tr class="odd">
<td><strong>Portability</strong></td>
<td>Workbook + DLL in same folder</td>
<td>Add-in is external to any workbook</td>
</tr>
<tr class="even">
<td><strong>Architecture support</strong></td>
<td>32-bit and 64-bit (separate DLLs)</td>
<td>64-bit only (current implementation)</td>
</tr>
<tr class="odd">
<td><strong>Excel version</strong></td>
<td>Office 2010+ (VBA7 required)</td>
<td>Excel 2007+ (XLOPER12 API)</td>
</tr>
<tr class="even">
<td><strong>Function Wizard</strong></td>
<td>Limited (appears under “User Defined,” no categories or help text unless you add <code>MacroOptions</code> calls)</td>
<td>Full integration (custom category, per-argument help text)</td>
</tr>
<tr class="odd">
<td><strong>Error reporting</strong></td>
<td><code>LR_GetLastError</code> string from thread-local buffer</td>
<td>Native Excel error cells (<code>#NUM!</code>, <code>#VALUE!</code>)</td>
</tr>
<tr class="even">
<td><strong>Multi-step workflows</strong></td>
<td>Yes (loops, conditionals, UI interaction)</td>
<td>No (each formula is one call)</td>
</tr>
<tr class="odd">
<td><strong>Boundary type</strong></td>
<td>Raw scalars (<code>*const f64</code>, <code>i32</code>, <code>usize</code>)</td>
<td>Structured (<code>XLOPER12</code>)</td>
</tr>
<tr class="even">
<td><strong>Calling convention sync</strong></td>
<td><code>Declare PtrSafe Function</code> in VBA</td>
<td><code>reg.add()</code> in Rust</td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="xll_vba_ownership_protocols.png" class="lightbox" data-glightbox="description: .lightbox-desc-7" data-gallery="quarto-lightbox-gallery-7" title="Figure 8: Ownership Protocols Compared (VBA DLL vs XLL). VBA uses an explicit handle lifecycle and manual free calls; XLL uses xlbitDLLFree plus the xlAutoFree12 callback, so cleanup is automatic after Excel copies the result."><img src="xll_vba_ownership_protocols.png" class="img-fluid figure-img" alt="Two side‑by‑side cards compare ownership protocols. Left card (“VBA DLL”) shows a 4‑step manual lifecycle: allocate + store handle, return handle, getters copy out, explicit LR_Free. Right card (“XLL”) shows a 4‑step callback lifecycle: allocate XLOPER12 + set xlbitDLLFree, return pointer, Excel copies to sheet, Excel calls xlAutoFree12. "></a></p>
<figcaption>Figure 8: Ownership Protocols Compared (VBA DLL vs XLL). VBA uses an explicit handle lifecycle and manual free calls; XLL uses xlbitDLLFree plus the xlAutoFree12 callback, so cleanup is automatic after Excel copies the result.</figcaption>
</figure>
</div>
</section>
<section id="when-xll-makes-sense" class="level3">
<h3 class="anchored" data-anchor-id="when-xll-makes-sense">When XLL Makes Sense</h3>
<p>The XLL shines when the deliverable is a reusable tool. Install the add-in once, and every workbook on that machine can use it. Formulas recalculate live when the data changes. The Function Wizard shows argument help. The user does not need to know what Rust is, what a DLL is, or what VBA is. They type a formula and get a result.</p>
<p>This is the right delivery mechanism when the audience is someone who uses Excel but does not program in it. The mechanical engineer from the introduction who runs regressions but has never touched VBA. For that person, <code>=LINREG.OLS(A1:A20, B1:E20)</code> is a formula like any other. <code>LINREG.BREUSCHPAGAN(A1:A20, B1:E20)</code> is another formula. There is nothing to learn except the function names.</p>
</section>
<section id="when-vbadll-makes-sense" class="level3">
<h3 class="anchored" data-anchor-id="when-vbadll-makes-sense">When VBA/DLL Makes Sense</h3>
<p>The VBA/DLL approach shines when the deliverable is a workbook paired with a DLL in the same folder. The workbook carries its macros and data; the DLL sits alongside it and is loaded at runtime via <code>LR_Init</code>. There is no add-in install step, no system-wide registration. The user opens the workbook from the folder and it works.</p>
<p>VBA also supports workflows that worksheet formulas cannot express. A macro can fit a model, inspect the R-squared, conditionally run diagnostics, format the output, and paste results into specific cells with custom formatting. That kind of multi-step logic does not map to a single formula. The XLL’s statelessness, which is an advantage for simplicity, is a limitation for complex workflows.</p>
</section>
<section id="the-failure-modes" class="level3">
<h3 class="anchored" data-anchor-id="the-failure-modes">The Failure Modes</h3>
<p>Both approaches have their own ways of failing silently. The VBA article covered the maintenance burden of keeping four parallel surfaces in sync (Rust exports, <code>.def</code> file, VBA declarations, VBA wrapper code). The XLL has a different set:</p>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Mistake</th>
<th>Symptom</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forget <code>xlbitDLLFree</code> on a returned XLOPER12</td>
<td>Every call to that UDF leaks memory silently</td>
</tr>
<tr class="even">
<td>Forget to register a UDF in <code>xlAutoOpen</code></td>
<td>Function exists in the DLL but shows <code>#NAME?</code> in Excel</td>
</tr>
<tr class="odd">
<td>Wrong type string (wrong number of <code>Q</code>s)</td>
<td>Crash or garbled arguments at runtime</td>
</tr>
<tr class="even">
<td>Forget <code>xlAutoFree12</code> entirely</td>
<td>Excel never reclaims any DLL-allocated memory</td>
</tr>
<tr class="odd">
<td>Wrong <code>extern "system"</code> signature</td>
<td>Stack corruption on every call</td>
</tr>
</tbody>
</table>
<p>None of these produce compile-time errors. The type string is a runtime-only contract between the registration call and the actual function signature. This is the same category of problem as the VBA <code>Declare PtrSafe Function</code> statements: a parallel declaration that must match the implementation exactly, with no compiler to enforce it.</p>
</section>
<section id="the-marginal-cost" class="level3">
<h3 class="anchored" data-anchor-id="the-marginal-cost">The Marginal Cost</h3>
<p>The VBA article made the argument that the FFI layer was worth building because the library already existed. The same argument applies here, even more strongly. The XLL layer is 5 files in <code>src/xll/</code>, one feature flag (<code>xll = []</code>), and zero new dependencies. The core library did not change. The QR decomposition, the coordinate descent solver, the distribution functions, every diagnostic test: all of it was already written, already tested against R and Python across 20 datasets. The XLL is a new boundary layer on top of the same computation.</p>
<p>The difference from the VBA approach is what the XLL layer does <em>not</em> need. No handle store. No <code>Mutex</code>. No <code>HashMap</code>. No <code>.def</code> file. No <code>build.rs</code> logic for the linker (the existing <code>build.rs</code> only fires for the <code>ffi</code> feature on 32-bit targets). No thread-local error buffer. The statefulness that dominated the VBA design is absent here because the XLL protocol is inherently stateless: Excel calls a function, gets a result, frees it. There is nothing to manage between calls.</p>
<p>The trade-off is a lower-level memory protocol. <code>Box::into_raw</code>, <code>Vec::from_raw_parts</code>, <code>xlbitDLLFree</code>, <code>xlAutoFree12</code>. But those operations are concentrated in a small number of functions and exercised by 165 automated tests. The per-UDF cost is low because the infrastructure absorbs the complexity.</p>
<hr>
</section>
</section>
<section id="Section13" class="level2">
<h2 class="anchored" data-anchor-id="Section13">13. Building and Installing the XLL</h2>
<section id="the-build-command" class="level3">
<h3 class="anchored" data-anchor-id="the-build-command">The Build Command</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1"></a><span class="ex">cargo</span> build <span class="at">--release</span> <span class="at">--features</span> xll <span class="at">--no-default-features</span> <span class="at">--target</span> x86_64-pc-windows-msvc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>--target</code> flag is technically optional if your default Rust toolchain already targets x64 MSVC (the common case on 64-bit Windows with Visual Studio installed), but including it makes the intent explicit and avoids surprises if a GNU toolchain is the default.</p>
<p>The other two flags are required.</p>
<p><code>--features xll</code> enables the XLL module (<code>src/xll/</code> and its four submodules). <code>--no-default-features</code> disables the default <code>wasm</code> feature. These two features are mutually exclusive build targets. The <code>wasm</code> feature pulls in <code>wasm-bindgen</code>, <code>web-sys</code>, <code>js-sys</code>, <code>csv</code>, and <code>getrandom</code> (with its <code>js</code> feature) as dependencies, and targets a browser sandbox. The <code>xll</code> feature pulls in nothing (<code>xll = []</code> in <code>Cargo.toml</code>) and targets Excel’s native C API. Building with both active on a native Windows target will fail because the <code>wasm</code> feature depends on <code>wasm-bindgen</code> and related crates that only compile for <code>wasm32</code>.</p>
<p>The feature definition in <code>Cargo.toml</code> is:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource toml number-lines code-with-copy"><code class="sourceCode toml"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">[features]</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="dt">default</span> <span class="op">=</span> <span class="op">[</span><span class="st">"wasm"</span><span class="op">]</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="dt">xll</span> <span class="op">=</span> <span class="op">[]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>No optional dependencies. No <code>build.rs</code> logic. The existing <code>build.rs</code> only fires for the <code>ffi</code> feature on 32-bit targets (to supply a <code>.def</code> file for stdcall name decoration). The XLL build does not need a <code>.def</code> file because it targets x64 only, where <code>extern "system"</code> does not decorate symbol names.</p>
</section>
<section id="the-output" class="level3">
<h3 class="anchored" data-anchor-id="the-output">The Output</h3>
<p>When <code>--target</code> is specified, the build produces <code>target/x86_64-pc-windows-msvc/release/linreg_core.dll</code>. (If you omit <code>--target</code> and x64 MSVC is your default, the output is <code>target/release/linreg_core.dll</code> instead.) Excel expects the <code>.xll</code> extension to recognize the file as an add-in, so you rename it:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1"></a><span class="fu">cp</span> target/x86_64-pc-windows-msvc/release/linreg_core.dll linreg_core_xll_x64.xll</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That is the entire build artifact. One file, no sidecar resources, no configuration files.</p>
</section>
<section id="no-external-dependencies" class="level3">
<h3 class="anchored" data-anchor-id="no-external-dependencies">No External Dependencies</h3>
<p>The <code>.cargo/config.toml</code> in this project sets <code>+crt-static</code> for MSVC targets:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource toml number-lines code-with-copy"><code class="sourceCode toml"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">[target.x86_64-pc-windows-msvc]</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="dt">rustflags</span> <span class="op">=</span> <span class="op">[</span><span class="st">"-C"</span><span class="op">,</span> <span class="st">"target-feature=+crt-static"</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This statically links the C runtime into the DLL. Without it, the XLL would depend on VCRUNTIME140.dll and the Universal CRT DLLs (<code>api-ms-win-crt-*.dll</code>), which require the Visual C++ Redistributable to be installed. With <code>+crt-static</code>, the only remaining dependencies are system DLLs present on Windows 8 and later: KERNEL32.dll, ntdll.dll, bcryptprimitives.dll, and api-ms-win-core-synch-l1-2-0.dll. The same approach as the VBA DLL, for the same reason: the XLL must work on machines where the user has never installed a development tool.</p>
</section>
<section id="x64-only" class="level3">
<h3 class="anchored" data-anchor-id="x64-only">x64 Only</h3>
<p>Unlike the VBA approach, which needed separate 32-bit and 64-bit DLLs (with a <code>.def</code> file and <code>build.rs</code> linker logic for the 32-bit variant), the XLL targets 64-bit Office only. This is a deliberate simplification. 64-bit Office is the dominant modern installation. Dropping 32-bit support eliminates the <code>.def</code> file, the <code>build.rs</code> logic, and the need to test two separate DLLs.</p>
<p>If 32-bit support becomes necessary in the future, the XLL code itself would not change. The <code>extern "system"</code> calling convention handles the stdcall/x64 difference automatically. The only addition would be a <code>.def</code> file to strip the <code>_FunctionName@N</code> decoration that the MSVC linker applies on 32-bit stdcall exports, the same mechanism described in the VBA article.</p>
</section>
<section id="installation" class="level3">
<h3 class="anchored" data-anchor-id="installation">Installation</h3>
<ol type="1">
<li>Open Excel.</li>
<li>Go to File &gt; Options &gt; Add-ins.</li>
<li>At the bottom, select “Excel Add-ins” from the Manage dropdown and click Go.</li>
<li>Click Browse, navigate to the <code>.xll</code> file, and click OK.</li>
<li>The add-in appears in the list with a checkbox. Confirm with OK.</li>
<li>Type <code>=LINREG.VERSION()</code> in any cell to verify. It should return the library version string.</li>
</ol>
<p>Alternatively, copy the <code>.xll</code> to the trusted add-in folder (the default location that Excel’s Add-in Manager browses to). On most installations, this is <code>%APPDATA%\Microsoft\AddIns\</code>. Once there, it appears in the Add-in Manager without needing to browse.</p>
</section>
<section id="the-dll-lock" class="level3">
<h3 class="anchored" data-anchor-id="the-dll-lock">The DLL Lock</h3>
<p>Excel locks the XLL file while it is loaded. You cannot overwrite <code>linreg_core_xll_x64.xll</code> while Excel has it open. During development, the cycle is: close Excel, rebuild, copy the new XLL, reopen Excel. This is the same behavior as any DLL loaded into a running process, but it is worth noting because it makes the iteration loop slower than a typical Rust compile-run cycle.</p>
<p>The automated test suite (Section 10) exists partly because of this friction. Testing in Excel means rebuilding, closing, copying, reopening, and reloading for every change. Testing in Rust means <code>cargo test --features xll --no-default-features</code> and a result in seconds.</p>
</section>
<section id="code-signing" class="level3">
<h3 class="anchored" data-anchor-id="code-signing">Code Signing</h3>
<p>The XLL is not code-signed. When a user loads an unsigned add-in, Excel may show a security warning depending on the Trust Center settings. The user must choose to enable the add-in. In enterprise environments with strict macro policies, an unsigned XLL may be blocked entirely.</p>
<p>Code signing is future work. The XLL itself is structurally ready for it (it is a standard PE DLL), but acquiring a code-signing certificate and integrating signing into the build process has not been done yet.</p>
<hr>
</section>
</section>
<section id="Section14" class="level2">
<h2 class="anchored" data-anchor-id="Section14">14. Lessons Learned</h2>
<p>The earlier sections describe the XLL as it exists today. This section is about the things that were not obvious until I hit them, and the non-obvious properties that anyone building an XLL in Rust should know about going in.</p>
<section id="nil-renders-as-zero" class="level3">
<h3 class="anchored" data-anchor-id="nil-renders-as-zero"><code>nil()</code> Renders as Zero</h3>
<p>This one cost me time early on. When building a result array, summary rows like “R-squared” have a value in the second column and nothing in columns 3 through 5. The natural way to represent “nothing” in the XLOPER12 type system is <code>XLOPER12::nil()</code>, which sets <code>xltype = XLTYPE_NIL</code>. But Excel renders <code>xltypeNil</code> as <code>0</code> when it appears inside a spilled <code>xltypeMulti</code> array. A summary row that should look like <code>R-squared | 0.9234 |  |  |</code> instead looks like <code>R-squared | 0.9234 | 0 | 0 | 0</code>.</p>
<p>The fix is <code>XLOPER12::from_str("")</code>. An empty string renders as a visually blank cell. Every output builder in the XLL uses <code>from_str("")</code> for padding cells, never <code>nil()</code>. It is a small thing, but it is the difference between output that looks professional and output that looks broken.</p>
</section>
<section id="single-cells-arrive-as-scalars" class="level3">
<h3 class="anchored" data-anchor-id="single-cells-arrive-as-scalars">Single Cells Arrive as Scalars</h3>
<p>When a user passes a single cell as an argument (e.g., <code>=LINREG.OLS(A1, B1)</code>), Excel does not wrap it in a 1x1 <code>xltypeMulti</code> array. It arrives as a bare <code>xltypeNum</code> (or <code>xltypeStr</code>, <code>xltypeErr</code>, etc.). Every conversion function in <code>convert.rs</code> must handle both paths: the scalar case and the multi-cell case.</p>
<p>I discovered this the hard way. The first version of <code>xloper_to_f64_vec</code> only handled <code>xltypeMulti</code>. Passing a single cell returned <code>#VALUE!</code>. The fix was straightforward (add a <code>XLTYPE_NUM</code> match arm that wraps the value in a one-element <code>Vec</code>), but the failure mode was confusing because the same formula worked fine with two or more cells. The doc comment at the top of <code>convert.rs</code> now lists this as one of the gotchas discovered during development.</p>
</section>
<section id="extern-system-not-extern-stdcall" class="level3">
<h3 class="anchored" data-anchor-id="extern-system-not-extern-stdcall"><code>extern "system"</code>, Not <code>extern "stdcall"</code></h3>
<p>All exported functions in the XLL use <code>extern "system"</code>. On 32-bit Windows, <code>extern "system"</code> is equivalent to <code>extern "stdcall"</code>. On 64-bit Windows, it maps to the standard x64 calling convention. The important thing is that <code>extern "system"</code> does the right thing on both architectures without conditional compilation.</p>
<p>Some existing XLL crates on crates.io use <code>extern "stdcall"</code> directly. On x64 targets, the Rust compiler emits a warning for <code>extern "stdcall"</code> (<code>unsupported_calling_conventions</code>) because stdcall was never specified for x64. As of early 2025, this warning is being phased into a hard error in a future Rust release. <code>extern "system"</code> avoids the issue entirely.</p>
</section>
<section id="you-do-not-need-an-sdk" class="level3">
<h3 class="anchored" data-anchor-id="you-do-not-need-an-sdk">You Do Not Need an SDK</h3>
<p>This was the most consequential discovery of the project. The conventional wisdom for building an XLL involves external files: a header for type definitions, a C source file for the callback trampoline, and an import library to link against. I assumed I would need at least the import library.</p>
<p>In practice, the entire XLL infrastructure can be implemented in pure Rust:</p>
<ul>
<li><strong>Type definitions</strong>: <code>#[repr(C)]</code> structs in <code>types.rs</code> (about 210 lines)</li>
<li><strong>Callback resolution</strong>: <code>GetModuleHandleA</code> / <code>GetProcAddress</code> in <code>entrypoint.rs</code> (about 100 lines)</li>
<li><strong>Registration</strong>: <code>xlfRegister</code> calls through the trampoline in <code>register.rs</code> (about 130 lines)</li>
<li><strong>Type conversion</strong>: XLOPER12-to-Rust and Rust-to-XLOPER12 in <code>convert.rs</code> (about 150 lines)</li>
</ul>
<p>Four files, roughly 590 lines of infrastructure code. No C compiler in the build chain, no external files to download, no import library. The <code>xll</code> feature in <code>Cargo.toml</code> is <code>xll = []</code> because there is nothing to depend on.</p>
</section>
<section id="function-wizard-truncation" class="level3">
<h3 class="anchored" data-anchor-id="function-wizard-truncation">Function Wizard Truncation</h3>
<p>The per-argument help text in the Function Wizard has practical limits. Long descriptions get cut off in the dialog. Newlines are not supported; if you put <code>\n</code> in a help string, it renders as a literal <code>\n</code>. For UDFs with complex argument semantics (Elastic Net has five parameters), the help text must be kept concise or the user will not see the full description.</p>
<p>The proper solution is an HTML help file referenced via the <code>help_topic</code> parameter in the <code>xlfRegister</code> call. I pass <code>xltypeMissing</code> for that parameter because I have not built the help file yet. It is future work, but worth noting for anyone who plans to write more than a few sentences of per-argument documentation.</p>
</section>
<section id="dynamic-arrays-just-work" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-arrays-just-work">Dynamic Arrays Just Work</h3>
<p>In Excel 365+, returning an <code>xltypeMulti</code> from a UDF naturally spills into surrounding cells. No special flags, no array formula syntax, no Ctrl+Shift+Enter. The same XLOPER12 that would require CSE entry in legacy Excel (2019 and earlier) spills automatically in 365. I did not need to write any code to support this; it is a property of the Excel version, not of the XLL.</p>
<p>This is worth noting for readers who may be targeting older Excel versions. On pre-365 Excel, the user must select the output range, type the formula, and press Ctrl+Shift+Enter to commit it as an array formula. The XLL code is identical in both cases. The difference is entirely on Excel’s side.</p>
</section>
<section id="statelessness-is-a-feature" class="level3">
<h3 class="anchored" data-anchor-id="statelessness-is-a-feature">Statelessness Is a Feature</h3>
<p>The VBA article’s centerpiece design decision was the handle store: a <code>HashMap</code> behind a <code>Mutex</code>, monotonic IDs, explicit free calls, thread safety considerations, idempotent double-free. The handle store was necessary because VBA workflows are multi-step: fit a model, then query it for coefficients, then query it for diagnostics, then free it.</p>
<p>XLL UDFs have no shared state. Each call is self-contained: parse inputs from XLOPER12s into Rust-owned Vecs, call the core function, build the output XLOPER12, return a pointer. Nothing persists between calls. No <code>Mutex</code>. No <code>HashMap</code>. No handle lifecycle.</p>
<p>This is what makes thread-safe registration (the <code>$</code> modifier in the type string) trivial. Excel can call the same UDF from multiple recalculation threads simultaneously, and there is no shared data to protect. If the XLL had a handle store, thread-safe registration would require the same <code>Mutex</code> synchronization the VBA DLL needs. Without it, thread safety is free.</p>
</section>
<section id="test-at-the-boundary-not-just-the-core" class="level3">
<h3 class="anchored" data-anchor-id="test-at-the-boundary-not-just-the-core">Test at the Boundary, Not Just the Core</h3>
<p>Section 10 covers the test infrastructure in detail. The lesson here is shorter: do not test the Rust core and assume the XLL layer is correct. The XLL layer has its own failure modes (wrong array dimensions, missing <code>xlbitDLLFree</code> flags, incorrect string encoding, broken error propagation) that are invisible to core-level tests. The 165 tests in the XLL suite call the actual <code>extern "system"</code> functions with actual XLOPER12 inputs and verify the actual XLOPER12 outputs. They exercise the same code path that Excel will call, including the memory cleanup in <code>xlAutoFree12</code>.</p>
<p>The <code>xlbitDLLFree</code> bug found during this article’s writing process (Section 10) is the clearest illustration. Error XLOPER12s were missing the flag, which meant every error return leaked 32 bytes. Core-level tests would never catch this because the core does not know about XLOPER12 flags. Only boundary-level tests that inspect the returned XLOPER12’s <code>xltype</code> field could detect it.</p>
<hr>
</section>
</section>
<section id="Section15" class="level2">
<h2 class="anchored" data-anchor-id="Section15">15. Conclusion</h2>
<p>The architecture of the XLL, end to end, is three layers:</p>
<ol type="1">
<li><p><strong>Rust core.</strong> OLS, Ridge, Lasso, Elastic Net, WLS, Polynomial, 14 diagnostic tests, cross-validation, prediction intervals. Custom linear algebra, custom distribution functions, no external math dependencies. This layer knows nothing about Excel, XLOPER12, or Windows calling conventions. It is the same code that compiles to WebAssembly, links into the Python bindings, and backs the VBA DLL.</p></li>
<li><p><strong>XLL boundary layer.</strong> 27 <code>extern "system"</code> UDF functions, plus the four Excel callbacks (<code>xlAutoOpen</code>, <code>xlAutoClose</code>, <code>xlAutoFree12</code>, <code>xlAddInManagerInfo12</code>). Each UDF parses XLOPER12 inputs into Rust types, calls the core, and builds an XLOPER12 result. Memory ownership transfers cleanly: <code>Box::into_raw</code> on the way out, <code>Box::from_raw</code> and <code>Vec::from_raw_parts</code> on the way back through <code>xlAutoFree12</code>. No shared state between calls.</p></li>
<li><p><strong>Excel.</strong> The host process. It loads the XLL, calls <code>xlAutoOpen</code> to learn what UDFs are available, calls them when formulas reference them, and calls <code>xlAutoFree12</code> when it is done with each result. The user types <code>=LINREG.OLS(A1:A20, B1:E20)</code> and gets a coefficient table. They do not know Rust is involved.</p></li>
</ol>
<p>That is the full path from a cell reference to a regression result: cell range to XLOPER12 to <code>Vec&lt;f64&gt;</code> to core computation to <code>RegressionOutput</code> to XLOPER12 array to spilled cells. Every layer has exactly one responsibility, and the boundaries between them are <code>#[repr(C)]</code> structs that both sides agree on.</p>
<section id="the-ownership-insight" class="level3">
<h3 class="anchored" data-anchor-id="the-ownership-insight">The Ownership Insight</h3>
<p>The broader lesson from this project is that Rust’s ownership model is not limited to Rust code. The XLOPER12 memory contract is an ownership protocol: the DLL allocates, sets a flag to declare ownership, hands a raw pointer to Excel, and Excel calls back when it is done so the DLL can reclaim the memory. That is <code>Box::into_raw</code> / <code>xlAutoFree12</code>, which is just Rust ownership transfer expressed through a C API.</p>
<p>In the VBA article, the same insight appeared in a different form: <code>Box::into_raw</code> for the handle store, <code>Box::from_raw</code> in <code>LR_Free</code>. The mechanism is the same. What changed is the protocol around it. The VBA approach required a handle store and explicit free calls because VBA workflows are multi-step. The XLL approach requires none of that because Excel provides the callback. The ownership transfer is the constant; the surrounding protocol is the variable.</p>
</section>
<section id="the-testing-story" class="level3">
<h3 class="anchored" data-anchor-id="the-testing-story">The Testing Story</h3>
<p>165 tests exercise the exact code paths Excel will call. They construct <code>#[repr(C)]</code> XLOPER12 structs byte-identical to what Excel constructs, pass them to the same <code>extern "system"</code> functions, inspect the returned XLOPER12 results cell by cell, and run <code>xlAutoFree12</code> to verify cleanup. Memory stress tests run 500 iterations per test, cycling through UDFs within each test, and a dedicated leak-detection test asserts that heap growth stays under 1 MB over the full run.</p>
<p>This is what “systems language safety” means in practice for an XLL. Not just that the core regression math is correct (the validation suite covers that against R and Python across 20 datasets), but that the boundary layer does not leak memory, does not corrupt strings, does not return wrong dimensions, and does not silently drop error flags. The boundary is where the bugs live, so the boundary is where the tests run.</p>
</section>
<section id="what-is-next" class="level3">
<h3 class="anchored" data-anchor-id="what-is-next">What Is Next</h3>
<p>The XLL layer is 5 source files and roughly 2,340 lines of Rust (about 590 lines of infrastructure across four files, and about 1,750 lines of UDF implementations, output builders, and registration calls in <code>mod.rs</code>). The per-UDF boilerplate is small but repetitive: type string, registration call, input parsing, output building. The 270 lines of hand-written <code>reg.add()</code> calls in <code>xlAutoOpen</code> are the clearest example of code that should be generated.</p>
<p>The next step, after a break, is making this pattern reusable. Two crates:</p>
<p><strong><code>xll-rs</code></strong>: the runtime library. The XLOPER12 type definitions, the trampoline, the registration helper, the conversion functions. Everything in <code>src/xll/</code> that is not specific to linreg-core.</p>
<p><strong><code>xllgen</code></strong>: a proc-macro crate. Annotate a Rust function with <code>#[xll_func]</code> and the macro generates the <code>extern "system"</code> wrapper, the type string, and the registration call from the function signature. Similar to what <code>wasm-bindgen</code> does for WASM exports. The goal is to reduce the per-UDF cost from 40 lines of boilerplate to a single attribute.</p>
<p>Neither crate exists yet. The XLL in this article is the proof of concept that validates the approach. The 27 UDFs work, the memory management is verified, and the pattern is clear enough to generalize.</p>
</section>
<section id="final-thoughts" class="level3">
<h3 class="anchored" data-anchor-id="final-thoughts">Final Thoughts</h3>
<p>The <a href="https://blog.jesse-anderson.net/posts/linreg_core_VBA_FFI/">VBA article</a> ended with the Chemical Engineering professor who built a process simulator in Excel with the heavy computation hidden in a DLL. It always seemed like magic. The magic is demystified now. I always knew it was programming; I just wondered how to get from A to B.</p>
<p>I showed the XLL to a few colleagues. They thought it was pretty interesting, and none of them expected Rust could be called from Excel like that. That reaction tells me something useful: if people are surprised it is possible, they are not going to build it themselves. You have to hand them a formula.</p>
<p>This is a nightly project, work done after hours in focused bursts. I already had the <a href="https://jesse-anderson.net/linreg-core/">WASM site</a> for people who want to run regressions in a browser. The XLL is for people who want to run them in Excel without leaving their workbook. The underlying Rust core and the R/Python validation are identical in both cases; only the delivery mechanism changed. I wanted something anyone could pick up and use, and a formula in a cell is about as low-friction as it gets.</p>
<p>The full source is at <a href="https://github.com/jesse-anderson/linreg-core">github.com/jesse-anderson/linreg-core</a>. The XLL is behind the <code>xll</code> feature flag. The VBA DLL is behind the <code>ffi</code> feature flag. Build instructions are in the repository README.</p>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">Figure 1: A single formula spills a full regression table; no VBA required.</span>
<span class="glightbox-desc lightbox-desc-2">Figure 2: Architecture: Excel calls XLL UDFs; XLOPER12 crosses the boundary to the Rust core.</span>
<span class="glightbox-desc lightbox-desc-3">Figure 3: Ownership lifecycle for returned XLOPER12 values (allocate -&gt; return -&gt; callback -&gt; reclaim).</span>
<span class="glightbox-desc lightbox-desc-4">Figure 4: Excel12v trampoline: runtime lookup and cached callback.</span>
<span class="glightbox-desc lightbox-desc-5">Figure 5: Function Wizard integration with per‑argument help.</span>
<span class="glightbox-desc lightbox-desc-6">Figure 7: Heap deltas stabilize under stress tests (leak‑free behavior).</span>
<span class="glightbox-desc lightbox-desc-7">Figure 8: Ownership Protocols Compared (VBA DLL vs XLL). VBA uses an explicit handle lifecycle and manual free calls; XLL uses xlbitDLLFree plus the xlAutoFree12 callback, so cleanup is automatic after Excel copies the result.</span>
</div>
</section>
</section>
</section>

</main> <!-- /main -->






    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Support Page</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <style>

        .centered-text {

            text-align: center; /* Centers text for elements with this class */

        }

        .centered-content {

            display: flex; /* Uses Flexbox for layout */

            justify-content: center; /* Horizontally centers the content within the container */

            align-items: center; /* Vertically centers the content within the container */

        }

        .email-share-button {

            background: #007BFF; /* Example: a distinct blue color for the email button */

            color: white; /* Ensure text and icon are white for visibility */

        }

        #share-buttons {

            display: flex;

            align-items: center;

            justify-content: center;

            gap: 5px;

        }

        .share-button {

            display: inline-flex;

            padding: 2px 4px;

            font-size: 14px;

            cursor: pointer;

            text-align: center;

            color: white;

            border-radius: 0px;

        }

    </style>





    <footer class="centered-text">

        <p>Copyright © <span id="copyright-year"></span> Jesse Anderson</p>

        <!-- Other footer details -->

    </footer>

    <div>

        <hr>

        <h3 class="centered-text">Support my work with a Coffee/Monster</h3>

        <div class="centered-content">

            <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="jesseanderson" data-color="#06436e" data-emoji="☕" data-font="Lato" data-text="Support me" data-outline-color="#ffffff" data-font-color="#ffffff" data-coffee-color="#FFDD00" data-height="40px"></script>

        </div>

        <!-- Footer content -->

        <h3 class="centered-text">Share</h3>

        <!-- Share Buttons -->

        <div id="share-buttons" class="centered-content">

            <!-- Twitter Share Button, dynamically setting the URL -->

            <a href="#" class="share-button twitter-share-button" data-size="large" data-hashtags="computerscience" data-via="JesseA7C5" data-show-count="false">Tweet</a>

            <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

            <!-- Facebook SDK with Dynamic Nonce -->

            <div id="fb-root"></div>

            <script id="facebook-jssdk" async="" defer="" crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&amp;version=v10.0"></script>

            <div class="fb-share-button share-button" data-href="" data-layout="button_count">

            </div>

            <!-- LinkedIn Share Button -->

            <script src="https://platform.linkedin.com/in.js" type="text/javascript">lang: en_US</script>

            <script type="IN/Share" data-url=""></script>

            <!-- Email Share Button -->

            <a href="#" class="share-button email-share-button"><i class="fas fa-envelope"></i></a>

        </div>

    </div>

    <script>

        // Function to generate a random nonce

        function generateNonce(length = 16) {

            const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

            let text = "";

            for (let i = 0; i < length; i++) {

                text += possible.charAt(Math.floor(Math.random() * possible.length));

            }

            return text;

        }

        // Set the nonce attribute for the Facebook SDK script and dynamically set URLs

        document.addEventListener('DOMContentLoaded', function() {

            const nonce = generateNonce();

            const facebookSDKScript = document.getElementById('facebook-jssdk');

            facebookSDKScript.setAttribute('nonce', nonce);

            var elems = document.querySelectorAll('script[type="IN/Share"]');

            for (var i = 0; i < elems.length; i++) {

                elems[i].setAttribute('data-url', window.location.href);

            }

            // Set dynamic URLs for social sharing

            const currentUrl = window.location.href;

            const currentTitle = document.title; // Use the current document title as the email subject

            // Facebook

            document.querySelector('.fb-share-button').setAttribute('data-href', currentUrl);

            // LinkedIn

            document.querySelectorAll('script[type="IN/Share"]')[0].setAttribute('data-url', currentUrl);

            // Twitter

            document.querySelector('.twitter-share-button').setAttribute('href', 'https://twitter.com/share?url=' + encodeURIComponent(currentUrl) + '&hashtags=rstats');

            // Email

            document.querySelector('.email-share-button').setAttribute('href', `mailto:?subject=${encodeURIComponent(currentTitle)}&body=Check out this link: ${encodeURIComponent(currentUrl)}`);

            // Dynamically set the current year in the copyright footer

            document.getElementById('copyright-year').textContent = new Date().getFullYear();

        });

        // This script below to put a latest posts list after the comment system was such a pain in the ass.

        document.addEventListener('DOMContentLoaded', function() {

            // console.log("Latest Posts Populating...");

            // Create the latest posts container

            const latestPostsContainer = document.createElement('div');

            latestPostsContainer.className = 'latest-posts';

            latestPostsContainer.innerHTML = `

                <h3>Latest Posts</h3>

                <ul id="latest-posts-list">

                    <!-- Latest posts will be inserted here -->

                </ul>

            `;

            // Find the footer element

            const footer = document.querySelector('footer.footer');

            // Insert the latest posts container before footer, easier than after utterances.

            footer.parentNode.insertBefore(latestPostsContainer, footer);

            // Fetch latest posts from the archive page

            fetch('https://jesse-anderson.github.io/Blog/_site/archive.html')

                .then(response => response.text())

                .then(data => {

                    const parser = new DOMParser();

                    const doc = parser.parseFromString(data, 'text/html');

                    const posts = doc.querySelectorAll('.quarto-listing-container-table tbody tr');

                    // console.log("Posts: ", posts);

                    const latestPostsList = document.getElementById('latest-posts-list');

                    let count = 0;

                    posts.forEach(post => {

                        if (count < 4) {

                            // console.log("Title populating...");

                            const titleElement = post.querySelector('.listing-title'); // Correctly select the <a> tag with the title class

                            // console.log(titleElement)

                              const imageElement = post.querySelector('.listing-image img');

                              // console.log(imageElement)

                            if (titleElement) {

                                const title = titleElement.textContent.trim();

                                // console.log('Title: ', title);

                                let url = titleElement.getAttribute('href');

                                // console.log('URL: ', url);

                                if (url && !url.startsWith('http')) {

                                    url = 'https://jesse-anderson.github.io/Blog/_site/' + url.replace(/^\.\//, '');

                                }

                                // console.log('Formatted URL: ', url);

                                const imageUrl = imageElement ? imageElement.getAttribute('src').replace(/^\.\//, 'https://jesse-anderson.github.io/Blog/_site/') : 'default-image.jpg'; // Fallback image

                                // console.log('Image URL: ', imageUrl);

                                const listItem = document.createElement('li');

                                listItem.innerHTML = `<a href="${url}"><img src="${imageUrl}" alt="Post Image" style="height: 20px;"> ${title}</a>`;

                                latestPostsList.appendChild(listItem);

                                // console.log('ListItem: ', listItem);

                                count++;

                            } else {

                                console.warn('Missing elements for post:', post);

                            }

                        }

                    });

                });

        });

    </script>





<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="jesse-anderson/blogComments" issue-term="title" theme="github-dark" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"descPosition":"bottom","openEffect":"zoom","selector":".lightbox","loop":false,"closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>